# Comparing `tmp/usls-0.0.9-py3-none-any.whl.zip` & `tmp/usls-0.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,22 @@
-Zip file size: 59937 bytes, number of entries: 20
--rw-rw-r--  2.0 unx      236 b- defN 23-Mar-20 01:47 usls/__init__.py
--rw-rw-r--  2.0 unx     4341 b- defN 23-Mar-20 01:45 usls/cli.py
--rw-rw-r--  2.0 unx    12030 b- defN 23-Mar-20 01:26 usls/run.py
--rw-rw-r--  2.0 unx      345 b- defN 23-Mar-20 01:26 usls/src/__init__.py
--rw-rw-r--  2.0 unx     2171 b- defN 23-Mar-20 01:26 usls/src/class_modify.py
--rw-rw-r--  2.0 unx     1598 b- defN 23-Mar-20 01:26 usls/src/deduplicate.py
--rw-rw-r--  2.0 unx     2537 b- defN 23-Mar-20 01:26 usls/src/dir_combine.py
--rw-rw-r--  2.0 unx     3204 b- defN 23-Mar-20 01:26 usls/src/label_combine.py
--rw-rw-r--  2.0 unx    18138 b- defN 23-Mar-20 01:26 usls/src/labelling_cls.py
--rw-rw-r--  2.0 unx    40640 b- defN 23-Mar-20 01:26 usls/src/labelling_det.py
--rw-rw-r--  2.0 unx    40823 b- defN 23-Mar-20 01:26 usls/src/labelling_det_2.py
--rw-rw-r--  2.0 unx     3299 b- defN 23-Mar-20 01:26 usls/src/spider.py
--rw-rw-r--  2.0 unx    18795 b- defN 23-Mar-20 01:26 usls/src/utils.py
--rw-rw-r--  2.0 unx     9193 b- defN 23-Mar-20 01:27 usls/src/video_tools.py
--rw-rw-r--  2.0 unx    35149 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/LICENSE
--rw-rw-r--  2.0 unx      588 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/WHEEL
--rw-rw-r--  2.0 unx       34 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx        5 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1551 b- defN 23-Mar-20 01:47 usls-0.0.9.dist-info/RECORD
-20 files, 194769 bytes uncompressed, 57457 bytes compressed:  70.5%
+Zip file size: 60855 bytes, number of entries: 20
+-rwxrwxrwx  2.0 unx      236 b- defN 23-Apr-27 09:14 usls/__init__.py
+-rwxrwxrwx  2.0 unx     1879 b- defN 23-Apr-27 09:16 usls/cli.py
+-rwxrwxrwx  2.0 unx    13002 b- defN 23-Apr-27 08:37 usls/run.py
+-rwxrwxrwx  2.0 unx      345 b- defN 23-Apr-27 06:18 usls/src/__init__.py
+-rwxrwxrwx  2.0 unx     2171 b- defN 23-Apr-27 06:18 usls/src/class_modify.py
+-rwxrwxrwx  2.0 unx     1598 b- defN 23-Apr-27 06:18 usls/src/deduplicate.py
+-rwxrwxrwx  2.0 unx     2537 b- defN 23-Apr-27 06:18 usls/src/dir_combine.py
+-rwxrwxrwx  2.0 unx     3204 b- defN 23-Apr-27 06:18 usls/src/label_combine.py
+-rwxrwxrwx  2.0 unx    18138 b- defN 23-Apr-27 06:18 usls/src/labelling_cls.py
+-rwxrwxrwx  2.0 unx    41064 b- defN 23-Apr-27 08:44 usls/src/labelling_det.py
+-rwxrwxrwx  2.0 unx    40829 b- defN 23-Apr-27 07:16 usls/src/labelling_det_2.py
+-rwxrwxrwx  2.0 unx     3299 b- defN 23-Apr-27 06:18 usls/src/spider.py
+-rwxrwxrwx  2.0 unx    24160 b- defN 23-Apr-27 09:19 usls/src/utils.py
+-rwxrwxrwx  2.0 unx     9416 b- defN 23-Apr-27 08:25 usls/src/video_tools.py
+-rwxrwxrwx  2.0 unx    35149 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/LICENSE
+-rwxrwxrwx  2.0 unx      588 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/METADATA
+-rwxrwxrwx  2.0 unx       92 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/WHEEL
+-rwxrwxrwx  2.0 unx       34 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/entry_points.txt
+-rwxrwxrwx  2.0 unx        5 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1551 b- defN 23-Apr-27 09:19 usls-0.1.0.dist-info/RECORD
+20 files, 199297 bytes uncompressed, 58375 bytes compressed:  70.7%
```

## zipnote {}

```diff
@@ -36,26 +36,26 @@
 
 Filename: usls/src/utils.py
 Comment: 
 
 Filename: usls/src/video_tools.py
 Comment: 
 
-Filename: usls-0.0.9.dist-info/LICENSE
+Filename: usls-0.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: usls-0.0.9.dist-info/METADATA
+Filename: usls-0.1.0.dist-info/METADATA
 Comment: 
 
-Filename: usls-0.0.9.dist-info/WHEEL
+Filename: usls-0.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: usls-0.0.9.dist-info/entry_points.txt
+Filename: usls-0.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: usls-0.0.9.dist-info/top_level.txt
+Filename: usls-0.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: usls-0.0.9.dist-info/RECORD
+Filename: usls-0.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## usls/__init__.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*- 
 
 
-__version__ = '0.0.9'
+__version__ = '0.1.0'
 
 from usls.cli import cli
 from usls.run import run
 from usls.src import resource_info
 
 
 __all__ = [
```

## usls/cli.py

```diff
@@ -1,108 +1,22 @@
 import sys
 import rich
 import re
 from omegaconf import OmegaConf, DictConfig
 
 from usls import __version__
 from usls.run import run
-from usls.src.utils import LOGGER
+from usls.src.utils import LOGGER, CLI_MSG_TABLE, CONSOLE
 
 
 
-CLI_MSG = '''
-  Uselesss Usage: 
-	-----------------------------
-	Special options:
-	-----------------------------
-	-h, -H, --help     	 package usage
-	-v, -V, --version  	 package version
-
-	-----------------------------
-	Format:
-	-----------------------------
-	> fx task=xxx sth=sth 
-
-	-----------------------------
-	common toolkits
-	-----------------------------
-
-	-----------------------------
-	Detection Labelling 
-	-----------------------------
-	> usls task=inspect img_dir=sth {label_dir=sth} classes=sth,sth,sth {window_width=800 window_height=600 mv_dir=moved_dir wrong_img_dir=sth}
-
-	-----------------------------
-	Classification Labelling 
-	-----------------------------
-	> usls task=classify img_dir=sth {label_dir=sth} classes=sth,sth,sth {window_width=800 window_height=600 mv_dir=moved_dir wrong_img_dir=sth}
-
-	-----------------------------
-	Image & Label dir info 
-	-----------------------------
-	> usls task=info img_dir=sth {label_dir=sth}
-
-	-----------------------------
-	Clean-up Image & Label Dir 
-	-----------------------------
-	> usls task=clean img_dir=sth {label_dir=sth mv_dir=sth clean_empty=True}
-
-	-----------------------------
-	Combine labels
-	-----------------------------
-	> usls task=label_combine input_dir=sth {output_dir=output-label-combine}
-
-	-----------------------------
-	Combine dirs
-	-----------------------------
-	> usls task=dir_combine input_dir=sth {output_dir=output-dir-combine suffix=[] move=False}
-
-	-----------------------------
-	Video -> Images
-	-----------------------------
-	> usls task=v2is source=sth {output_dir=v2is frame=20 view=False flip=False fmt_img=.jpg}
-	
-	-----------------------------
-	Videos -> Images
-	-----------------------------
-	> usls task=vs2is input_dir=sth {output_dir=vs2is frame=20 view=False flip=False fmt_img=.jpg}
-
-	-----------------------------
-	Images -> Video
-	-----------------------------
-	> usls task=is2v input_dir=sth {output_dir=vs2is fps=30 last4=60 video_size=640}
-
-	-----------------------------
-	Play videos/streams & Record(Press `r/R` to record when playing.)
-	-----------------------------
-	> usls task=play source=sth {delay=1 flip=False}
-
-	-----------------------------
-	Spider
-	-----------------------------
-	> usls task=spider words=sth
-
-	-----------------------------
-	De-duplicate
-	-----------------------------
-	> usls task=deduplicate input_dir=sth {mv_dir=sth}
-
-	-----------------------------
-	Label Class Modify
-	-----------------------------
-	> usls task=class_modify input_dir=sth to=7
-
-
-'''
-
-
 SPECIALS = {
-	'--help': lambda: rich.print(CLI_MSG),
-	'-H': lambda: rich.print(CLI_MSG),
-	'-h': lambda: rich.print(CLI_MSG),
+	'--help': lambda: CONSOLE.print(CLI_MSG_TABLE()),
+	'-H': lambda: CONSOLE.print(CLI_MSG_TABLE()),
+	'-h': lambda: CONSOLE.print(CLI_MSG_TABLE()),
 	'--version': lambda: rich.print(f"> uselesss version: {__version__}"),
 	'-V': lambda: rich.print(f"> uselesss version: {__version__}"),
 	'-v': lambda: rich.print(f"> uselesss version: {__version__}"),
 }
 
 
 # support task list
@@ -124,15 +38,15 @@
 )
 
 
 def cli() -> None:
 	args = sys.argv[1:]
 
 	if not args:
-		rich.print(f">\n{CLI_MSG}")
+		CONSOLE.print(CLI_MSG_TABLE())
 		return 
 
 	cmd = {'task': 'untitled'} 	# default  TODO: msg
 
 	# argv[1:]
 	for idx, x in enumerate(args):
 
@@ -141,15 +55,15 @@
 			if x in SPECIALS.keys():
 				SPECIALS[x]()
 				return
 
 		else:	# must use '=' to specify args
 			if '=' in x:
 				try:
-					k, v = x.strip().split('=', 1)  # only catch 1st =
+					k, v = x.strip().split('=', 1)
 					if k == 'task':
 						assert v in TASKS, f"> Error: Task support: {TASKS} for now!"
 					cmd.update({k: v})
 				except Exception as E:
 					rich.print(f'{E}')
 					sys.exit(1)
```

## usls/run.py

```diff
@@ -8,55 +8,51 @@
 import sys
 import random
 import time
 from omegaconf import OmegaConf, DictConfig
 
 # ---------------------------------------------------------------------------------------------
 from usls.src.utils import (
-    get_corresponding_label_path, Colors, load_img_label_list,
-    img_label_dir_cleanup, get_img_path, LOGGER, IMG_FORMAT, 
-    is_point_in_rect
+    get_corresponding_label_path, Colors, load_from_dir,
+    img_label_dir_cleanup, get_img_path, LOGGER, IMG_FORMAT, VIDEO_FORMAT,
+    is_point_in_rect, CONSOLE
 )
 from usls.src.labelling_det import inspect
 from usls.src.labelling_det_2 import inspect2
 from usls.src.labelling_cls import classify
 from usls.src.video_tools import play_and_record, video_to_images, videos_to_images, images_to_video
 from usls.src.spider import spider_img_baidu
 from usls.src.dir_combine import dir_combine
 from usls.src.label_combine import combine_labels
 from usls.src.deduplicate import deduplicate
 from usls.src.class_modify import class_modify
 # ---------------------------------------------------------------------------------------------
 
 
-def run(opt: DictConfig):
 
-    # ------------------------
-    #   common vars
-    # ------------------------
+
+
+
+def run(opt: DictConfig):
 
 
     # -------------------------------------
     #   img & label dir info 
     # -------------------------------------
     if opt.task == 'info':
 
-        img_dir = opt.get('img_dir')
-        label_dir = opt.label_dir if opt.get('label_dir') else img_dir
-
-        assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
-        assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
-
-
-        rich.print(f"\n-------INFO----------")
-        image_list = [x for x in Path(img_dir).iterdir() if x.suffix in IMG_FORMAT]
-        label_list = list(Path(label_dir).glob("*.txt"))
-        rich.print(f"> Images count: {len(image_list)}")
-        rich.print(f"> Labels count: {len(label_list)}")    
-        rich.print(f'---------------------')
+        with CONSOLE.status("[bold green]Working on info checking...") as status:
+            _, _, _, = load_from_dir(
+                img_dir=opt.get('img_dir'), 
+                label_dir=opt.get('label_dir'), 
+                video_dir=opt.get('video_dir'), 
+                # verbose=True,
+                # title='INFO',
+                caption='INFO\n',
+            )
 
 
     # -------------------------------------
     #   inspect 
     # -------------------------------------
     if opt.task in ('inspect', 'classify'):
 
@@ -65,23 +61,21 @@
 
         assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
         assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
 
         mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
         wrong_img_dir = opt.wrong_img_dir if opt.get('wrong_img_dir') else 'wrong_img_dir'  # wrong dir
 
-
         assert opt.get('classes'), f"No `classes=???` args when task is `inspect`!"
         classes = opt.classes.split(',')
         window_width = opt.window_width if opt.get('window_width') else 800  # save moved dir
         window_height = opt.window_height if opt.get('window_height') else 600  # save moved dir
 
         # det
         if opt.task == 'inspect':
-
             inspect( 
                 img_dir, 
                 label_dir,
                 mv_dir,
                 wrong_img_dir,
                 classes,
                 window_width,
@@ -102,48 +96,52 @@
 
 
     # -------------------------------------
     #   inspect 2
     # -------------------------------------
     if opt.task in ('inspect2'):
 
-        img_dir = opt.get('img_dir')
-        label_dir = opt.label_dir if opt.get('label_dir') else img_dir
+        with CONSOLE.status("[bold cyan]Doing inspect...") as status:
 
-        assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
-        assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
 
-        mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
-        wrong_img_dir = opt.wrong_img_dir if opt.get('wrong_img_dir') else 'wrong_img_dir'  # wrong dir
+            img_dir = opt.get('img_dir')
+            label_dir = opt.label_dir if opt.get('label_dir') else img_dir
 
+            assert all((img_dir, label_dir)), f"Not `img_dir=???` or `label_dir=???` input!"
+            assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
 
-        assert opt.get('classes'), f"No `classes=???` args when task is `inspect`!"
-        classes = opt.classes.split(',')
-        window_width = opt.window_width if opt.get('window_width') else 800  # save moved dir
-        window_height = opt.window_height if opt.get('window_height') else 600  # save moved dir
+            mv_dir = opt.mv_dir if opt.get('mv_dir') else 'moved_dir'  # save moved dir
+            wrong_img_dir = opt.wrong_img_dir if opt.get('wrong_img_dir') else 'wrong_img_dir'  # wrong dir
 
-        # det
-        if opt.task == 'inspect2':
 
-            inspect2( 
-                img_dir, 
-                label_dir,
-                mv_dir,
-                wrong_img_dir,
-                classes,
-                window_width,
-                window_height,
-            )
+            assert opt.get('classes'), f"No `classes=???` args when task is `inspect`!"
+            classes = opt.classes.split(',')
+            window_width = opt.window_width if opt.get('window_width') else 800  # save moved dir
+            window_height = opt.window_height if opt.get('window_height') else 600  # save moved dir
+
+            # det
+            if opt.task == 'inspect2':
+
+                inspect2( 
+                    img_dir, 
+                    label_dir,
+                    mv_dir,
+                    wrong_img_dir,
+                    classes,
+                    window_width,
+                    window_height,
+                )
 
 
 
     # -------------------------------------
     #   img & label dir clean up 
     # -------------------------------------
     if opt.task in ('clean', 'cleanup'):
+
         img_dir = opt.get('img_dir')
         label_dir = opt.label_dir if opt.get('label_dir') else img_dir
 
         assert img_dir, f"No `img_dir=???` input!"
         assert label_dir, f"No `label_dir=???` input!"
         assert Path(img_dir).is_dir() and Path(label_dir).is_dir(), f"`img_dir={img_dir}` or `label_dir={label_dir}` is not a dir path"
 
@@ -153,29 +151,55 @@
             if opt.clean_empty.lower() == 'false':
                 clean_empty = True
             else:
                 clean_empty = False
         else:
             clean_empty = False
 
-        rich.print(f"-------CLEAN_UP-------")
-        rich.print("> IMG Directory:", Path(img_dir).resolve())
-        rich.print("> LABEL Directory:", Path(label_dir).resolve())
+
+            # display
+            table = rich.table.Table(
+                # title='usls cleanup', 
+                # title_style='bold cyan',
+                box=rich.box.ASCII2, 
+                show_lines=False, 
+                caption=f"Cleanup\n",
+                caption_justify='center',
+                header_style='bold',
+                caption_style='bold cyan',
+            )
+            table.add_column(
+                "Directory", 
+                justify="left", 
+                style="b", 
+                no_wrap=False
+            )
+            table.add_column(
+                "Absolute Path", 
+                justify="left", 
+                style="b green", 
+                no_wrap=False
+            )
+            table.add_row(f"IMAGE", f"{Path(img_dir).resolve()}", end_section=False)
+            table.add_row(f"LABEL", f"{Path(label_dir).resolve()}", end_section=False)
+            CONSOLE.print(table)
+
 
         # in case of other keys input
         while True: 
-            user_answer = input('> do clean-up? ---> [yes/no]: ')
-            if user_answer.lower() in ('n', 'no'):
+            user_answer = CONSOLE.input("Are you sure to do [b cyan]clean-up[/b cyan] :smiley: ? > ")
+            if user_answer.lower() in ('n', 'no', 'false', 'f'):
                 sys.exit("Cancelled cleanup!")
 
-            elif user_answer.lower() in ('y', 'yes'):
+            elif user_answer.lower() in ('y', 'yes', 'true', 't'):
+                # with CONSOLE.status("[bold cyan]Doing cleanup...") as status:
                 img_label_dir_cleanup(
-                    img_dir, 
-                    label_dir, 
-                    mv_dir, 
+                    img_dir,
+                    label_dir,
+                    mv_dir,
                     IMG_FORMAT, 
                     info=True, 
                     dont_clean_empty_txt=clean_empty  # false default
                 )
 
                 break
 
@@ -185,14 +209,15 @@
     #   label combine
     # -------------------------------------
     if opt.task == 'label_combine':
 
         assert opt.get('input_dir'), f"No `input_dir=???` args when task is `label_combine`! default: `output_dir=output-label-combine`"
         input_dir = opt.input_dir
         output_dir = opt.output_dir if opt.get('output_dir') else 'output-label-combine'
+
         combine_labels(input_dir=input_dir, output_dir=output_dir)
 
 
     # -------------------------------------
     #   dir combine
     # -------------------------------------
     if opt.task == 'dir_combine':
@@ -209,20 +234,23 @@
             if opt.move.lower() == 'true':
                 move = True
             else:
                 move = False
         else:
             move = False
 
-        dir_combine(
-            input=input_dir,
-            output=output_dir,
-            suffix=suffix,
-            move=move
-        )
+
+        with CONSOLE.status("[bold cyan]Combining directories...") as status:
+
+            dir_combine(
+                input=input_dir,
+                output=output_dir,
+                suffix=suffix,
+                move=move
+            )
 
 
     # -------------------------------------
     #  video_tools => video to images 
     # -------------------------------------
     if opt.task in ('v2is', 'vs2is'):
 
@@ -250,27 +278,29 @@
         fmt_img = opt.fmt_img if opt.get('fmt_img') else '.jpg' 
 
         if opt.task == 'v2is':
             assert opt.get('source'), f"No `source=???` args when task is `v2is`!"
             source = opt.source
             output_dir = opt.output_dir if opt.get('output_dir') else 'v2is'
 
-            video_to_images(
-                source=source,      
-                output=output_dir,      
-                x=frame,
-                view=view,
-                flip=flip,
-                img_fmt=fmt_img
-            )
+            with CONSOLE.status("[bold cyan]video->images, spliting...\n") as status:
+                video_to_images(
+                    source=source,      
+                    output=output_dir,      
+                    x=frame,
+                    view=view,
+                    flip=flip,
+                    img_fmt=fmt_img
+                )
         elif opt.task == 'vs2is':
             assert opt.get('input_dir'), f"No `input_dir=???` args when task is `vs2is`!"
             input_dir = opt.input_dir
             output_dir = opt.output_dir if opt.get('output_dir') else 'vs2is'
 
+
             videos_to_images(
                 input_dir=input_dir,
                 output_dir=output_dir,
                 x=frame,
                 view=view,
                 flip=flip,
                 img_fmt=fmt_img
@@ -291,14 +321,15 @@
             if opt.flip.lower() == 'true':
                 flip = True
             else:
                 flip = False
         else:
             flip = False
 
+        # with CONSOLE.status("[bold cyan]Playing...\n") as status:
         play_and_record(
             source=source, 
             delay=delay, 
             flip=flip
         )
```

## usls/src/labelling_det.py

```diff
@@ -21,41 +21,41 @@
 #--------------------------------------------
 FILE = Path(__file__).resolve()
 ROOT = FILE.parents[0]   # FILE.parent 
 if str(ROOT) not in sys.path:
     sys.path.append(str(ROOT))  # add ROOT to PATH
 #--------------------------------------------
 
-from utils import Colors, IMG_FORMAT, is_point_in_rect, LOGGER
+from utils import Colors, IMG_FORMAT, is_point_in_rect, LOGGER, CONSOLE
 
 
 #--------------------------------------------
 #          Global Variables
 #--------------------------------------------
 
 HELP_MSG = '''
 
-Usage:
-    ESC:                    quit 
-    r/R:                    switch mode between `mark` and `read`
-    a(A)/d(D):              switch image
-    w(W)/s(S):              switch class
-    -/+:                    adjust line-thickness
-    t/T:                    switch line-thickness between thickness=1 and thickness=current
-    n/N:                    hide all bboxes' labels
-    b/B:                    blink the bboxes & labels
-    l/L:                    shuffle bbox colors
-    i/I:                    display info
-    0-8:                    show single class bboxes
-    9:                      show all classes bboxes
-    delete:                 way 1. press `c/C` to remove all bboxes and txt label.
-                            way 2. press `backspace` to remove bbox one by one (start from the last one). txt label not included.
-                            way 3. press  r/R to enter `mark` mode, then click right button on bbox you're about to delete. txt label not included
-    select bbox:            press r/R, then double click one bboxes to select it.
-    change bbox's class:    select bbox first, then press `w/s` to change its'class. 
+[bold]Usage:
+    [green]ESC:                    [cyan]quit 
+    [green]r/R:                    [cyan]switch mode between `mark` and `read`
+    [green]a(A)/d(D):              [cyan]switch image
+    [green]w(W)/s(S):              [cyan]switch class
+    [green]-/+:                    [cyan]adjust line-thickness
+    [green]t/T:                    [cyan]switch line-thickness between thickness=1 and thickness=current
+    [green]n/N:                    [cyan]hide all bboxes' labels
+    [green]b/B:                    [cyan]blink the bboxes & labels
+    [green]l/L:                    [cyan]shuffle bbox colors
+    [green]i/I:                    [cyan]display info
+    [green]0-8:                    [cyan]show single class bboxes
+    [green]9:                      [cyan]show all classes bboxes
+    [green]delete:                 
+                            [cyan]way 1. press `c/C` to remove all bboxes and txt label.
+                            [cyan]way 2. press  r/R to enter `mark` mode, then click right button on bbox you're about to delete. txt label not included
+    [green]select bbox:            [cyan]press r/R, then double click one bboxes to select it.
+    [green]change bbox's class:    [cyan]select bbox first, then press `w/s` to change its'class. 
 '''
 
 
 # windows 
 WINDOW_NAME = 'Detection-Labelling'
 
 # tracker bars
@@ -615,15 +615,15 @@
         exit(-1)
 
     # opencv windows init
     opencv_window_init()
 
     # read all input images
     LOGGER.info(f"Loading all images...")
-    IMAGE_PATH_LIST = sorted([str(x) for x in Path(INPUT_IMG_DIR).iterdir() if x.suffix in IMG_FORMAT], key=cmp)
+    IMAGE_PATH_LIST = sorted([str(x) for x in Path(INPUT_IMG_DIR).iterdir() if x.suffix.lower() in IMG_FORMAT], key=cmp)
 
     # image class json file init
     IMAGE_CLASSES_JSON_PATH = Path(INPUT_IMG_DIR).with_name('classify.json')
 
     # load json for classify task
     if (IMAGE_CLASSES_JSON_PATH).exists():
         IMAGE_CLASSES = json.load(open(IMAGE_CLASSES_JSON_PATH, encoding="utf-8"))
@@ -639,447 +639,428 @@
     # create window 
     cv2.namedWindow(WINDOW_NAME, cv2.WINDOW_NORMAL)  # cv2.WINDOW_FREERATIO   cv2.WINDOW_KEEPRATIO, WINDOW_GUI_NORMAL, WINDOW_GUI_EXPANDED
     cv2.resizeWindow(WINDOW_NAME, WINDOW_INIT_WIDTH, WINDOW_INIT_HEIGHT)
 
     # mouse listen callback
     cv2.setMouseCallback(WINDOW_NAME, mouse_listener)
 
-
     # images trackbar
     if IMG_COUNT != 0:
         cv2.createTrackbar(TRACKBAR_IMG, WINDOW_NAME, 0, IMG_COUNT, set_img_index)   
  
     # class trackbar
     TRACKBAR_CLASS = TRACKBAR_CLASS + '\n' + str(classes) + '\n'
     if CLS_COUNT != 0:
         cv2.createTrackbar(TRACKBAR_CLASS, WINDOW_NAME, 0, CLS_COUNT, set_class_index)
         # cv2.createTrackbar(TRACKBAR_CLASS + '\n' + str(classes) + '\n', WINDOW_NAME, 0, CLS_COUNT, set_class_index)
         # cv2.createTrackbar(TRACKBAR_CLASS + '\n' + str(classes) + '\n', WINDOW_NAME, 0, CLS_COUNT, lambda x: None)
 
     # initialize the img index
     set_img_index(0)
 
-
     # help info
-    rich.print(HELP_MSG)
+    rich.print(f"{HELP_MSG}")
 
 
     # colors palette
     COLOR_PALETTE = Colors(shuffle=False)  
-    LOGGER.info(f"running...")
+    # LOGGER.info(f"running...")
 
-    # loop
-    while True:
-        color = COLOR_PALETTE(int(CLS_IDX_CURRENT), bgr=False)  # color for every class
-        tmp_img = IMG_CURRENT.copy()    # clone the img   
-        img_height_current, img_width_current = tmp_img.shape[:2]   # height, width
-
-        # calculate line-thickness
-        if MIN_LINE_WIDTH:
-            LINE_THICKNESS = 1
-        else:
-            LINE_THICKNESS = max(round(sum(tmp_img.shape) / 2 * 0.003), 1) if not LINE_THICKNESS_ADJUST else LINE_THICKNESS      # line width
+    with CONSOLE.status("[bold cyan]Doing inspect...") as status:
 
-        # current class index and it's class name
-        class_name = CLASS_LIST[CLS_IDX_CURRENT]
-        
-        # current image path, relative path: img/img_1.jpg
-        img_path = IMAGE_PATH_LIST[IMG_IDX_CURRENT]   
-        label_path = Path(INPUT_LABEL_DIR) / (Path(img_path).stem + '.txt')  # get get corresponding label path
-        
-        # statusbar info
-        status_msg = (f"CURSOR: ({MOUSE_X}, {MOUSE_Y})" + "\t" * 8 + 
-                      f"NUM_BBOXES: {str(len(IMG_OBJECTS))}" + "\t" * 8 +
-                      f"IMG RESOLUTION: ({tmp_img.shape[0]}, {tmp_img.shape[1]})" + "\t" * 5 +
-                      f"IMAGE PATH: {Path(img_path).name}"  + "\t" * 10 + 
-                      f"LABEL PATH: {Path(label_path).name}"  + "\t" * 10
-                    )
-        cv2.displayStatusBar(WINDOW_NAME, status_msg)
+        # loop
+        while True:
+            color = COLOR_PALETTE(int(CLS_IDX_CURRENT), bgr=False)  # color for every class
+            tmp_img = IMG_CURRENT.copy()    # clone the img   
+            img_height_current, img_width_current = tmp_img.shape[:2]   # height, width
+
+            # calculate line-thickness
+            if MIN_LINE_WIDTH:
+                LINE_THICKNESS = 1
+            else:
+                LINE_THICKNESS = max(round(sum(tmp_img.shape) / 2 * 0.003), 1) if not LINE_THICKNESS_ADJUST else LINE_THICKNESS      # line width
 
-        
-        # Display Label if has label txt
-        # Blink bboxes
-        if DO_BLINK_BBOXES:
-            if BLINK_OR_NOT == False:
-                tmp_img = draw_bboxes_from_file(tmp_img, label_path, img_width_current, img_height_current, COLOR_PALETTE, 0, SINGLE_CLS, HIDE_LABEL)
-                BLINK_OR_NOT = True
+            # current class index and it's class name
+            class_name = CLASS_LIST[CLS_IDX_CURRENT]
+            
+            # current image path, relative path: img/img_1.jpg
+            img_path = IMAGE_PATH_LIST[IMG_IDX_CURRENT]   
+            label_path = Path(INPUT_LABEL_DIR) / (Path(img_path).stem + '.txt')  # get get corresponding label path
+            
+            # statusbar info
+            status_msg = (f"CURSOR: ({MOUSE_X}, {MOUSE_Y})" + "\t" * 8 + 
+                          f"NUM_BBOXES: {str(len(IMG_OBJECTS))}" + "\t" * 8 +
+                          f"IMG RESOLUTION: ({tmp_img.shape[0]}, {tmp_img.shape[1]})" + "\t" * 5 +
+                          f"IMAGE PATH: {Path(img_path).name}"  + "\t" * 10 + 
+                          f"LABEL PATH: {Path(label_path).name}"  + "\t" * 10
+                        )
+            cv2.displayStatusBar(WINDOW_NAME, status_msg)
+
+            
+            # Display Label if has label txt
+            # Blink bboxes
+            if DO_BLINK_BBOXES:
+                if BLINK_OR_NOT == False:
+                    tmp_img = draw_bboxes_from_file(tmp_img, label_path, img_width_current, img_height_current, COLOR_PALETTE, 0, SINGLE_CLS, HIDE_LABEL)
+                    BLINK_OR_NOT = True
+                else:
+                    tmp_img = draw_bboxes_from_file(tmp_img, label_path, img_width_current, img_height_current, COLOR_PALETTE, LINE_THICKNESS, SINGLE_CLS, HIDE_LABEL)
+                    BLINK_OR_NOT = False
             else:
+                # draw already done bounding boxes
                 tmp_img = draw_bboxes_from_file(tmp_img, label_path, img_width_current, img_height_current, COLOR_PALETTE, LINE_THICKNESS, SINGLE_CLS, HIDE_LABEL)
-                BLINK_OR_NOT = False
-        else:
-            # draw already done bounding boxes
-            tmp_img = draw_bboxes_from_file(tmp_img, label_path, img_width_current, img_height_current, COLOR_PALETTE, LINE_THICKNESS, SINGLE_CLS, HIDE_LABEL)
 
 
-        # inspect mode
-        if MARK_MODE:
-            # --------------------------
-            # show cursor line for drawing
-            # ----------------------------
-            cv2.line(tmp_img, (MOUSE_X, 0), (MOUSE_X, img_height_current), color, LINE_THICKNESS)
-            cv2.line(tmp_img, (0, MOUSE_Y), (img_width_current, MOUSE_Y), color, LINE_THICKNESS)
-
-            # show label or not when drawing
-            if not HIDE_LABEL:
-                text_w, text_h = cv2.getTextSize(class_name, 
-                                                 0,
-                                                 fontScale=LINE_THICKNESS / 3, 
-                                                 thickness=max(LINE_THICKNESS - 1, 1)
-                                                 )[0]  # text width, height
-                # check if outside of img
-                outside = MOUSE_Y - text_h - 3 >= 0  # label fits outside box
-                cv2.putText(tmp_img, 
-                            class_name, 
-                            (MOUSE_X, MOUSE_Y - 2 if outside else MOUSE_Y + text_h + 3), 
-                            cv2.FONT_HERSHEY_SIMPLEX, 
-                            LINE_THICKNESS / 3, 
-                            # LINE_THICKNESS, 
-                            color, 
-                            thickness=int(LINE_THICKNESS * 0.7), 
-                            lineType=cv2.LINE_AA
-                )
-
-            # --------------------------
-            #  check if bbox is selected
-            # --------------------------
-            # left button double click  =>  hightlight selected bbox
-            if IS_BBOX_SELECTED:
-                tmp_img = highlight_selected_bbox(tmp_img, LINE_THICKNESS, alpha=1, beta=0.5, gamma=0)
+            # inspect mode
+            if MARK_MODE:
+                # --------------------------
+                # show cursor line for drawing
+                # ----------------------------
+                cv2.line(tmp_img, (MOUSE_X, 0), (MOUSE_X, img_height_current), color, LINE_THICKNESS)
+                cv2.line(tmp_img, (0, MOUSE_Y), (img_width_current, MOUSE_Y), color, LINE_THICKNESS)
+
+                # show label or not when drawing
+                if not HIDE_LABEL:
+                    text_w, text_h = cv2.getTextSize(class_name, 
+                                                     0,
+                                                     fontScale=LINE_THICKNESS / 3, 
+                                                     thickness=max(LINE_THICKNESS - 1, 1)
+                                                     )[0]  # text width, height
+                    # check if outside of img
+                    outside = MOUSE_Y - text_h - 3 >= 0  # label fits outside box
+                    cv2.putText(tmp_img, 
+                                class_name, 
+                                (MOUSE_X, MOUSE_Y - 2 if outside else MOUSE_Y + text_h + 3), 
+                                cv2.FONT_HERSHEY_SIMPLEX, 
+                                LINE_THICKNESS / 3, 
+                                # LINE_THICKNESS, 
+                                color, 
+                                thickness=int(LINE_THICKNESS * 0.7), 
+                                lineType=cv2.LINE_AA
+                    )
 
-            # --------------------------
-            #   draw with rect
-            # --------------------------
-            # first click: top_left point
-            if POINT_1[0] != -1:    
-                # draw partial bbox 
-                cv2.rectangle(tmp_img, POINT_1, (MOUSE_X, MOUSE_Y), color, LINE_THICKNESS)
-
-                # if second click: bottom_right point
-                if POINT_2[0] != -1:
-
-                    # save bbox right after get point_2  =>  label.txt
-                    line = idxyxy2idcxcywh(CLS_IDX_CURRENT, POINT_1, POINT_2, img_width_current, img_height_current) # (x,y,x,y) => (x,y,w,h)
-                    # f.write(line + '\n') # append line
-
-                    # save label
-                    with open(label_path, 'a') as f:
-
-                        if os.path.getsize(label_path) == 0:
-                            f.write(line)
-                        else:
-                            f_r = open(label_path, "r").read()   # read a
-                            if f_r[-1] == '\n':
-                                # msg = line + '\n'
-                                msg = line
-                            else:
-                                # msg = '\n' + line + '\n'
-                                msg = '\n' + line
-                            f.write(msg)
-                    
-                    # reset the points
-                    POINT_1 = (-1, -1)
-                    POINT_2 = (-1, -1)
+                # --------------------------
+                #  check if bbox is selected
+                # --------------------------
+                # left button double click  =>  hightlight selected bbox
+                if IS_BBOX_SELECTED:
+                    tmp_img = highlight_selected_bbox(tmp_img, LINE_THICKNESS, alpha=1, beta=0.5, gamma=0)
+
+                # --------------------------
+                #   draw with rect
+                # --------------------------
+                # first click: top_left point
+                if POINT_1[0] != -1:    
+                    # draw partial bbox 
+                    cv2.rectangle(tmp_img, POINT_1, (MOUSE_X, MOUSE_Y), color, LINE_THICKNESS)
+
+                    # if second click: bottom_right point
+                    if POINT_2[0] != -1:
+
+                        # save bbox right after get point_2  =>  label.txt
+                        line = idxyxy2idcxcywh(CLS_IDX_CURRENT, POINT_1, POINT_2, img_width_current, img_height_current) # (x,y,x,y) => (x,y,w,h)
+                        # f.write(line + '\n') # append line
 
+                        # save label
+                        with open(label_path, 'a') as f:
 
+                            if os.path.getsize(label_path) == 0:
+                                f.write(line)
+                            else:
+                                f_r = open(label_path, "r").read()   # read a
+                                if f_r[-1] == '\n':
+                                    # msg = line + '\n'
+                                    msg = line
+                                else:
+                                    # msg = '\n' + line + '\n'
+                                    msg = '\n' + line
+                                f.write(msg)
+                        
+                        # reset the points
+                        POINT_1 = (-1, -1)
+                        POINT_2 = (-1, -1)
 
-        # current show
-        cv2.imshow(WINDOW_NAME, tmp_img)
-        
-        # -----------------------------------------
-        # opencv key listening
-        # -----------------------------------------
-        # key listen
-        pressed_key = cv2.waitKey(1)
-
-        # h/H => help 
-        if pressed_key in (ord('h'), ord('H')):
-            # text = (
-            #     '''
-            #     '''
-                # '[ESC] to quit;\n'
-                #     '[r] switch mode between mark and read;\n'
-                #     '[a/d] to switch image;\n'
-                #     '[w/s] to switch class;\n'
-                #     '[double click to select] + w/s can change class;\n'
-                #     '[-/+] to adjust line-thickness;\n'
-                #     '[t/T] to switch line-thickness between thickness=1 and thickness=current;\n'
-                #     '[n] to hide labels;\n'
-                #     '[b] to blink the bboxes & labels;\n'
-                #     '[l] to shuffle bbox colors;\n'
-                #     '[i] to display info: [path & bboxes];\n'
-                #     '[c] to to remove all bboxes and corresponding txt label;\n'
-                #     '[backspace]to remove bbox one by one (start from the last one);\n'
-                #     '[0-8] to show single class bboxes;\n'
-                #     '[9] to show all classes bboxes;\n'
-
-            print_info(HELP_MSG, ms=1000, where="Overlay")
-
-        # ---------------------------------------
-        # a,d -> images [previous, next]
-        # ---------------------------------------
-        elif pressed_key in (ord('a'), ord('A'), ord('d'), ord('D')):
-
-            if not IS_BBOX_SELECTED:
-
-                # last image index
-                IMG_IDX_LAST = IMG_IDX_CURRENT
-
-                # show previous image
-                if pressed_key in (ord('a'), ord('A')):     
-                    # IMG_IDX_CURRENT = decrease_index(IMG_IDX_CURRENT, IMG_COUNT)
-                    IMG_IDX_CURRENT = 0 if IMG_IDX_CURRENT - 1 < 0 else IMG_IDX_CURRENT - 1
-
-                # show next image index
-                elif pressed_key in (ord('d'), ord('D')):
-
-                    # IMG_IDX_CURRENT = increase_index(IMG_IDX_CURRENT, IMG_COUNT)
-                    IMG_IDX_CURRENT = IMG_COUNT if IMG_IDX_CURRENT + 1 > IMG_COUNT else IMG_IDX_CURRENT + 1
 
-                # set current img index
-                set_img_index(IMG_IDX_CURRENT)
 
-                # update img trackbar 
-                cv2.setTrackbarPos(TRACKBAR_IMG, WINDOW_NAME, IMG_IDX_CURRENT)
+            # current show
+            cv2.imshow(WINDOW_NAME, tmp_img)
+            
+            # -----------------------------------------
+            # opencv key listening
+            # -----------------------------------------
+            # key listen
+            pressed_key = cv2.waitKey(1)
 
-                # set the adjust flag False
-                LINE_THICKNESS_ADJUST = False
+            # h/H => help 
+            if pressed_key in (ord('h'), ord('H')):
+                print_info(HELP_MSG, ms=1000, where="Overlay")
 
-        
+            # ---------------------------------------
+            # a,d -> images [previous, next]
+            # ---------------------------------------
+            elif pressed_key in (ord('a'), ord('A'), ord('d'), ord('D')):
 
-        # ---------------------------------------
-        # w,s -> class  [previous, next]
-        # ---------------------------------------
-        elif pressed_key in (ord('s'), ord('S'), ord('w'), ord('W')):
+                if not IS_BBOX_SELECTED:
 
-            # next class
-            if pressed_key in (ord('s'), ord('S')):
-                CLS_IDX_CURRENT = decrease_index(CLS_IDX_CURRENT, CLS_COUNT)
-                # CLS_IDX_CURRENT = CLS_COUNT if CLS_IDX_CURRENT - 1 < 0 else CLS_IDX_CURRENT - 1     # loop
+                    # last image index
+                    IMG_IDX_LAST = IMG_IDX_CURRENT
 
-            # last class
-            elif pressed_key in (ord('w'), ord('W')):
-                CLS_IDX_CURRENT = increase_index(CLS_IDX_CURRENT, CLS_COUNT)
-                # CLS_IDX_CURRENT = 0 if CLS_IDX_CURRENT + 1 > CLS_COUNT else CLS_IDX_CURRENT + 1
+                    # show previous image
+                    if pressed_key in (ord('a'), ord('A')):     
+                        # IMG_IDX_CURRENT = decrease_index(IMG_IDX_CURRENT, IMG_COUNT)
+                        IMG_IDX_CURRENT = 0 if IMG_IDX_CURRENT - 1 < 0 else IMG_IDX_CURRENT - 1
 
-            # set current class index
-            set_class_index(CLS_IDX_CURRENT)
+                    # show next image index
+                    elif pressed_key in (ord('d'), ord('D')):
 
+                        # IMG_IDX_CURRENT = increase_index(IMG_IDX_CURRENT, IMG_COUNT)
+                        IMG_IDX_CURRENT = IMG_COUNT if IMG_IDX_CURRENT + 1 > IMG_COUNT else IMG_IDX_CURRENT + 1
 
-            # update class trackbar                
-            cv2.setTrackbarPos(TRACKBAR_CLASS, WINDOW_NAME, CLS_IDX_CURRENT)
+                    # set current img index
+                    set_img_index(IMG_IDX_CURRENT)
 
-            # when select, use W/S to edit bbox's class
-            if IS_BBOX_SELECTED:
-                bbox_with_id = IMG_OBJECTS[SELECTED_BBOX]
-                edit_bbox(bbox_with_id, 'change_class:{}'.format(CLS_IDX_CURRENT))
+                    # update img trackbar 
+                    cv2.setTrackbarPos(TRACKBAR_IMG, WINDOW_NAME, IMG_IDX_CURRENT)
 
-        # ---------------------------------------
-        # n/N => hide label
-        # ---------------------------------------
-        elif pressed_key in (ord('n'), ord('N')):
-            HIDE_LABEL = not HIDE_LABEL
-            print_info('Press n to hide Label or show Label.', ms=1000, where="Overlay")
-
-        # ---------------------------------------
-        # '=+' => bold line thickness
-        # '-_' => thin line thickness
-        # ---------------------------------------
-        elif pressed_key in (ord('='), ord('+')):
+                    # set the adjust flag False
+                    LINE_THICKNESS_ADJUST = False
 
-            # set the adjust flag TRUE
-            LINE_THICKNESS_ADJUST = True
             
-            # get the max line width
-            max_t = max(round(sum(tmp_img.shape) / 2 * 0.003), 2) + 5
 
-            # increate the line width
-            if LINE_THICKNESS <= max_t:
-                LINE_THICKNESS += 1
-                print_info(f'Line Thickness +1, now = {LINE_THICKNESS}', ms=1000, where="Overlay")
-            else:
-                print_info('Line Thickness has reach the max value!', ms=1000, where="Overlay")
+            # ---------------------------------------
+            # w,s -> class  [previous, next]
+            # ---------------------------------------
+            elif pressed_key in (ord('s'), ord('S'), ord('w'), ord('W')):
+
+                # next class
+                if pressed_key in (ord('s'), ord('S')):
+                    CLS_IDX_CURRENT = decrease_index(CLS_IDX_CURRENT, CLS_COUNT)
+                    # CLS_IDX_CURRENT = CLS_COUNT if CLS_IDX_CURRENT - 1 < 0 else CLS_IDX_CURRENT - 1     # loop
+
+                # last class
+                elif pressed_key in (ord('w'), ord('W')):
+                    CLS_IDX_CURRENT = increase_index(CLS_IDX_CURRENT, CLS_COUNT)
+                    # CLS_IDX_CURRENT = 0 if CLS_IDX_CURRENT + 1 > CLS_COUNT else CLS_IDX_CURRENT + 1
+
+                # set current class index
+                set_class_index(CLS_IDX_CURRENT)
+
+
+                # update class trackbar                
+                cv2.setTrackbarPos(TRACKBAR_CLASS, WINDOW_NAME, CLS_IDX_CURRENT)
+
+                # when select, use W/S to edit bbox's class
+                if IS_BBOX_SELECTED:
+                    bbox_with_id = IMG_OBJECTS[SELECTED_BBOX]
+                    edit_bbox(bbox_with_id, 'change_class:{}'.format(CLS_IDX_CURRENT))
+
+            # ---------------------------------------
+            # n/N => hide label
+            # ---------------------------------------
+            elif pressed_key in (ord('n'), ord('N')):
+                HIDE_LABEL = not HIDE_LABEL
+                print_info('Press n to hide Label or show Label.', ms=1000, where="Overlay")
+
+            # ---------------------------------------
+            # '=+' => bold line thickness
+            # '-_' => thin line thickness
+            # ---------------------------------------
+            elif pressed_key in (ord('='), ord('+')):
+
+                # set the adjust flag TRUE
+                LINE_THICKNESS_ADJUST = True
+                
+                # get the max line width
+                max_t = max(round(sum(tmp_img.shape) / 2 * 0.003), 2) + 5
 
-        elif pressed_key in (ord('-'), ord('_')):
-            LINE_THICKNESS_ADJUST = True
-            min_t = 1
-            if LINE_THICKNESS > min_t:
-                LINE_THICKNESS -= 1
-                print_info(f'Line Thickness -1, now = {LINE_THICKNESS}', ms=1000, where="Overlay")
-            else: 
-                print_info('Line Thickness has reach the min value!', ms=1000, where="Overlay")
-
-        # ---------------------------------------
-        # i/I => display the info in this img(size, path, num_bboxes)
-        # ---------------------------------------
-        elif pressed_key in (ord('i'), ord('I')):
-            msg = (f"Current image: {Path(img_path).name}\n,"
-                    f"Current labels: {Path(label_path).resolve()}\n,"
-                  f"Currnet BBoxes: {len(IMG_OBJECTS)}\n"
-                  f"Img size: ({tmp_img.shape[0]}, {tmp_img.shape[1]})")
-            print_info(msg, ms=2000, where="Overlay")
-
-            # display the num_bboxes in the img
-            # HIDE_NUM_BBOXES = not HIDE_NUM_BBOXES
-
-
-        # ---------------------------------------
-        # b/b => blink bboxes in current img
-        # ---------------------------------------
-        elif pressed_key in (ord('b'), ord('B')):
-            DO_BLINK_BBOXES = not DO_BLINK_BBOXES
-
-        # ---------------------------------------
-        # BACKSPACE => remove last bboxes in current image
-        # ---------------------------------------
-        # elif pressed_key == 8:
-        #     if not IS_BBOX_SELECTED:
-        #         print_info(f"Remove all bbox", ms=1000, where="Overlay")
-        #         if IMG_OBJECTS:
-        #             # print(f"num: {len(IMG_OBJECTS)}")
-        #             bbox_with_id = IMG_OBJECTS[-1]
-        #             edit_bbox(bbox_with_id, 'delete')
-
-        # ---------------------------------------
-        # c/C  =>  Remove all bboxes in this img, specifically, delete the annotation file(.txt)
-        # ---------------------------------------
-        elif pressed_key in (ord('c'), ord('C')):
-
-            if not IS_BBOX_SELECTED:
-                print_info(f"Clean bbox one by one! rest num = {len(IMG_OBJECTS)}", ms=1000, where="Overlay")
-                if Path(label_path).exists():
-                    Path(label_path).unlink()
+                # increate the line width
+                if LINE_THICKNESS <= max_t:
+                    LINE_THICKNESS += 1
+                    print_info(f'Line Thickness +1, now = {LINE_THICKNESS}', ms=1000, where="Overlay")
                 else:
-                    print_info(f"No bboxes in this img!", ms=1000, where="Overlay")
+                    print_info('Line Thickness has reach the max value!', ms=1000, where="Overlay")
 
+            elif pressed_key in (ord('-'), ord('_')):
+                LINE_THICKNESS_ADJUST = True
+                min_t = 1
+                if LINE_THICKNESS > min_t:
+                    LINE_THICKNESS -= 1
+                    print_info(f'Line Thickness -1, now = {LINE_THICKNESS}', ms=1000, where="Overlay")
+                else: 
+                    print_info('Line Thickness has reach the min value!', ms=1000, where="Overlay")
+
+            # ---------------------------------------
+            # i/I => display the info in this img(size, path, num_bboxes)
+            # ---------------------------------------
+            elif pressed_key in (ord('i'), ord('I')):
+                msg = (f"Current image: {Path(img_path).name}\n,"
+                        f"Current labels: {Path(label_path).resolve()}\n,"
+                      f"Currnet BBoxes: {len(IMG_OBJECTS)}\n"
+                      f"Img size: ({tmp_img.shape[0]}, {tmp_img.shape[1]})")
+                print_info(msg, ms=2000, where="Overlay")
+
+                # display the num_bboxes in the img
+                # HIDE_NUM_BBOXES = not HIDE_NUM_BBOXES
+
+
+            # ---------------------------------------
+            # b/b => blink bboxes in current img
+            # ---------------------------------------
+            elif pressed_key in (ord('b'), ord('B')):
+                DO_BLINK_BBOXES = not DO_BLINK_BBOXES
+
+            # ---------------------------------------
+            # BACKSPACE => remove last bboxes in current image
+            # ---------------------------------------
+            # elif pressed_key == 8:
+            #     if not IS_BBOX_SELECTED:
+            #         print_info(f"Remove all bbox", ms=1000, where="Overlay")
+            #         if IMG_OBJECTS:
+            #             # print(f"num: {len(IMG_OBJECTS)}")
+            #             bbox_with_id = IMG_OBJECTS[-1]
+            #             edit_bbox(bbox_with_id, 'delete')
+
+            # ---------------------------------------
+            # c/C  =>  Remove all bboxes in this img, specifically, delete the annotation file(.txt)
+            # ---------------------------------------
+            elif pressed_key in (ord('c'), ord('C')):
+
+                if not IS_BBOX_SELECTED:
+                    print_info(f"Clean bbox one by one! rest num = {len(IMG_OBJECTS)}", ms=1000, where="Overlay")
+                    if Path(label_path).exists():
+                        Path(label_path).unlink()
+                    else:
+                        print_info(f"No bboxes in this img!", ms=1000, where="Overlay")
 
 
-        # ---------------------------------------
-        # r/R  =>  switch mode
-        # ---------------------------------------
-        elif pressed_key in (ord('r'), ord('R')):
-            print_info(f"Switch mode between READ and MARK", ms=1000, where="Overlay")
-            MARK_MODE = not MARK_MODE
 
-        # ---------------------------------------
-        # l/L  =>  shuffle bbox color
-        # ---------------------------------------
-        elif pressed_key in (ord('l'), ord('L')):
-            COLOR_PALETTE = Colors(shuffle=True)
-            print_info(f"Colors palette shuffled!", ms=1000, where="Overlay")
+            # ---------------------------------------
+            # r/R  =>  switch mode
+            # ---------------------------------------
+            elif pressed_key in (ord('r'), ord('R')):
+                print_info(f"Switch mode between READ and MARK", ms=1000, where="Overlay")
+                MARK_MODE = not MARK_MODE
 
+            # ---------------------------------------
+            # l/L  =>  shuffle bbox color
+            # ---------------------------------------
+            elif pressed_key in (ord('l'), ord('L')):
+                COLOR_PALETTE = Colors(shuffle=True)
+                print_info(f"Colors palette shuffled!", ms=1000, where="Overlay")
 
-        # ---------------------------------------
-        # t/T  =>  min line width
-        # ---------------------------------------
-        elif pressed_key in (ord('t'), ord('T')):
-            MIN_LINE_WIDTH = not MIN_LINE_WIDTH
 
+            # ---------------------------------------
+            # t/T  =>  min line width
+            # ---------------------------------------
+            elif pressed_key in (ord('t'), ord('T')):
+                MIN_LINE_WIDTH = not MIN_LINE_WIDTH
 
-        # ---------------------------------------
-        # e/E  =>  classsify mode
-        # ---------------------------------------
-        # elif pressed_key in (ord('e'), ord('E')):
-        #     CLASSIFY_MODE = not CLASSIFY_MODE
 
+            # ---------------------------------------
+            # e/E  =>  classsify mode
+            # ---------------------------------------
+            # elif pressed_key in (ord('e'), ord('E')):
+            #     CLASSIFY_MODE = not CLASSIFY_MODE
 
 
-        # ---------------------------------------
-        # 0-8 -> select to show single class
-        # 9 -> show all
-        # ---------------------------------------
-        elif pressed_key in range(48, 57):  # 0-8 => 48-56
-            value = int(chr(pressed_key))
 
-            # not in classify mode
-            if not CLASSIFY_MODE:
-                if value <= CLS_COUNT:
-                    SINGLE_CLS = value
-                    print_info(f"Only show class: {SINGLE_CLS} => {CLASS_LIST[SINGLE_CLS]}", ms=1000, where="Overlay")
-                else:
-                    SINGLE_CLS = None
-                    print_info(f"No class: {value}, Max class is {CLS_COUNT} => {CLASS_LIST[CLS_COUNT]}. Show All bboxes", ms=1000, where="Overlay")
+            # ---------------------------------------
+            # 0-8 -> select to show single class
+            # 9 -> show all
+            # ---------------------------------------
+            elif pressed_key in range(48, 57):  # 0-8 => 48-56
+                value = int(chr(pressed_key))
 
-            else:   # classify mode
-                IMAGE_CLASSES.update({img_path: value})
-                print_info(f"image: {img_path} assign class: {value}", ms=1000, where="Overlay")
+                # not in classify mode
+                if not CLASSIFY_MODE:
+                    if value <= CLS_COUNT:
+                        SINGLE_CLS = value
+                        print_info(f"Only show class: {SINGLE_CLS} => {CLASS_LIST[SINGLE_CLS]}", ms=1000, where="Overlay")
+                    else:
+                        SINGLE_CLS = None
+                        print_info(f"No class: {value}, Max class is {CLS_COUNT} => {CLASS_LIST[CLS_COUNT]}. Show All bboxes", ms=1000, where="Overlay")
 
+                else:   # classify mode
+                    IMAGE_CLASSES.update({img_path: value})
+                    print_info(f"image: {img_path} assign class: {value}", ms=1000, where="Overlay")
 
-        elif pressed_key == 57:  # 9
-            # not in classify mode
-            if not CLASSIFY_MODE:
-                SINGLE_CLS = None
 
+            elif pressed_key == 57:  # 9
+                # not in classify mode
+                if not CLASSIFY_MODE:
+                    SINGLE_CLS = None
 
-        # ---------------------------------------
-        # ESC -> quit key listener
-        # ---------------------------------------
-        elif pressed_key == 27:
-            break
-        # ---------------- Key Listeners END ------------------------
 
-        # if window gets closed then quit
-        if cv2.getWindowProperty(WINDOW_NAME, cv2.WND_PROP_VISIBLE) < 1:
-            break
+            # ---------------------------------------
+            # ESC -> quit key listener
+            # ---------------------------------------
+            elif pressed_key == 27:
+                break
+            # ---------------- Key Listeners END ------------------------
 
-    cv2.destroyAllWindows()
+            # if window gets closed then quit
+            if cv2.getWindowProperty(WINDOW_NAME, cv2.WND_PROP_VISIBLE) < 1:
+                break
 
+        cv2.destroyAllWindows()
 
-    # ---------------------------
-    #  deal with classify dict
-    # ---------------------------
-    if IMAGE_CLASSES:
 
-        # check if json file is same with IMAGE_CLASS
-        assert json.load(open(IMAGE_CLASSES_JSON_PATH, encoding="utf-8")) == IMAGE_CLASSES
+        # ---------------------------
+        #  deal with classify dict
+        # ---------------------------
+        if IMAGE_CLASSES:
 
-        # in case of other keys input
-        while True: 
-            response = input('> Find classify.json! Do classifying? [yes / no]: ')
-            if response.lower() in ('n', 'no'):   # exit
-                LOGGER.info('Not doing classifying')
-                break
+            # check if json file is same with IMAGE_CLASS
+            assert json.load(open(IMAGE_CLASSES_JSON_PATH, encoding="utf-8")) == IMAGE_CLASSES
 
-            elif response.lower() in ('y', 'yes'):
-                LOGGER.info('Doing classifying')
+            # in case of other keys input
+            while True: 
+                response = input('> Find classify.json! Do classifying? [yes / no]: ')
+                if response.lower() in ('n', 'no'):   # exit
+                    LOGGER.info('Not doing classifying')
+                    break
 
+                elif response.lower() in ('y', 'yes'):
+                    LOGGER.info('Doing classifying')
 
-                # iterate IMAGE_CLASSES to move image to dirs
-                for idx, (k, v) in enumerate(tqdm(IMAGE_CLASSES.items(), desc='Classifying')):
-                    # print(f'{idx} --> {k} --> {v}')
-
-                    # mkdir dirs for different class: CLASS/class_a, CLASS/class_b, CLASS/class_c 
-                    dst_class_dir = Path('IMAGE-CLASS') / classes[v-1]
-                    if not dst_class_dir.exists():
-                        dst_class_dir.mkdir(parents=True, exist_ok=True)
-                    shutil.copy(k, str(dst_class_dir))
 
+                    # iterate IMAGE_CLASSES to move image to dirs
+                    for idx, (k, v) in enumerate(tqdm(IMAGE_CLASSES.items(), desc='Classifying')):
+                        # print(f'{idx} --> {k} --> {v}')
 
+                        # mkdir dirs for different class: CLASS/class_a, CLASS/class_b, CLASS/class_c 
+                        dst_class_dir = Path('IMAGE-CLASS') / classes[v-1]
+                        if not dst_class_dir.exists():
+                            dst_class_dir.mkdir(parents=True, exist_ok=True)
+                        shutil.copy(k, str(dst_class_dir))
 
-                break
 
 
+                    break
 
-    # ---------------------------
-    # deal with wrong img
-    # last step: opencv
-    # ---------------------------
-    if len(WRONG_IMG_SET) > 0:
-        LOGGER.warning(f"has {len(WRONG_IMG_SET)} images can not be read by OpenCV, moving to {WRONG_IMG_DIR}")
-        
-        # create dir if not exist
-        if not Path(WRONG_IMG_DIR).exists():
-            Path(WRONG_IMG_DIR).mkdir()
-
-        # remove
-        for img in WRONG_IMG_SET:
-            shutil.move(img, WRONG_IMG_DIR)
-            LOGGER.info(f"{Path(img).resolve()}")
 
-    else:
-        LOGGER.info(f"Every image can be read by OpenCV.")
+
+        # ---------------------------
+        # deal with wrong img
+        # last step: opencv
+        # ---------------------------
+        if len(WRONG_IMG_SET) > 0:
+            LOGGER.warning(f"has {len(WRONG_IMG_SET)} images can not be read by OpenCV, moving to {WRONG_IMG_DIR}")
+            
+            # create dir if not exist
+            if not Path(WRONG_IMG_DIR).exists():
+                Path(WRONG_IMG_DIR).mkdir()
+
+            # remove
+            for img in WRONG_IMG_SET:
+                shutil.move(img, WRONG_IMG_DIR)
+                LOGGER.info(f"{Path(img).resolve()}")
+
+        else:
+            LOGGER.info(f"\n> Every image can be read by OpenCV.\n")
```

## usls/src/labelling_det_2.py

```diff
@@ -656,15 +656,15 @@
     set_img_index(0)
 
     # help info
     rich.print(HELP_MSG)
 
     # colors palette
     COLOR_PALETTE = Colors(shuffle=False)  
-    LOGGER.info(f"running...")
+    # LOGGER.info(f"running...")
 
     # loop
     while True:
         color = COLOR_PALETTE(int(CLS_IDX_CURRENT), bgr=False)  # color for every class
         tmp_img = IMG_CURRENT.copy()    # clone the img   
         img_height_current, img_width_current = tmp_img.shape[:2]   # height, width
 
@@ -1080,15 +1080,15 @@
 
         # remove
         for img in WRONG_IMG_SET:
             shutil.move(img, WRONG_IMG_DIR)
             LOGGER.info(f"{Path(img).resolve()}")
 
     else:
-        LOGGER.info(f"Every image can be read by OpenCV.")
+        LOGGER.info(f"\nEvery image can be read by OpenCV.\n")
```

## usls/src/utils.py

```diff
@@ -21,17 +21,117 @@
 import contextlib
 import numpy as np
 from dataclasses import dataclass
 from typing import Union
 
 
 IMG_FORMAT = ('.jpg', '.jpeg', '.png', '.bmp')
-VIDEO_FORMAT = ['.mp4', '.flv', '.avi', '.MOV']
+VIDEO_FORMAT = ('.mp4', '.flv', '.avi', '.mov')
 CONSOLE = Console()
 
+
+def CLI_MSG_TABLE():
+    table = rich.table.Table(
+        title='', 
+        title_style='left',
+        box=rich.box.ASCII2, 
+        show_lines=False, 
+        caption='usls\n',
+        caption_justify='center',
+        header_style='bold cyan',
+    )
+
+
+    table.add_column(
+        "Usage", 
+        justify="left", 
+        style="b", 
+        no_wrap=False
+    )
+    table.add_column(
+        "Command", 
+        justify="left", 
+        style="green", 
+        no_wrap=False
+    )
+
+
+    table.add_row(f"-h, -H, --help", f"usls --help", end_section=False)
+    table.add_row(f"-v, -V, --version", f"usls --version", end_section=True)
+    table.add_row(f"Format", f"usls task=... args=... (task can be omitted)", end_section=True)
+    table.add_row(
+        f"Detection Labelling", 
+        f"usls inspect img_dir=..., [label_dir=...] classes=sth,sth,sth", 
+        end_section=False
+    )
+    table.add_row(
+        f"Classification Labelling", 
+        f"usls classify img_dir=... [label_dir=...] classes=sth,sth,sth", 
+        end_section=False
+    )
+    table.add_row(
+        f"info", 
+        f"usls info img_dir=... [label_dir=... video_dir=...]", 
+        end_section=False
+    )
+    table.add_row(
+        f"clean-up", 
+        f"usls info img_dir=... [label_dir=... mv_dir=... clean_empty=True]", 
+        end_section=False
+    )
+    table.add_row(
+        f"combine labels", 
+        f"usls label_combine input_dir=... [output_dir=...]", 
+        end_section=False
+    )
+    table.add_row(
+        f"combine directories", 
+        f"usls dir_combine input_dir=... [output_dir=... suffix=[] move=False]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Video -> Images", 
+        f"usls v2is source=... [output_dir=v2is frame=20 view=False flip=False fmt_img=.jpg]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Videos -> Images", 
+        f"usls vs2is input_dir=... [output_dir=v2is frame=20 view=False flip=False fmt_img=.jpg]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Images -> Video", 
+        f"usls is2v input_dir=... [output_dir=vs2is fps=30 last4=60 video_size=640]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Play videos/streams & Record(r/R)", 
+        f"usls play source=... [delay=1 flip=False]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Spider", 
+        f"usls spider words=sth", 
+        end_section=False
+    )
+    table.add_row(
+        f"De-duplicate", 
+        f"usls deduplicate input_dir=... [mv_dir=...]", 
+        end_section=False
+    )
+    table.add_row(
+        f"Label Class Modify", 
+        f"usls class_modify input_dir=... to=...", 
+        end_section=False
+    )
+
+    # CONSOLE.print(table)
+    return table
+
+
 def setup_logging_plain(
         stream_logger_name=None, 
         stream_level=logging.DEBUG,
     ):
 
     # stream logger 
     stream_logger = logging.getLogger(stream_logger_name)
@@ -146,28 +246,97 @@
         LOGGER.warning(f"Exceptions: {e}")
 
 
 def verify_label(path):
     pass
 
 
-
 # img_list & label_list, relative path
 def load_img_label_list(img_dir, label_dir, img_format, info=True):
     image_list = [x for x in Path(img_dir).iterdir() if x.suffix in img_format]
     label_list = list(Path(label_dir).glob("*.txt"))
     
     if info:
         rich.print(f"[green]> Images count: {len(image_list)}")
         rich.print(f"[green]> Labels count: {len(label_list)}")
         
 
     return image_list, label_list
 
 
+def load_from_dir(
+        img_dir, 
+        label_dir=None, 
+        video_dir=None, 
+        img_format=IMG_FORMAT,
+        video_format=VIDEO_FORMAT, 
+        verbose=True,
+        title='',
+        caption='',
+    ):
+
+    # img_dir = opt.get('img_dir')
+    # label_dir = opt.label_dir if opt.get('label_dir') else img_dir
+
+    # erroe checking
+    if not Path(img_dir).is_dir():
+        raise TypeError(f'img_dir should be directory, not {type(img_dir)}')
+
+    if label_dir and not Path(label_dir).is_dir():
+        raise TypeError(f'label_dir should be directory, not {type(label_dir)}')
+
+    if video_dir and not Path(video_dir).is_dir():
+        raise TypeError(f'video_dir should be directory, not {type(video_dir)}')
+
+
+    label_dir = label_dir if label_dir else img_dir 
+    video_dir = video_dir if video_dir else img_dir 
+
+
+    image_list = [x for x in Path(img_dir).iterdir() if x.suffix.lower() in img_format]
+    video_list = [x for x in Path(img_dir).iterdir() if x.suffix.lower() in video_format]
+    label_list = list(Path(label_dir).glob("*.txt"))
+    
+    if verbose:
+
+        # display
+        table = rich.table.Table(
+            title=title, 
+            title_style='left',
+            box=rich.box.ASCII2, 
+            show_lines=False, 
+            caption=caption,
+            caption_justify='center',
+            # header_style='bold cyan',
+        )
+        table.add_column(
+            "Type", 
+            justify="left", 
+            style="b", 
+            no_wrap=False
+        )
+        table.add_column(
+            "Count", 
+            justify="right", 
+            style="b green", 
+            no_wrap=False
+        )
+
+        table.add_row(f"Images{img_format}", f"{len(image_list)}", end_section=True)
+        table.add_row(f"Labels(.txt)", f"{len(label_list)}", end_section=True)
+        table.add_row(f"Videos{video_format}", f"{len(video_list)}", end_section=True)
+        CONSOLE.print(table)
+
+
+
+    return image_list, label_list, video_list
+
+
+
+
 # img_path => label_path(txt)
 def get_corresponding_label_path(img_path, output_dir):
     label_name = Path(img_path).stem + '.txt'
     saveout = Path(output_dir) / label_name 
     return str(saveout)
 
 
@@ -236,44 +405,59 @@
         img_format, 
         info=True, 
         dont_clean_empty_txt=False,
         verbose=False,
     ):
 
     # load img and label
-    image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
+    # image_list, label_list = load_img_label_list(
+    #     input_img_dir, input_label_dir, img_format, info
+    # )
+
+    image_list, label_list, video_list = load_from_dir(
+        img_dir=input_img_dir, 
+        label_dir=input_label_dir, 
+        video_dir=None, 
+        verbose=True,
+        title='\nbefore',
+        caption='',
+    )
+
 
     # create mv-dir if not exist
     if not Path(mv_dir).exists():
         Path(mv_dir).mkdir()
 
 
     # 1. imagelabel
     # has img, no label => remove img
-    rich.print(f"> Checking if all images has corresponding label...")
-    for image_path in tqdm(image_list):
+    for image_path in tqdm(image_list, desc=f"Checking images"):
 
         # has corresponding label, continue
         if Path(input_label_dir) / (image_path.stem + '.txt') in label_list:
             continue
 
         # else remove img
-        # rich.print(f"[bold red]No corresponding label: {image_path}, moved.")
         if verbose:
             LOGGER.warning(f"No corresponding label: {image_path}, moved.")
         shutil.move(str(image_path), mv_dir)  
 
 
     # 2. imagelabelsize(img) <= size(label)
     # labelimage
     # has label, no img  => remove label 
-    rich.print(f"> Checking if all labels has corresponding image...")
     
-    image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
-    for label_path in tqdm(label_list):      
+    # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
+    image_list, label_list, video_list = load_from_dir(
+        img_dir=input_img_dir, 
+        label_dir=input_label_dir, 
+        video_dir=None, 
+        verbose=False
+    )
+    for label_path in tqdm(label_list, desc=f"Checking labels"):      
 
         # remove label file without corresponding img
         if Path(input_img_dir) / (label_path.stem + '.png') in image_list:
             continue
         elif Path(input_img_dir) / (label_path.stem + '.jpg') in image_list:
             continue
         elif Path(input_img_dir) / (label_path.stem + '.jpeg') in image_list:
@@ -285,17 +469,25 @@
             shutil.move(str(label_path), mv_dir)
 
 
 
     # 3. label; size(img) = size(label)
     # empty label => remove img & label 
     if not dont_clean_empty_txt:
-        rich.print(f"> Checking if all labels are not empty...")
-        image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
-        for label_path in tqdm(label_list):   
+        # rich.print(f"> Checking if all labels are not empty...")
+        # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, info)
+        image_list, label_list, video_list = load_from_dir(
+            img_dir=input_img_dir, 
+            label_dir=input_label_dir, 
+            video_dir=None, 
+            verbose=False
+        )
+
+
+        for label_path in tqdm(label_list, desc=f"Checking empty labels"):   
 
             # size < 10 => empty
             if os.path.getsize(str(label_path)) < 10:
 
                 # revome label & img
                 # rich.print(f"[bold red]Empty label file: {label_path}, moved.")
                 if verbose:
@@ -327,35 +519,42 @@
                     # rich.print(f"[bold red]=>corresponding img file: {label_path}, moved.")
                     if verbose:
                         LOGGER.warning(f"-> corresponding img file: {img_path_jpeg}, moved.")
                     shutil.move(str(img_path_jpeg), mv_dir)
                 
 
     # 4. clean up IMG-dir, Label-dir
-    rich.print(f"> Cleaning-up img-dir * label-dir...")
+    # rich.print(f"> Cleaning-up img-dir * label-dir...")
     item_list = list(Path(input_img_dir).iterdir())
-    for p in tqdm(item_list):
+    for p in tqdm(item_list, desc=f"Cleaning-up"):
         if p.suffix in list(img_format) + ['.txt']:
             continue
         if verbose:
             LOGGER.warning(f"Not support format: {p.suffix} --> {p}, moved.")
         shutil.move(str(p.resolve()), mv_dir)
 
     # show after check result info
-    image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, False)
-    rich.print(f"[green]> Valid Labels count: {len(label_list)}")
-    rich.print(f"[green]> Valid Images count: {len(image_list)}")
+    # image_list, label_list = load_img_label_list(input_img_dir, input_label_dir, img_format, False)
+    image_list, label_list, video_list = load_from_dir(
+        img_dir=input_img_dir, 
+        label_dir=input_label_dir, 
+        video_dir=None, 
+        verbose=True,
+        title='\nafter',
+        caption='',
+    )
+
 
     # mv_dir
     mv_dir_list = list(Path(mv_dir).iterdir())
     if len(mv_dir_list) == 0:
         Path(mv_dir).rmdir()
 
     # prompt
-    rich.print(f"[bold gold1]> You should run this command servalal times until it's unchanged!")
+    rich.print(f"[bold green]> [Recommand] You should run this command servalal times until it's unchanged!")
 
 
 #---------
 # Usage:
     '''
     save_dir = increment_path(Path(project) / name, exist_ok=False, sep='-')  # increment run
     save_dir.mkdir(parents=True, exist_ok=True)  # make dir 
```

## usls/src/video_tools.py

```diff
@@ -17,30 +17,28 @@
 ROOT = FILE.parents[0]   # FILE.parent 
 if str(ROOT) not in sys.path:
     sys.path.append(str(ROOT))  # add ROOT to PATH
 # ROOT = Path(os.path.relpath(ROOT, Path.cwd()))  # abs path => relative
 #--------------------------------------------
 
 
-from utils import increment_path
+from utils import increment_path, CONSOLE
 from utils import LOGGER, VIDEO_FORMAT, IMG_FORMAT, letterbox
 
 
 
 
 # video play & record
 def play_and_record(source, delay=1, flip=False):
 
     # check video path
     # if Path(source).is_dir():
     #     LOGGER.error("video path is WRONG!")
     #     exit(-3)
 
-    print('----> ', source)
-
     # video_cap 
     videoCapture = cv2.VideoCapture(source)
 
     fps = int(videoCapture.get(cv2.CAP_PROP_FPS))
     w = int(videoCapture.get(cv2.CAP_PROP_FRAME_WIDTH))
     h = int(videoCapture.get(cv2.CAP_PROP_FRAME_HEIGHT))
     video_size = (w, h)
@@ -49,60 +47,61 @@
     LOGGER.info(f"Video info: width={w}, height={h}, FPS={fps}")
 
 
     # record flag
     do_rec = False
     LOGGER.info(f"Not recording! Press [r] to record, Press again to stop recording.")
 
+    with CONSOLE.status("[bold cyan]Playing...\n") as status:
 
-    while True:
-        ret, frame = videoCapture.read()
-        if ret:
-            cv2.imshow('frame', frame)
-            # flip
-            if flip:
-                frame = cv2.flip(frame, 0)
+        while True:
+            ret, frame = videoCapture.read()
+            if ret:
+                cv2.imshow('frame', frame)
+                # flip
+                if flip:
+                    frame = cv2.flip(frame, 0)
 
-            # rec
-            if do_rec:
-                video_writer.write(frame)
+                # rec
+                if do_rec:
+                    video_writer.write(frame)
 
-            # key detect
-            key = cv2.waitKey(delay)
+                # key detect
+                key = cv2.waitKey(delay)
 
-            # q -> quit
-            if key == ord('q'):
-                break
+                # q -> quit
+                if key == ord('q'):
+                    break
 
-            # r -> record
-            if key == ord('r'):
+                # r -> record
+                if key == ord('r'):
 
-                # ~                     
-                do_rec = not do_rec 
+                    # ~                     
+                    do_rec = not do_rec 
 
-                # rec 
-                if do_rec:
-                    LOGGER.info(f"Rec...")
+                    # rec 
+                    if do_rec:
+                        LOGGER.info(f"Rec...")
 
-                    dir_name = 'video_record'
-                    sub_name = 'rec'
-                    save_dir = increment_path(Path(dir_name) / sub_name, exist_ok=False, sep='')  # increment run
-                    save_dir.mkdir(parents=True, exist_ok=True)
-
-                    video_name = 'rec.mp4'
-                    saveout = save_dir / video_name 
-                    # print(saveout)
-                    video_writer = cv2.VideoWriter(str(saveout), fourcc, fps, video_size)
+                        dir_name = 'video_record'
+                        sub_name = 'rec'
+                        save_dir = increment_path(Path(dir_name) / sub_name, exist_ok=False, sep='')  # increment run
+                        save_dir.mkdir(parents=True, exist_ok=True)
 
-                else:
-                    LOGGER.info(f"Done rec. Saved at: {saveout.resolve()}")
+                        video_name = 'rec.mp4'
+                        saveout = save_dir / video_name 
+                        # print(saveout)
+                        video_writer = cv2.VideoWriter(str(saveout), fourcc, fps, video_size)
 
-        else:
-            # print('can not read frame!')
-            break
+                    else:
+                        LOGGER.info(f"Done rec. Saved at: {saveout.resolve()}")
+
+            else:
+                # print('can not read frame!')
+                break
 
 
     # release cap & video cap
     videoCapture.release()
     cv2.destroyAllWindows()
 
     LOGGER.info(f"Done.")
@@ -132,16 +131,16 @@
     save_dir.mkdir(parents=True, exist_ok=True)  # make dir 
 
 
     # load video
     cap = cv2.VideoCapture(str(source))
 
     # read video
-    if verbose:
-        rich.print(f"> [cyan]Spliting...")   
+    # if verbose:
+    #     rich.print(f"> [cyan]Spliting...")   
     
     while True:
         ret, frame = cap.read()
         if ret == True:
 
             # flip frame
             if flip:
@@ -178,15 +177,15 @@
     # close opencv windows if opened.
     if view:
         cv2.destroyAllWindows()
 
 
     if verbose:
         # successful info
-        LOGGER.info(f"Images saved at: {save_dir.resolve()}")
+        LOGGER.info(f"\nImages saved at: {save_dir.resolve()}")
 
 
 
 # batch videos -> images
 def videos_to_images(
                     input_dir,
                     output_dir='',
@@ -195,38 +194,39 @@
                     flip=False,
                     img_fmt=".jpg",
                     ):
 
     # video list
     video_list = [x for x in Path(input_dir).iterdir() if x.suffix in VIDEO_FORMAT]
     # rich.print(f"[italic magenta]==>Videos to be split:[/italic magenta]\n{video_list}\n\n")
-    rich.print(f"> Video spliting list:")
+    # rich.print(f"> Video spliting list:")
     rich.print([str(x.resolve()) for x in video_list])
 
     # if empty dir, stop
     if len(video_list) == 0:
         LOGGER.warning(f"Empty video directory")
         exit(-3)
 
 
     # split videos one by one
-    for video in tqdm(video_list, f"> Spliting... "):
-
-        save_out = Path(input_dir) / video.stem if not output_dir else Path(output_dir) / video.stem
-        video_to_images(source=video,           
-                        output=save_out,      # save dir
-                        x=x,
-                        view=view,
-                        flip=flip,
-                        img_fmt=img_fmt,
-                        verbose=False
-                      )
+    for video in tqdm(video_list, desc=f"videos -> images"):
+        with CONSOLE.status("[bold cyan]spliting...\n") as status:
+            save_out = Path(input_dir) / video.stem if not output_dir else Path(output_dir) / video.stem
+            video_to_images(
+                source=video,           
+                output=save_out,      # save dir
+                x=x,
+                view=view,
+                flip=flip,
+                img_fmt=img_fmt,
+                verbose=False
+            )
 
     # successful info
-    LOGGER.info(f"Images saved at: {Path(output_dir).resolve()}")
+    LOGGER.info(f"Saved at: {Path(output_dir).resolve()}")
 
 
 
 # images -> video
 # 
 # todo: 
 def images_to_video(source,
```

## Comparing `usls-0.0.9.dist-info/LICENSE` & `usls-0.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `usls-0.0.9.dist-info/METADATA` & `usls-0.1.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: usls
-Version: 0.0.9
+Version: 0.1.0
 Summary: Useless CV toolkits
 Home-page: https://github.com/jamjamjon/usls
 Author: jamjamjon
 License: GPL-3.0
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
 License-File: LICENSE
```

## Comparing `usls-0.0.9.dist-info/RECORD` & `usls-0.1.0.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-usls/__init__.py,sha256=252-EG_U1rML3gGu3nomPx2iiiPYLUMiGXnOpjKtQr0,236
-usls/cli.py,sha256=O-8ewm-ejRJgEJW7wuhb4wZCsPVXP1WEBhCh95gK3RI,4341
-usls/run.py,sha256=SY-RZeDeklgjlRg91Z9ZX-SSjN5VoRAZqhvKf5cPD8A,12030
+usls/__init__.py,sha256=O9yEv94vgq8qbgdXFHGNfl01CA6T8Gv_-aWU14If8Xg,236
+usls/cli.py,sha256=DTEd67B04LRnSaDmHF5Wb1-cGvsy0TmoFtzzTz9jJBw,1879
+usls/run.py,sha256=aPAeXdXS9KfelPpjpeXY_qEHe2tPHAKnSGnd-cjjYVY,13002
 usls/src/__init__.py,sha256=sOvJIS48PlCb5VxgHWJURfVCWHToAUvk3dy0DPAN2FI,345
 usls/src/class_modify.py,sha256=MVwj18Z47GV67EfLv77wEKMfRLT2DgOmckQPFQQkU2I,2171
 usls/src/deduplicate.py,sha256=IjLlnx9w080xfllIxoWYYLHqU-c0VSf-sIixIN7cXao,1598
 usls/src/dir_combine.py,sha256=XNXKt3s8fk3ApVQluPkt4ReRRfwCTWHAkyZJ61mPMvE,2537
 usls/src/label_combine.py,sha256=T99nvA4fcHt94cCV9zZVPJvmgj_Lus-5H3lowCbp9So,3204
 usls/src/labelling_cls.py,sha256=yFW_zeBBFr_HS6fu5mqUpPq9-z0F_txAhUGpg-RchRQ,18138
-usls/src/labelling_det.py,sha256=dqR0WnHjy6NzmsEDqFFFQ9qiiHBVJu6VpatOJPv-vsY,40640
-usls/src/labelling_det_2.py,sha256=LLOg4NzkUM7G8t38Z5J9w3MlC38ZygBwBxpMFEEgCkE,40823
+usls/src/labelling_det.py,sha256=2O72FnhHBVvrE6-6LTZWlDOup1cUV4LBCjfKC3FflNI,41064
+usls/src/labelling_det_2.py,sha256=jfiW3F7NifoV64QylkRi5yYmeWJW6HMUkJchEzCjAJ4,40829
 usls/src/spider.py,sha256=ecqEz3Qer94U9Gms7IWLo9tlPLa9GIbMbPWy_G9h2jM,3299
-usls/src/utils.py,sha256=5OOr2WtFlkTblC3Ah1wgkQRlw5UDIenGSMHgDyv1PHw,18795
-usls/src/video_tools.py,sha256=GJXfKJSCg0GkMAnt_VMhve8GIgEzTRp0qOFGjKBmgkE,9193
-usls-0.0.9.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-usls-0.0.9.dist-info/METADATA,sha256=7_oROnTzajlgALzWuasS0HapbTcb9JSoz3iuLf2FP90,588
-usls-0.0.9.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
-usls-0.0.9.dist-info/entry_points.txt,sha256=NtT7OjVpekraB5xlzXzTbTQ9q8VOKMUrByrtciZMJms,34
-usls-0.0.9.dist-info/top_level.txt,sha256=oS7b-J2DgqOuJIQaKnSyirCC_Rt6yeQCLkbNqh2H_DM,5
-usls-0.0.9.dist-info/RECORD,,
+usls/src/utils.py,sha256=eK9RARNe7KEE2OTah1_qnfUhTHFJOfbNJ0uTRyYqx5I,24160
+usls/src/video_tools.py,sha256=zJKFXhKWH5lpFOvUyQpALYwnSyZMBw9V1kTaKzAzTW4,9416
+usls-0.1.0.dist-info/LICENSE,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+usls-0.1.0.dist-info/METADATA,sha256=dt0WxmZdOFweFbXn5R4dzFxDNKh2lTtv6wf0RzCykJ0,588
+usls-0.1.0.dist-info/WHEEL,sha256=2wepM1nk4DS4eFpYrW1TTqPcoGNfHhhO_i5m4cOimbo,92
+usls-0.1.0.dist-info/entry_points.txt,sha256=NtT7OjVpekraB5xlzXzTbTQ9q8VOKMUrByrtciZMJms,34
+usls-0.1.0.dist-info/top_level.txt,sha256=oS7b-J2DgqOuJIQaKnSyirCC_Rt6yeQCLkbNqh2H_DM,5
+usls-0.1.0.dist-info/RECORD,,
```

