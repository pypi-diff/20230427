# Comparing `tmp/yubikey_manager-5.1.0.tar.gz` & `tmp/yubikey_manager-5.1.1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "yubikey_manager-5.1.0.tar", max compression
+gzip compressed data, was "yubikey_manager-5.1.1.tar", max compression
```

## Comparing `yubikey_manager-5.1.0.tar` & `yubikey_manager-5.1.1.tar`

### file list

```diff
@@ -1,108 +1,108 @@
--rw-r--r--   0        0        0     1322 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/COPYING
--rw-r--r--   0        0        0    15548 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/NEWS
--rw-r--r--   0        0        0     7452 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/README.adoc
--rw-r--r--   0        0        0     1508 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/man/ykman.1
--rw-r--r--   0        0        0     1246 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/pyproject.toml
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/__init__.py
--rw-r--r--   0        0        0      195 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/conftest.py
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/__init__.py
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/cli/__init__.py
--rw-r--r--   0        0        0     1092 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/cli/conftest.py
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/cli/piv/__init__.py
--rw-r--r--   0        0        0      215 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/cli/piv/conftest.py
--rw-r--r--   0        0        0      733 2023-04-17 07:17:04.765138 yubikey_manager-5.1.0/tests/device/cli/piv/test_fips.py
--rw-r--r--   0        0        0    10295 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_generate_cert_and_csr.py
--rw-r--r--   0        0        0    15795 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_key_management.py
--rw-r--r--   0        0        0     5502 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_management_key.py
--rw-r--r--   0        0        0     1303 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_misc.py
--rw-r--r--   0        0        0     1691 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_pin_puk.py
--rw-r--r--   0        0        0     3057 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/test_read_write_object.py
--rw-r--r--   0        0        0      325 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/piv/util.py
--rw-r--r--   0        0        0      311 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_aliases.py
--rw-r--r--   0        0        0     8495 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_config.py
--rw-r--r--   0        0        0      816 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_misc.py
--rw-r--r--   0        0        0    11351 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_oath.py
--rw-r--r--   0        0        0     5304 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_openpgp.py
--rw-r--r--   0        0        0    23421 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/cli/test_otp.py
--rw-r--r--   0        0        0     2379 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/condition.py
--rw-r--r--   0        0        0     2708 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/conftest.py
--rw-r--r--   0        0        0      276 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_ccid.py
--rw-r--r--   0        0        0     2022 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_fips_u2f_commands.py
--rw-r--r--   0        0        0      694 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_interfaces.py
--rw-r--r--   0        0        0     8019 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_oath.py
--rw-r--r--   0        0        0     6723 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_openpgp.py
--rw-r--r--   0        0        0     5163 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_otp.py
--rw-r--r--   0        0        0    21962 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/device/test_piv.py
--rw-r--r--   0        0        0      887 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_1024_key.pem
--rw-r--r--   0        0        0      735 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_cert.der
--rw-r--r--   0        0        0     1050 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_cert.pem
--rw-r--r--   0        0        0     1088 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_cert_metadata.pem
--rw-r--r--   0        0        0     1679 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_key.pem
--rw-r--r--   0        0        0     2469 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_key_cert.pfx
--rw-r--r--   0        0        0     2469 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_key_cert_encrypted.pfx
--rw-r--r--   0        0        0     1751 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/files/rsa_2048_key_encrypted.pem
--rw-r--r--   0        0        0     5490 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_device.py
--rw-r--r--   0        0        0      153 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_management.py
--rw-r--r--   0        0        0     3971 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_oath.py
--rw-r--r--   0        0        0     2420 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_piv.py
--rw-r--r--   0        0        0    21312 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_scancodes.py
--rw-r--r--   0        0        0     6105 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/test_util.py
--rw-r--r--   0        0        0     1302 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/tests/util.py
--rw-r--r--   0        0        0     1394 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/__init__.py
--rw-r--r--   0        0        0     1371 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/__init__.py
--rw-r--r--   0        0        0    12603 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/__main__.py
--rw-r--r--   0        0        0     5554 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/aliases.py
--rw-r--r--   0        0        0     6279 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/apdu.py
--rw-r--r--   0        0        0    17796 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/config.py
--rwxr-xr-x   0        0        0    26006 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/fido.py
--rw-r--r--   0        0        0     6970 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/info.py
--rw-r--r--   0        0        0    22389 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/oath.py
--rw-r--r--   0        0        0    17018 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/openpgp.py
--rw-r--r--   0        0        0    27317 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/otp.py
--rw-r--r--   0        0        0    38384 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/piv.py
--rw-r--r--   0        0        0     3341 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/script.py
--rw-r--r--   0        0        0     9236 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/_cli/util.py
--rw-r--r--   0        0        0     2050 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/base.py
--rw-r--r--   0        0        0    10548 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/device.py
--rw-r--r--   0        0        0     7089 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/diagnostics.py
--rw-r--r--   0        0        0     3558 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/fido.py
--rw-r--r--   0        0        0     3772 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/__init__.py
--rw-r--r--   0        0        0     2136 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/base.py
--rw-r--r--   0        0        0    10151 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/freebsd.py
--rw-r--r--   0        0        0     4307 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/linux.py
--rw-r--r--   0        0        0     9838 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/macos.py
--rw-r--r--   0        0        0    11199 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/hid/windows.py
--rw-r--r--   0        0        0     2763 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/logging.py
--rw-r--r--   0        0        0     2322 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/logging_setup.py
--rw-r--r--   0        0        0     2173 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/oath.py
--rw-r--r--   0        0        0     2518 2023-04-17 07:17:04.769138 yubikey_manager-5.1.0/ykman/openpgp.py
--rw-r--r--   0        0        0     7239 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/otp.py
--rw-r--r--   0        0        0     6186 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/pcsc/__init__.py
--rw-r--r--   0        0        0    22734 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/piv.py
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/py.typed
--rw-r--r--   0        0        0     1907 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/__init__.py
--rw-r--r--   0        0        0     3405 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/bepo.py
--rw-r--r--   0        0        0     3343 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/de.py
--rw-r--r--   0        0        0     3287 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/fr.py
--rw-r--r--   0        0        0     3351 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/it.py
--rw-r--r--   0        0        0     2172 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/modhex.py
--rw-r--r--   0        0        0     3312 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/norman.py
--rw-r--r--   0        0        0     3306 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/uk.py
--rw-r--r--   0        0        0     3305 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scancodes/us.py
--rw-r--r--   0        0        0     7636 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/scripting.py
--rw-r--r--   0        0        0     4031 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/settings.py
--rw-r--r--   0        0        0     6063 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/ykman/util.py
--rw-r--r--   0        0        0     1371 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/__init__.py
--rw-r--r--   0        0        0    10457 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/core/__init__.py
--rw-r--r--   0        0        0     1593 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/core/fido.py
--rw-r--r--   0        0        0     9552 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/core/otp.py
--rw-r--r--   0        0        0     7083 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/core/smartcard.py
--rw-r--r--   0        0        0     1642 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/logging.py
--rw-r--r--   0        0        0    17699 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/management.py
--rw-r--r--   0        0        0    14147 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/oath.py
--rw-r--r--   0        0        0    53812 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/openpgp.py
--rwxr-xr-x   0        0        0    29081 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/piv.py
--rw-r--r--   0        0        0        0 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/py.typed
--rw-r--r--   0        0        0    15689 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/support.py
--rw-r--r--   0        0        0    29215 2023-04-17 07:17:04.773138 yubikey_manager-5.1.0/yubikit/yubiotp.py
--rw-r--r--   0        0        0     1133 1970-01-01 00:00:00.000000 yubikey_manager-5.1.0/PKG-INFO
+-rw-r--r--   0        0        0     1348 2023-03-25 15:34:11.878760 yubikey_manager-5.1.1/COPYING
+-rw-r--r--   0        0        0     1579 2023-04-27 12:08:40.654177 yubikey_manager-5.1.1/man/ykman.1
+-rw-r--r--   0        0        0    16123 2023-04-27 11:58:10.705487 yubikey_manager-5.1.1/NEWS
+-rw-r--r--   0        0        0     1297 2023-04-27 07:22:39.653446 yubikey_manager-5.1.1/pyproject.toml
+-rw-r--r--   0        0        0     7624 2023-04-04 13:17:32.853514 yubikey_manager-5.1.1/README.adoc
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.884969 yubikey_manager-5.1.1/tests/__init__.py
+-rw-r--r--   0        0        0      199 2023-03-25 15:34:11.884969 yubikey_manager-5.1.1/tests/conftest.py
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.885966 yubikey_manager-5.1.1/tests/device/__init__.py
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.885966 yubikey_manager-5.1.1/tests/device/cli/__init__.py
+-rw-r--r--   0        0        0     1126 2023-03-25 15:34:11.885966 yubikey_manager-5.1.1/tests/device/cli/conftest.py
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.885966 yubikey_manager-5.1.1/tests/device/cli/piv/__init__.py
+-rw-r--r--   0        0        0      224 2023-03-25 15:34:11.885966 yubikey_manager-5.1.1/tests/device/cli/piv/conftest.py
+-rw-r--r--   0        0        0      756 2023-03-25 15:34:11.886965 yubikey_manager-5.1.1/tests/device/cli/piv/test_fips.py
+-rw-r--r--   0        0        0    10601 2023-03-25 15:34:11.886965 yubikey_manager-5.1.1/tests/device/cli/piv/test_generate_cert_and_csr.py
+-rw-r--r--   0        0        0    16409 2023-03-25 15:34:11.886965 yubikey_manager-5.1.1/tests/device/cli/piv/test_key_management.py
+-rw-r--r--   0        0        0     5684 2023-03-25 15:34:11.886965 yubikey_manager-5.1.1/tests/device/cli/piv/test_management_key.py
+-rw-r--r--   0        0        0     1351 2023-03-25 15:34:11.886965 yubikey_manager-5.1.1/tests/device/cli/piv/test_misc.py
+-rw-r--r--   0        0        0     1756 2023-03-25 15:34:11.888015 yubikey_manager-5.1.1/tests/device/cli/piv/test_pin_puk.py
+-rw-r--r--   0        0        0     3171 2023-03-25 15:34:11.888015 yubikey_manager-5.1.1/tests/device/cli/piv/test_read_write_object.py
+-rw-r--r--   0        0        0      335 2023-03-25 15:34:11.888015 yubikey_manager-5.1.1/tests/device/cli/piv/util.py
+-rw-r--r--   0        0        0      324 2023-03-25 15:34:11.888015 yubikey_manager-5.1.1/tests/device/cli/test_aliases.py
+-rw-r--r--   0        0        0     8720 2023-03-25 15:34:11.889012 yubikey_manager-5.1.1/tests/device/cli/test_config.py
+-rw-r--r--   0        0        0      840 2023-03-25 15:34:11.889012 yubikey_manager-5.1.1/tests/device/cli/test_misc.py
+-rw-r--r--   0        0        0    11638 2023-03-25 15:34:11.889012 yubikey_manager-5.1.1/tests/device/cli/test_oath.py
+-rw-r--r--   0        0        0     5515 2023-03-25 15:34:11.889012 yubikey_manager-5.1.1/tests/device/cli/test_openpgp.py
+-rw-r--r--   0        0        0    24089 2023-03-25 15:34:11.889012 yubikey_manager-5.1.1/tests/device/cli/test_otp.py
+-rw-r--r--   0        0        0     2463 2023-03-25 15:34:11.890015 yubikey_manager-5.1.1/tests/device/condition.py
+-rw-r--r--   0        0        0     2807 2023-03-25 15:34:11.890015 yubikey_manager-5.1.1/tests/device/conftest.py
+-rw-r--r--   0        0        0      284 2023-03-25 15:34:11.890015 yubikey_manager-5.1.1/tests/device/test_ccid.py
+-rw-r--r--   0        0        0     2080 2023-03-25 15:34:11.890015 yubikey_manager-5.1.1/tests/device/test_fips_u2f_commands.py
+-rw-r--r--   0        0        0      719 2023-03-25 15:34:11.891014 yubikey_manager-5.1.1/tests/device/test_interfaces.py
+-rw-r--r--   0        0        0     8262 2023-03-25 15:34:11.891014 yubikey_manager-5.1.1/tests/device/test_oath.py
+-rw-r--r--   0        0        0     6912 2023-04-04 13:17:39.056465 yubikey_manager-5.1.1/tests/device/test_openpgp.py
+-rw-r--r--   0        0        0     5312 2023-03-25 15:34:11.891014 yubikey_manager-5.1.1/tests/device/test_otp.py
+-rw-r--r--   0        0        0    22572 2023-03-25 15:34:11.891014 yubikey_manager-5.1.1/tests/device/test_piv.py
+-rw-r--r--   0        0        0      902 2023-03-25 15:34:11.892010 yubikey_manager-5.1.1/tests/files/rsa_1024_key.pem
+-rw-r--r--   0        0        0      735 2023-03-25 15:34:11.892010 yubikey_manager-5.1.1/tests/files/rsa_2048_cert.der
+-rw-r--r--   0        0        0     1068 2023-03-25 15:34:11.892010 yubikey_manager-5.1.1/tests/files/rsa_2048_cert.pem
+-rw-r--r--   0        0        0     1108 2023-03-25 15:34:11.892010 yubikey_manager-5.1.1/tests/files/rsa_2048_cert_metadata.pem
+-rw-r--r--   0        0        0     1706 2023-03-25 15:34:11.893012 yubikey_manager-5.1.1/tests/files/rsa_2048_key.pem
+-rw-r--r--   0        0        0     2469 2023-03-25 15:34:11.893012 yubikey_manager-5.1.1/tests/files/rsa_2048_key_cert.pfx
+-rw-r--r--   0        0        0     2469 2023-03-25 15:34:11.893012 yubikey_manager-5.1.1/tests/files/rsa_2048_key_cert_encrypted.pfx
+-rw-r--r--   0        0        0     1781 2023-03-25 15:34:11.893012 yubikey_manager-5.1.1/tests/files/rsa_2048_key_encrypted.pem
+-rw-r--r--   0        0        0     5646 2023-04-04 13:17:32.859255 yubikey_manager-5.1.1/tests/test_device.py
+-rw-r--r--   0        0        0      159 2023-03-25 15:34:11.894009 yubikey_manager-5.1.1/tests/test_management.py
+-rw-r--r--   0        0        0     4079 2023-03-25 15:34:11.894009 yubikey_manager-5.1.1/tests/test_oath.py
+-rw-r--r--   0        0        0     2493 2023-03-25 15:34:11.894009 yubikey_manager-5.1.1/tests/test_piv.py
+-rw-r--r--   0        0        0    21660 2023-03-25 15:34:11.894009 yubikey_manager-5.1.1/tests/test_scancodes.py
+-rw-r--r--   0        0        0     6260 2023-03-25 15:34:11.895027 yubikey_manager-5.1.1/tests/test_util.py
+-rw-r--r--   0        0        0     1343 2023-03-25 15:34:11.895027 yubikey_manager-5.1.1/tests/util.py
+-rw-r--r--   0        0        0     1422 2023-04-27 07:27:23.729581 yubikey_manager-5.1.1/ykman/__init__.py
+-rw-r--r--   0        0        0     1397 2023-03-25 15:34:11.897009 yubikey_manager-5.1.1/ykman/_cli/__init__.py
+-rw-r--r--   0        0        0    12988 2023-03-25 15:34:11.897009 yubikey_manager-5.1.1/ykman/_cli/__main__.py
+-rw-r--r--   0        0        0     5686 2023-03-25 15:34:11.897009 yubikey_manager-5.1.1/ykman/_cli/aliases.py
+-rw-r--r--   0        0        0     6461 2023-03-25 15:34:11.897009 yubikey_manager-5.1.1/ykman/_cli/apdu.py
+-rw-r--r--   0        0        0    18509 2023-04-17 13:14:22.029286 yubikey_manager-5.1.1/ykman/_cli/config.py
+-rw-r--r--   0        0        0    26798 2023-03-25 15:34:11.898011 yubikey_manager-5.1.1/ykman/_cli/fido.py
+-rw-r--r--   0        0        0     7173 2023-03-25 15:34:11.899035 yubikey_manager-5.1.1/ykman/_cli/info.py
+-rw-r--r--   0        0        0    23162 2023-03-25 15:34:11.899209 yubikey_manager-5.1.1/ykman/_cli/oath.py
+-rw-r--r--   0        0        0    17563 2023-04-04 13:17:39.056465 yubikey_manager-5.1.1/ykman/_cli/openpgp.py
+-rw-r--r--   0        0        0    28348 2023-04-19 12:46:55.776782 yubikey_manager-5.1.1/ykman/_cli/otp.py
+-rw-r--r--   0        0        0    39643 2023-04-04 13:17:32.861897 yubikey_manager-5.1.1/ykman/_cli/piv.py
+-rw-r--r--   0        0        0     3446 2023-03-25 15:34:11.900298 yubikey_manager-5.1.1/ykman/_cli/script.py
+-rw-r--r--   0        0        0     9546 2023-04-04 13:17:39.056465 yubikey_manager-5.1.1/ykman/_cli/util.py
+-rw-r--r--   0        0        0     2099 2023-03-25 15:34:11.901321 yubikey_manager-5.1.1/ykman/base.py
+-rw-r--r--   0        0        0    10843 2023-03-25 15:34:11.901321 yubikey_manager-5.1.1/ykman/device.py
+-rw-r--r--   0        0        0     7309 2023-04-04 13:17:39.060261 yubikey_manager-5.1.1/ykman/diagnostics.py
+-rw-r--r--   0        0        0     3657 2023-03-25 15:34:11.902323 yubikey_manager-5.1.1/ykman/fido.py
+-rw-r--r--   0        0        0     3873 2023-03-25 15:34:11.902323 yubikey_manager-5.1.1/ykman/hid/__init__.py
+-rw-r--r--   0        0        0     2187 2023-03-25 15:34:11.902323 yubikey_manager-5.1.1/ykman/hid/base.py
+-rw-r--r--   0        0        0    10452 2023-03-25 15:34:11.903393 yubikey_manager-5.1.1/ykman/hid/freebsd.py
+-rw-r--r--   0        0        0     4439 2023-03-25 15:34:11.903393 yubikey_manager-5.1.1/ykman/hid/linux.py
+-rw-r--r--   0        0        0    10141 2023-03-25 15:34:11.903393 yubikey_manager-5.1.1/ykman/hid/macos.py
+-rw-r--r--   0        0        0    11570 2023-03-25 15:34:11.903393 yubikey_manager-5.1.1/ykman/hid/windows.py
+-rw-r--r--   0        0        0     2839 2023-03-25 15:34:11.904397 yubikey_manager-5.1.1/ykman/logging.py
+-rw-r--r--   0        0        0     2383 2023-03-25 15:34:11.904397 yubikey_manager-5.1.1/ykman/logging_setup.py
+-rw-r--r--   0        0        0     2230 2023-03-25 15:34:11.904397 yubikey_manager-5.1.1/ykman/oath.py
+-rw-r--r--   0        0        0     2574 2023-04-04 13:17:39.060261 yubikey_manager-5.1.1/ykman/openpgp.py
+-rw-r--r--   0        0        0     7444 2023-04-04 13:17:32.863196 yubikey_manager-5.1.1/ykman/otp.py
+-rw-r--r--   0        0        0     6358 2023-03-25 15:34:11.905396 yubikey_manager-5.1.1/ykman/pcsc/__init__.py
+-rw-r--r--   0        0        0    23409 2023-04-04 13:17:39.061267 yubikey_manager-5.1.1/ykman/piv.py
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.905396 yubikey_manager-5.1.1/ykman/py.typed
+-rw-r--r--   0        0        0     1954 2023-03-25 15:34:11.905396 yubikey_manager-5.1.1/ykman/scancodes/__init__.py
+-rw-r--r--   0        0        0     3539 2023-03-25 15:34:11.906397 yubikey_manager-5.1.1/ykman/scancodes/bepo.py
+-rw-r--r--   0        0        0     3476 2023-03-25 15:34:11.906397 yubikey_manager-5.1.1/ykman/scancodes/de.py
+-rw-r--r--   0        0        0     3417 2023-03-25 15:34:11.906397 yubikey_manager-5.1.1/ykman/scancodes/fr.py
+-rw-r--r--   0        0        0     3488 2023-03-25 15:34:11.906397 yubikey_manager-5.1.1/ykman/scancodes/it.py
+-rw-r--r--   0        0        0     2240 2023-03-25 15:34:11.907436 yubikey_manager-5.1.1/ykman/scancodes/modhex.py
+-rw-r--r--   0        0        0     3444 2023-03-25 15:34:11.907436 yubikey_manager-5.1.1/ykman/scancodes/norman.py
+-rw-r--r--   0        0        0     3438 2023-03-25 15:34:11.907436 yubikey_manager-5.1.1/ykman/scancodes/uk.py
+-rw-r--r--   0        0        0     3437 2023-03-25 15:34:11.907436 yubikey_manager-5.1.1/ykman/scancodes/us.py
+-rw-r--r--   0        0        0     7854 2023-03-25 15:34:11.908400 yubikey_manager-5.1.1/ykman/scripting.py
+-rw-r--r--   0        0        0     4145 2023-03-25 15:34:11.908400 yubikey_manager-5.1.1/ykman/settings.py
+-rw-r--r--   0        0        0     6248 2023-03-25 15:34:11.908400 yubikey_manager-5.1.1/ykman/util.py
+-rw-r--r--   0        0        0     1397 2023-03-25 15:34:11.908400 yubikey_manager-5.1.1/yubikit/__init__.py
+-rw-r--r--   0        0        0    10805 2023-03-25 15:34:11.909404 yubikey_manager-5.1.1/yubikit/core/__init__.py
+-rw-r--r--   0        0        0     1628 2023-03-25 15:34:11.909404 yubikey_manager-5.1.1/yubikit/core/fido.py
+-rw-r--r--   0        0        0     9901 2023-04-19 12:44:56.715091 yubikey_manager-5.1.1/yubikit/core/otp.py
+-rw-r--r--   0        0        0     7303 2023-04-04 13:17:39.061267 yubikey_manager-5.1.1/yubikit/core/smartcard.py
+-rw-r--r--   0        0        0     1681 2023-03-25 15:34:11.910393 yubikey_manager-5.1.1/yubikit/logging.py
+-rw-r--r--   0        0        0    18221 2023-03-25 15:34:11.910393 yubikey_manager-5.1.1/yubikit/management.py
+-rw-r--r--   0        0        0    14619 2023-03-25 15:34:11.910393 yubikey_manager-5.1.1/yubikit/oath.py
+-rw-r--r--   0        0        0    55423 2023-04-04 13:17:39.061267 yubikey_manager-5.1.1/yubikit/openpgp.py
+-rw-r--r--   0        0        0    29961 2023-04-17 12:46:48.547809 yubikey_manager-5.1.1/yubikit/piv.py
+-rw-r--r--   0        0        0        0 2023-03-25 15:34:11.911396 yubikey_manager-5.1.1/yubikit/py.typed
+-rw-r--r--   0        0        0    16135 2023-04-04 13:17:32.866910 yubikey_manager-5.1.1/yubikit/support.py
+-rw-r--r--   0        0        0    30084 2023-03-25 15:34:11.912395 yubikey_manager-5.1.1/yubikit/yubiotp.py
+-rw-r--r--   0        0        0     1133 1970-01-01 00:00:00.000000 yubikey_manager-5.1.1/PKG-INFO
```

### Comparing `yubikey_manager-5.1.0/COPYING` & `yubikey_manager-5.1.1/COPYING`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-Copyright (c) 2015 Yubico AB
-All rights reserved.
-
-  Redistribution and use in source and binary forms, with or
-  without modification, are permitted provided that the following
-  conditions are met:
-
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-   2. Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGE.
+Copyright (c) 2015 Yubico AB
+All rights reserved.
+
+  Redistribution and use in source and binary forms, with or
+  without modification, are permitted provided that the following
+  conditions are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `yubikey_manager-5.1.0/NEWS` & `yubikey_manager-5.1.1/NEWS`

 * *Files 11% similar despite different names*

```diff
@@ -1,277 +1,282 @@
-* Version 5.1.0 (released 2023-04-17)
- ** Add OpenPGP functionality to supported API.
- ** Add PIV key info command to CLI.
- ** PIV: Support signing prehashed data via API.
- ** Bugfix: Fix signing PIV certificates/CSRs with key that always requires PIN.
- ** Bugfix: Fix incorrect display name detection for certain keys over NFC.
-
-* Version 5.0.1 (released 2023-01-17)
- ** Bugfix: Fix the interactive confirmation prompt for some CLI commands.
- ** Bugfix: OpenPGP Signature PIN policy values were swapped.
- ** Bugfix: FIDO: Handle discoverable credentials that are missing name or displayName.
- ** Add support for Python 3.11.
- ** Remove extra whitespace characters from CLI into command output.
-
-* Version 5.0.0 (released 2022-10-19)
- ** Various cleanups and improvements to the API.
- ** Improvements to the handling of YubiKeys and connections.
- ** Command aliases for ykman 3.x (introduced in ykman 4.0) have now been dropped.
- ** Installers for ykman are now provided for Windows (amd64) and MacOS (universal2).
- ** Logging has been improved, and a new TRAFFIC level has been introduced.
- ** The codebase has been improved for scripting usage, either directly as a Python
-    module, or via the new "ykman script" command.
-    See doc/Scripting.adoc, doc/Library_Usage.adoc, and examples/ for more details.
- ** PIV: Add support for dotted-string OIDs when parsing RFC4514 strings.
- ** PIV: Drop support for signing certificates and CSRs with SHA-1.
- ** FIDO: Credential management commands have been improved to deal with ambiguity
-    in certain cases.
- ** OATH: Access Keys ("remembered" passwords) are now stored in the system keyring.
- ** OpenPGP: Commands have been added to manage PINs.
- 
-* Version 4.0.9 (released 2022-06-17)
- ** Dependency: Add support for python-fido2 1.x
-  ** Fix: Drop stated support for Click 6 as features from 7 are being used.
-
-* Version 4.0.8 (released 2022-01-31)
- ** Bugfix: Fix error message for invalid modhex when programing a YubiOTP credential.
- ** Bugfix: Fix issue with displaying a Steam credential when it is the only account.
- ** Bugfix: Prevent installation of files in site-packages root.
- ** Bugfix: Fix cleanup logic in PIV for protected management key.
- ** Add support for token identifier when programming slot-based HOTP.
- ** Add support for programming NDEF in text mode.
- ** Dependency: Add support for Cryptography <= 38.
-
-* Version 4.0.7 (released 2021-09-08)
- ** Bugfix release: Fix broken naming for "YubiKey 4", and a small OATH issue with
-    touch Steam credentials.
-
-* Version 4.0.6 (released 2021-09-08)
- ** Improve handling of YubiKey device reboots.
- ** More consistently mask PIN/password input in prompts.
- ** Support switching mode over CCID for YubiKey Edge.
- ** Run pkill from PATH instead of fixed location.
-
-* Version 4.0.5 (released 2021-07-16)
- ** Bugfix: Fix PIV feature detection for some YubiKey NEO versions.
- ** Bugfix: Fix argument short form for --period when adding TOTP credentials.
- ** Bugfix: More strict validation for some arguments, resulting in better error messages.
- ** Bugfix: Correctly handle TOTP credentials using period != 30 AND touch_required.
- ** Bugfix: Fix prompting for access code in the otp settings command (now uses "-A -").
-
-* Version 4.0.3 (released 2021-05-17)
- ** Add support for fido reset over NFC.
- ** Bugfix: The --touch argument to piv change-management-key was ignored.
- ** Bugfix: Don't prompt for password when importing PIV key/cert if file is invalid.
- ** Bugfix: Fix setting touch-eject/auto-eject for YubiKey 4 and NEO.
- ** Bugfix: Detect PKCS#12 format when outer sequence uses indefinite length.
- ** Dependency: Add support for Click 8.
-
-* Version 4.0.2 (released 2021-04-12)
- ** Update device names.
- ** Add read_info output to the --diagnose command, and show exception types.
- ** Bugfix: Fix read_info for YubiKey Plus.
-
-* Version 4.0.1 (released 2021-03-29)
- ** Add support for YK5-based FIPS YubiKeys.
- ** Bugfix: Fix OTP device enumeration on Win32.
-
-* Version 4.0.0 (released 2021-03-02)
- ** Drop support for Python < 3.6.
- ** Drop reliance on libusb and libykpersonalize.
- ** Support the "fido" and "otp" subcommands over NFC (using the --reader flag)
- ** New "ykman --diagnose" command to aid in troubleshooting.
- ** New "ykman apdu" command for sending raw APDUs over the smart card interface.
- ** Restructuring of subcommands, with aliases for old versions (to be removed
-    in a future release).
- ** Major changes to the underlying "library" code:
-  *** New "yubikit" package added for custom development and advanced scripting.
-  *** Type hints added for a large part of the "public" API.
- ** OpenPGP: Add support for KDF enabled YubiKeys.
- ** Static password: Add support for FR, IT, UK and BEPO keyboard layouts.
-
-* Version 3.1.2 (released 2021-01-21)
- ** Bugfix release: Fix dependency on python-fido2 version.
-
-* Version 3.1.1 (released 2020-01-29)
- ** Add support for YubiKey 5C NFC
- ** OpenPGP: set-touch now performs compatibility checks before prompting for PIN
- ** OpenPGP: Improve error messages and documentation for set-touch
- ** PIV: read-object command no longer adds a trailing newline
- ** CLI: Hint at missing permissions when opening a device fails
- ** Linux: Improve error handling when pcscd is not running
- ** Windows: Improve how .DLL files are loaded, thanks to Marius Gabriel Mihai for reporting this!
- ** Bugfix: set-touch now accepts the cached-fixed option
- ** Bugfix: Fix crash in OtpController.prepare_upload_key() error parsing
- ** Bugfix: Fix crash in piv info command when a certificate slot contains an invalid certificate
- ** Library: PivController.read_certificate(slot) now wraps certificate parsing exceptions in new exception type `InvalidCertificate`
- ** Library: PivController.list_certificates() now returns `None` for slots containing invalid certificate, instead of raising an exception
-
-* Version 3.1.0 (released 2019-08-20)
- ** Add support for YubiKey 5Ci
- ** OpenPGP: the info command now prints OpenPGP specification version as well
- ** OpenPGP: Update support for attestation to match OpenPGP v3.4
- ** PIV: Use UTC time for self-signed certificates
- ** OTP: Static password now supports the Norman keyboard layout
-
-* Version 3.0.0 (released 2019-06-24)
- ** Add support for new YubiKey Preview and lightning form factor
- ** FIDO: Support for credential management
- ** OpenPGP: Support for OpenPGP attestation, cardholder certificates and cached touch policies
- ** OTP: Add flag for using numeric keypad when sending digits
-
-* Version 2.1.1 (released 2019-05-28)
- ** OTP: Add initial support for uploading Yubico OTP credentials to YubiCloud
- ** Don't automatically select the U2F applet on YubiKey NEO, it might be blocked by the OS
- ** ChalResp: Always pad challenge correctly
- ** Bugfix: Don't crash with older versions of cryptography
- ** Bugfix: Password was always prompted in OATH command, even if sent as argument
-
-* Version 2.1.0 (released 2019-03-11)
- ** Add --reader flag to ykman list, to list available smart card readers
- ** FIPS: Checking if a YubiKey FIPS is in FIPS mode is now opt-in, with the --check-fips flag
- ** PIV: Add commands for writing and reading arbitrary PIV objects
- ** PIV: Verify that the PIN must be between 6 - 8 characters long
- ** PIV: In import-certificate, make the verification that the certificate and private key matches opt-in, with the --verify flag
- ** PIV: The piv info command now shows the serial number of the certificates
- ** PIV: The piv info command now shows the full Distinguished Name (DN) of the certificate subject and issuer, if possible
- ** PIV: Malformed certificates are now handled better
- ** OpenPGP: The openpgp touch command now shows current touch policies
- ** The ykman usb/nfc config command now accepts openpgp as well as opgp as an argument
- ** Bugfix: Fix support for german (DE) keyboard layout for static passwords
-
-* Version 2.0.0 (released 2019-01-09)
- ** Add support for Security Key NFC
- ** Add experimental support for external smart card reader. See --reader flag
- ** Add a minimal manpage
- ** Add examples in help texts
- ** PIV: update CHUID when importing a certificate
- ** PIV: Optionally validate that private key and certificate match when importing a certificate (on by default in CLI)
- ** PIV: Improve support for importing certificate chains and .PEM files with comments
- ** Breaking API changes:
-  *** Merge CCID status word constants into a single SW enum in ykman.driver_ccid
-  *** Throw custom exception types instead of raw APDUErrors from many methods of PivController
-  *** Write CLI prompts to standard error instead of standard output
-  *** Replace function `ykman.util.parse_certificate` with `parse_certificates` which returns a list
-
-* Version 1.0.1 (released 2018-10-10)
- ** Support for YubiKey 5A
- ** OATH: Ignore extra parameters in URI parsing
- ** Bugfix: Never say that NFC is supported for YubiKeys without NFC
-
-* Version 1.0.0 (released 2018-09-24)
- ** Add support for YubiKey 5 Series
- ** Config: Add flag to generate a random configuration lock
- ** OATH: Give a proper error message when a touch credential times out
- ** NDEF: Allow setting the NDEF prefix from the CLI
- ** FIDO: Block reset when multiple YubiKeys are connected
-
-* Version 0.7.1 (released 2018-07-09)
- ** Support for YubiKey FIPS.
- ** OTP: Allow setting and removing access codes on the slots.
- ** Interfaces: set-lock-code now only accepts hexadecimal inputs.
- ** Bugfix: Don't fail to open the YubiKey when the serial is not visible.
-
-* Version 0.7.0 (released 2018-05-07)
- ** Support for YubiKey Preview.
- ** Add command to configure enabled applications over USB and NFC. See ykman config -h.
- ** Add command for selecting which slot to use for NDEF. See ykman otp ndef -h.
-
-* Version 0.6.1 (released 2018-04-16)
- ** Support for YubiKeys with FIDO2. See ykman fido -h
- ** Report the form factor for YubiKeys that support it.
- ** OTP: slot command is now called otp. See ykman otp -h for all changes.
- ** Static password: Add support for different keyboard layouts. See ykman otp static -h
- ** PIV: Signatures for CSRs are now correct.
- ** PIV: Commands on slots with PIN policy ALWAYS no longer fail if the YubiKey has a management key protected by PIN.
- ** Mode: The U2F mode is now called FIDO.
- ** Dependencies: libu2f-host is no longer used for FIDO communication over USB, instead the python library fido2 is used.
-
-* Version 0.6.0 (released 2018-02-09)
- ** OpenPGP: Expose remaining PIN retries in info command and API.
- ** CCID: Only try YubiKey smart card readers by default.
- ** Handle NEO issues with challenge-response credentials better.
- ** Improve logging.
- ** Improve error handling when opening device over OTP.
- ** Bugfix: Fix adding OTP data through the interactive prompt.
-
-* Version 0.5.0 (released 2017-12-15)
- ** API breaking changes:
-  *** OATH: New API more similar to yubioath-android
- ** CLI breaking changes:
-  *** OATH: Touch prompt now written to stderr instead of stdout
-  *** OATH: `-a|--algorithm` option to `list` command removed
-  *** OATH: Columns in `code` command are now dynamically spaced depending on contents
-  *** OATH: `delete` command now requires confirmation or `-f|--force` argument
-  *** OATH: IDs printed by `list` command now include TOTP period if not 30
-  *** Changed outputs:
-   **** INFO: "Device name" output changed to "Device type"
-   **** PIV: "Management key is stored on device" output changed to "Management key is stored on the YubiKey"
-   **** PIV: "All PIV data have been cleared from the device" output changed to "All PIV data have been cleared from your YubiKey"
-   **** PIV: "The current management key is stored on the device" prompt changed to "The current management key is stored on the YubiKey"
-   **** SLOT: "blank to use device serial" prompt changed to "blank to use YubiKey serial number"
-   **** SLOT: "Using device serial" output changed to "Using YubiKey device serial"
-   **** Lots of failure case outputs changed
- ** New features:
-  *** Support for multiple devices via new top-level option `-d|--device`
-  *** New top-level option `-l|--log-level` to enable logging
-  *** OATH: Support for remembering passwords locally.
-  *** OATH: New option `-s|--single` for `code` command
-  *** PIV: `set-pin-retries` command now warns that PIN and PUK will be reset to factory defaults, and prints those defaults after resetting
- ** API bug fixes:
-  *** OATH: `valid_from` and `valid_to` for `Code` are now absolute instead of relative to the credential period
-  *** OATH: `period` for non-TOTP `Code` is now `None`
-
-* Version 0.4.6 (released 2017-10-17)
- ** Will now attempt to open device 3 times before failing
- ** OpenPGP: Don't say data is removed when not
- ** OpenPGP: Don't swallow APDU errors
- ** PIV: Block on-chip RSA key generation for firmware versions 4.2.0 to 4.3.4 (inclusive) since these chips are vulnerable to http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-15361[CVE-2017-15631].
-
-* Version 0.4.5 (released 2017-09-14)
- ** OATH: Don't print issuer if there is no issuer.
-
-* Version 0.4.4 (released 2017-09-06)
- ** OATH: Fix yet another issue with backwards compatibility, for adding new credentials.
-
-* Version 0.4.3 (released 2017-09-06)
- ** OATH: Fix issue with backwards compatibility, when used as a library.
-
-* Version 0.4.2 (released 2017-09-05)
- ** OATH: Support 7 digit credentials.
- ** OATH: Support credentials with a period other than 30 seconds.
- ** OATH: The remove command is now called delete.
-
-* Version 0.4.1 (released 2017-08-10)
- ** PIV: Dropped support for deriving a management key from PIN.
- ** PIV: Added support for generating a random management key and storing it on the device protected by the PIN.
- ** OpenPGP: The reset command now handles a device in terminated state.
- ** OATH: Credential filtering is now working properly on Python 2.
-
-* Version 0.4.0 (released 2017-06-19)
- ** Added PIV support. The tool and library now supports most of the PIV functionality found on the YubiKey 4 and NEO. To list the available commands, run ykman piv -h.
- ** Mode command now supports adding and removing modes incrementally.
-
-* Version 0.3.3 (released 2017-05-08)
- ** Bugfix: Fix issue with OATH credentials from Steam on YubiKey 4.
-
-* Version 0.3.2 (released 2017-04-24)
- ** Allow access code input through an interactive prompt.
- ** Bugfix: Some versions of YubiKey NEO occasionally failed calculating challenge-response credentials with touch.
-
-* Version 0.3.1 (released 2017-03-13)
- ** Allow programming of TOTP credentials in YubiKey Slots using the chalresp command.
- ** Add a calculate command (and library support) to perform a challenge-response operation. Can also be used to generate TOTP codes for credentials stored in a slot.
- ** OATH: Remove whitespace in secret keys provided by the user.
- ** OATH: Prompt the user to touch the YubiKey for HOTP touch credentials.
- ** Bugfix: The flag for showing hidden credentials was not working correctly for the oath code command.
-
-* Version 0.3.0 (released 2017-01-23)
- ** OATH functionality added. The tool now exposes the OATH functionality found on the YubiKey 4 and NEO. To list the available commands, run ykman oath -h.
- ** Added support for randomly generated static passwords.
-
-* Version 0.2.0 (released 2016-11-23)
- ** Removed all GUI code. This project is now only for the python library and CLI tool. The GUI will be re-released separately in a different project.
- ** Added command to update settings for YubiKey Slots.
-
-* Version 0.1.0 (released 2016-07-07)
- ** Initial release for beta testing.
+* Version 5.1.1 (released 2023-04-27)
+ ** Bugfix: PIV: string representation of SLOT caused infinite loop on Python <3.11.
+ ** Bugfix: Fix errors in 'ykman config nfc' on YubiKeys without NFC capability.
+ ** Bugfix: Fix error message shown when invalid modhex input length given for YubiOTP.
+
+* Version 5.1.0 (released 2023-04-17)
+ ** Add OpenPGP functionality to supported API.
+ ** Add PIV key info command to CLI.
+ ** PIV: Support signing prehashed data via API.
+ ** Bugfix: Fix signing PIV certificates/CSRs with key that always requires PIN.
+ ** Bugfix: Fix incorrect display name detection for certain keys over NFC.
+
+* Version 5.0.1 (released 2023-01-17)
+ ** Bugfix: Fix the interactive confirmation prompt for some CLI commands.
+ ** Bugfix: OpenPGP Signature PIN policy values were swapped.
+ ** Bugfix: FIDO: Handle discoverable credentials that are missing name or displayName.
+ ** Add support for Python 3.11.
+ ** Remove extra whitespace characters from CLI into command output.
+
+* Version 5.0.0 (released 2022-10-19)
+ ** Various cleanups and improvements to the API.
+ ** Improvements to the handling of YubiKeys and connections.
+ ** Command aliases for ykman 3.x (introduced in ykman 4.0) have now been dropped.
+ ** Installers for ykman are now provided for Windows (amd64) and MacOS (universal2).
+ ** Logging has been improved, and a new TRAFFIC level has been introduced.
+ ** The codebase has been improved for scripting usage, either directly as a Python
+    module, or via the new "ykman script" command.
+    See doc/Scripting.adoc, doc/Library_Usage.adoc, and examples/ for more details.
+ ** PIV: Add support for dotted-string OIDs when parsing RFC4514 strings.
+ ** PIV: Drop support for signing certificates and CSRs with SHA-1.
+ ** FIDO: Credential management commands have been improved to deal with ambiguity
+    in certain cases.
+ ** OATH: Access Keys ("remembered" passwords) are now stored in the system keyring.
+ ** OpenPGP: Commands have been added to manage PINs.
+ 
+* Version 4.0.9 (released 2022-06-17)
+ ** Dependency: Add support for python-fido2 1.x
+  ** Fix: Drop stated support for Click 6 as features from 7 are being used.
+
+* Version 4.0.8 (released 2022-01-31)
+ ** Bugfix: Fix error message for invalid modhex when programing a YubiOTP credential.
+ ** Bugfix: Fix issue with displaying a Steam credential when it is the only account.
+ ** Bugfix: Prevent installation of files in site-packages root.
+ ** Bugfix: Fix cleanup logic in PIV for protected management key.
+ ** Add support for token identifier when programming slot-based HOTP.
+ ** Add support for programming NDEF in text mode.
+ ** Dependency: Add support for Cryptography <= 38.
+
+* Version 4.0.7 (released 2021-09-08)
+ ** Bugfix release: Fix broken naming for "YubiKey 4", and a small OATH issue with
+    touch Steam credentials.
+
+* Version 4.0.6 (released 2021-09-08)
+ ** Improve handling of YubiKey device reboots.
+ ** More consistently mask PIN/password input in prompts.
+ ** Support switching mode over CCID for YubiKey Edge.
+ ** Run pkill from PATH instead of fixed location.
+
+* Version 4.0.5 (released 2021-07-16)
+ ** Bugfix: Fix PIV feature detection for some YubiKey NEO versions.
+ ** Bugfix: Fix argument short form for --period when adding TOTP credentials.
+ ** Bugfix: More strict validation for some arguments, resulting in better error messages.
+ ** Bugfix: Correctly handle TOTP credentials using period != 30 AND touch_required.
+ ** Bugfix: Fix prompting for access code in the otp settings command (now uses "-A -").
+
+* Version 4.0.3 (released 2021-05-17)
+ ** Add support for fido reset over NFC.
+ ** Bugfix: The --touch argument to piv change-management-key was ignored.
+ ** Bugfix: Don't prompt for password when importing PIV key/cert if file is invalid.
+ ** Bugfix: Fix setting touch-eject/auto-eject for YubiKey 4 and NEO.
+ ** Bugfix: Detect PKCS#12 format when outer sequence uses indefinite length.
+ ** Dependency: Add support for Click 8.
+
+* Version 4.0.2 (released 2021-04-12)
+ ** Update device names.
+ ** Add read_info output to the --diagnose command, and show exception types.
+ ** Bugfix: Fix read_info for YubiKey Plus.
+
+* Version 4.0.1 (released 2021-03-29)
+ ** Add support for YK5-based FIPS YubiKeys.
+ ** Bugfix: Fix OTP device enumeration on Win32.
+
+* Version 4.0.0 (released 2021-03-02)
+ ** Drop support for Python < 3.6.
+ ** Drop reliance on libusb and libykpersonalize.
+ ** Support the "fido" and "otp" subcommands over NFC (using the --reader flag)
+ ** New "ykman --diagnose" command to aid in troubleshooting.
+ ** New "ykman apdu" command for sending raw APDUs over the smart card interface.
+ ** Restructuring of subcommands, with aliases for old versions (to be removed
+    in a future release).
+ ** Major changes to the underlying "library" code:
+  *** New "yubikit" package added for custom development and advanced scripting.
+  *** Type hints added for a large part of the "public" API.
+ ** OpenPGP: Add support for KDF enabled YubiKeys.
+ ** Static password: Add support for FR, IT, UK and BEPO keyboard layouts.
+
+* Version 3.1.2 (released 2021-01-21)
+ ** Bugfix release: Fix dependency on python-fido2 version.
+
+* Version 3.1.1 (released 2020-01-29)
+ ** Add support for YubiKey 5C NFC
+ ** OpenPGP: set-touch now performs compatibility checks before prompting for PIN
+ ** OpenPGP: Improve error messages and documentation for set-touch
+ ** PIV: read-object command no longer adds a trailing newline
+ ** CLI: Hint at missing permissions when opening a device fails
+ ** Linux: Improve error handling when pcscd is not running
+ ** Windows: Improve how .DLL files are loaded, thanks to Marius Gabriel Mihai for reporting this!
+ ** Bugfix: set-touch now accepts the cached-fixed option
+ ** Bugfix: Fix crash in OtpController.prepare_upload_key() error parsing
+ ** Bugfix: Fix crash in piv info command when a certificate slot contains an invalid certificate
+ ** Library: PivController.read_certificate(slot) now wraps certificate parsing exceptions in new exception type `InvalidCertificate`
+ ** Library: PivController.list_certificates() now returns `None` for slots containing invalid certificate, instead of raising an exception
+
+* Version 3.1.0 (released 2019-08-20)
+ ** Add support for YubiKey 5Ci
+ ** OpenPGP: the info command now prints OpenPGP specification version as well
+ ** OpenPGP: Update support for attestation to match OpenPGP v3.4
+ ** PIV: Use UTC time for self-signed certificates
+ ** OTP: Static password now supports the Norman keyboard layout
+
+* Version 3.0.0 (released 2019-06-24)
+ ** Add support for new YubiKey Preview and lightning form factor
+ ** FIDO: Support for credential management
+ ** OpenPGP: Support for OpenPGP attestation, cardholder certificates and cached touch policies
+ ** OTP: Add flag for using numeric keypad when sending digits
+
+* Version 2.1.1 (released 2019-05-28)
+ ** OTP: Add initial support for uploading Yubico OTP credentials to YubiCloud
+ ** Don't automatically select the U2F applet on YubiKey NEO, it might be blocked by the OS
+ ** ChalResp: Always pad challenge correctly
+ ** Bugfix: Don't crash with older versions of cryptography
+ ** Bugfix: Password was always prompted in OATH command, even if sent as argument
+
+* Version 2.1.0 (released 2019-03-11)
+ ** Add --reader flag to ykman list, to list available smart card readers
+ ** FIPS: Checking if a YubiKey FIPS is in FIPS mode is now opt-in, with the --check-fips flag
+ ** PIV: Add commands for writing and reading arbitrary PIV objects
+ ** PIV: Verify that the PIN must be between 6 - 8 characters long
+ ** PIV: In import-certificate, make the verification that the certificate and private key matches opt-in, with the --verify flag
+ ** PIV: The piv info command now shows the serial number of the certificates
+ ** PIV: The piv info command now shows the full Distinguished Name (DN) of the certificate subject and issuer, if possible
+ ** PIV: Malformed certificates are now handled better
+ ** OpenPGP: The openpgp touch command now shows current touch policies
+ ** The ykman usb/nfc config command now accepts openpgp as well as opgp as an argument
+ ** Bugfix: Fix support for german (DE) keyboard layout for static passwords
+
+* Version 2.0.0 (released 2019-01-09)
+ ** Add support for Security Key NFC
+ ** Add experimental support for external smart card reader. See --reader flag
+ ** Add a minimal manpage
+ ** Add examples in help texts
+ ** PIV: update CHUID when importing a certificate
+ ** PIV: Optionally validate that private key and certificate match when importing a certificate (on by default in CLI)
+ ** PIV: Improve support for importing certificate chains and .PEM files with comments
+ ** Breaking API changes:
+  *** Merge CCID status word constants into a single SW enum in ykman.driver_ccid
+  *** Throw custom exception types instead of raw APDUErrors from many methods of PivController
+  *** Write CLI prompts to standard error instead of standard output
+  *** Replace function `ykman.util.parse_certificate` with `parse_certificates` which returns a list
+
+* Version 1.0.1 (released 2018-10-10)
+ ** Support for YubiKey 5A
+ ** OATH: Ignore extra parameters in URI parsing
+ ** Bugfix: Never say that NFC is supported for YubiKeys without NFC
+
+* Version 1.0.0 (released 2018-09-24)
+ ** Add support for YubiKey 5 Series
+ ** Config: Add flag to generate a random configuration lock
+ ** OATH: Give a proper error message when a touch credential times out
+ ** NDEF: Allow setting the NDEF prefix from the CLI
+ ** FIDO: Block reset when multiple YubiKeys are connected
+
+* Version 0.7.1 (released 2018-07-09)
+ ** Support for YubiKey FIPS.
+ ** OTP: Allow setting and removing access codes on the slots.
+ ** Interfaces: set-lock-code now only accepts hexadecimal inputs.
+ ** Bugfix: Don't fail to open the YubiKey when the serial is not visible.
+
+* Version 0.7.0 (released 2018-05-07)
+ ** Support for YubiKey Preview.
+ ** Add command to configure enabled applications over USB and NFC. See ykman config -h.
+ ** Add command for selecting which slot to use for NDEF. See ykman otp ndef -h.
+
+* Version 0.6.1 (released 2018-04-16)
+ ** Support for YubiKeys with FIDO2. See ykman fido -h
+ ** Report the form factor for YubiKeys that support it.
+ ** OTP: slot command is now called otp. See ykman otp -h for all changes.
+ ** Static password: Add support for different keyboard layouts. See ykman otp static -h
+ ** PIV: Signatures for CSRs are now correct.
+ ** PIV: Commands on slots with PIN policy ALWAYS no longer fail if the YubiKey has a management key protected by PIN.
+ ** Mode: The U2F mode is now called FIDO.
+ ** Dependencies: libu2f-host is no longer used for FIDO communication over USB, instead the python library fido2 is used.
+
+* Version 0.6.0 (released 2018-02-09)
+ ** OpenPGP: Expose remaining PIN retries in info command and API.
+ ** CCID: Only try YubiKey smart card readers by default.
+ ** Handle NEO issues with challenge-response credentials better.
+ ** Improve logging.
+ ** Improve error handling when opening device over OTP.
+ ** Bugfix: Fix adding OTP data through the interactive prompt.
+
+* Version 0.5.0 (released 2017-12-15)
+ ** API breaking changes:
+  *** OATH: New API more similar to yubioath-android
+ ** CLI breaking changes:
+  *** OATH: Touch prompt now written to stderr instead of stdout
+  *** OATH: `-a|--algorithm` option to `list` command removed
+  *** OATH: Columns in `code` command are now dynamically spaced depending on contents
+  *** OATH: `delete` command now requires confirmation or `-f|--force` argument
+  *** OATH: IDs printed by `list` command now include TOTP period if not 30
+  *** Changed outputs:
+   **** INFO: "Device name" output changed to "Device type"
+   **** PIV: "Management key is stored on device" output changed to "Management key is stored on the YubiKey"
+   **** PIV: "All PIV data have been cleared from the device" output changed to "All PIV data have been cleared from your YubiKey"
+   **** PIV: "The current management key is stored on the device" prompt changed to "The current management key is stored on the YubiKey"
+   **** SLOT: "blank to use device serial" prompt changed to "blank to use YubiKey serial number"
+   **** SLOT: "Using device serial" output changed to "Using YubiKey device serial"
+   **** Lots of failure case outputs changed
+ ** New features:
+  *** Support for multiple devices via new top-level option `-d|--device`
+  *** New top-level option `-l|--log-level` to enable logging
+  *** OATH: Support for remembering passwords locally.
+  *** OATH: New option `-s|--single` for `code` command
+  *** PIV: `set-pin-retries` command now warns that PIN and PUK will be reset to factory defaults, and prints those defaults after resetting
+ ** API bug fixes:
+  *** OATH: `valid_from` and `valid_to` for `Code` are now absolute instead of relative to the credential period
+  *** OATH: `period` for non-TOTP `Code` is now `None`
+
+* Version 0.4.6 (released 2017-10-17)
+ ** Will now attempt to open device 3 times before failing
+ ** OpenPGP: Don't say data is removed when not
+ ** OpenPGP: Don't swallow APDU errors
+ ** PIV: Block on-chip RSA key generation for firmware versions 4.2.0 to 4.3.4 (inclusive) since these chips are vulnerable to http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-15361[CVE-2017-15631].
+
+* Version 0.4.5 (released 2017-09-14)
+ ** OATH: Don't print issuer if there is no issuer.
+
+* Version 0.4.4 (released 2017-09-06)
+ ** OATH: Fix yet another issue with backwards compatibility, for adding new credentials.
+
+* Version 0.4.3 (released 2017-09-06)
+ ** OATH: Fix issue with backwards compatibility, when used as a library.
+
+* Version 0.4.2 (released 2017-09-05)
+ ** OATH: Support 7 digit credentials.
+ ** OATH: Support credentials with a period other than 30 seconds.
+ ** OATH: The remove command is now called delete.
+
+* Version 0.4.1 (released 2017-08-10)
+ ** PIV: Dropped support for deriving a management key from PIN.
+ ** PIV: Added support for generating a random management key and storing it on the device protected by the PIN.
+ ** OpenPGP: The reset command now handles a device in terminated state.
+ ** OATH: Credential filtering is now working properly on Python 2.
+
+* Version 0.4.0 (released 2017-06-19)
+ ** Added PIV support. The tool and library now supports most of the PIV functionality found on the YubiKey 4 and NEO. To list the available commands, run ykman piv -h.
+ ** Mode command now supports adding and removing modes incrementally.
+
+* Version 0.3.3 (released 2017-05-08)
+ ** Bugfix: Fix issue with OATH credentials from Steam on YubiKey 4.
+
+* Version 0.3.2 (released 2017-04-24)
+ ** Allow access code input through an interactive prompt.
+ ** Bugfix: Some versions of YubiKey NEO occasionally failed calculating challenge-response credentials with touch.
+
+* Version 0.3.1 (released 2017-03-13)
+ ** Allow programming of TOTP credentials in YubiKey Slots using the chalresp command.
+ ** Add a calculate command (and library support) to perform a challenge-response operation. Can also be used to generate TOTP codes for credentials stored in a slot.
+ ** OATH: Remove whitespace in secret keys provided by the user.
+ ** OATH: Prompt the user to touch the YubiKey for HOTP touch credentials.
+ ** Bugfix: The flag for showing hidden credentials was not working correctly for the oath code command.
+
+* Version 0.3.0 (released 2017-01-23)
+ ** OATH functionality added. The tool now exposes the OATH functionality found on the YubiKey 4 and NEO. To list the available commands, run ykman oath -h.
+ ** Added support for randomly generated static passwords.
+
+* Version 0.2.0 (released 2016-11-23)
+ ** Removed all GUI code. This project is now only for the python library and CLI tool. The GUI will be re-released separately in a different project.
+ ** Added command to update settings for YubiKey Slots.
+
+* Version 0.1.0 (released 2016-07-07)
+ ** Initial release for beta testing.
```

### Comparing `yubikey_manager-5.1.0/README.adoc` & `yubikey_manager-5.1.1/README.adoc`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,172 +1,172 @@
-== YubiKey Manager CLI
-image:https://github.com/Yubico/yubikey-manager/workflows/build/badge.svg["Build Status", link="https://github.com/Yubico/yubikey-manager/actions"]
-
-Python 3.7 (or later) library and command line tool for configuring a YubiKey.
-If you're looking for the graphical application, it's https://developers.yubico.com/yubikey-manager-qt/[here].
-
-=== Usage
-For more usage information and examples, see the https://docs.yubico.com/software/yubikey/tools/ykman/Using_the_ykman_CLI.html[YubiKey Manager CLI User Manual].
-
-....
-Usage: ykman [OPTIONS] COMMAND [ARGS]...
-
-  Configure your YubiKey via the command line.
-
-  Examples:
-
-    List connected YubiKeys, only output serial number:
-    $ ykman list --serials
-
-    Show information about YubiKey with serial number 0123456:
-    $ ykman --device 0123456 info
-
-Options:
-  -d, --device SERIAL             specify which YubiKey to interact with by serial number
-  -r, --reader NAME               specify a YubiKey by smart card reader name (can't be used with --device or list)
-  -l, --log-level [ERROR|WARNING|INFO|DEBUG|TRAFFIC]
-                                  enable logging at given verbosity level
-  --log-file FILE                 write log to FILE instead of printing to stderr (requires --log-level)
-  --diagnose                      show diagnostics information useful for troubleshooting
-  -v, --version                   show version information about the app
-  --full-help                     show --help output, including hidden commands
-  -h, --help                      show this message and exit
-
-Commands:
-  info     show general information
-  list     list connected YubiKeys
-  config   enable or disable applications
-  fido     manage the FIDO applications
-  oath     manage the OATH application
-  openpgp  manage the OpenPGP application
-  otp      manage the YubiOTP application
-  piv      manage the PIV application
-....
-
-The `--help` argument can also be used to get detailed information about specific
-subcommands:
-
-    ykman oath --help
-
-=== Versioning/Compatibility
-This project follows https://semver.org/[Semantic Versioning]. Any project
-depending on yubikey-manager should take care when specifying version ranges to
-not include any untested major version, as it is likely to have backwards
-incompatible changes. For example, you should NOT depend on ">=5", as it has no
-upper bound. Instead, depend on ">=5, <6", as any release before 6 will be
-compatible.
-
-Note that any private variables (names starting with '_') are not part of the
-public API, and may be changed between versions at any time.
-
-=== Installation
-YubiKey Manager can be installed independently of platform by using pip (or
-equivalent):
-
-  pip install --user yubikey-manager
-
-On Linux platforms you will need `pcscd` installed and running to be able to
-communicate with a YubiKey over the SmartCard interface. Additionally, you may
-need to set permissions for your user to access YubiKeys via the HID interfaces.
-More information available link:doc/Device_Permissions.adoc[here].
-
-Some of the libraries used by yubikey-manager have C-extensions, and may require
-additional dependencies to build, such as http://www.swig.org/[swig] and
-potentially https://pcsclite.apdu.fr/[PCSC lite].
-
-=== Pre-build packages
-Pre-built packages specific to your platform may be available from Yubico or
-third parties. Please refer to your platforms native package manager for
-detailed instructions on how to install, if available.
-
-==== Windows
-A Windows installer is available to download from the
-https://github.com/Yubico/yubikey-manager/releases/latest[Releases page].
-
-==== MacOS
-A MacOS installer is available to download from the
-https://github.com/Yubico/yubikey-manager/releases/latest[Releases page].
-
-Additionally, packages are available from Homebrew and MacPorts.
-
-===== Input Monitoring access on MacOS
-When running one of the `ykman otp` commands you may run into an error such as:
-`Failed to open device for communication: -536870174`. This indicates a problem
-with the permission to access the OTP (keyboard) USB interface.
-  
-To access a YubiKey over this interface the application needs the `Input
-Monitoring` permission. If you are not automatically prompted to grant this
-permission, you may have to do so manually. Note that it is the _terminal_ you
-are using that needs the permission, not the ykman executable.
-
-To add your terminal application to the `Input Monitoring` permission list, go
-to `System Preferences -> Security & Privacy -> Privacy -> Input Monitoring` to
-resolve this.
-
-==== Linux
-Packages are available for several Linux distributions by third party package
-maintainers.
-Yubico also provides packages for Ubuntu in the yubico/stable PPA:
-
-  $ sudo apt-add-repository ppa:yubico/stable
-  $ sudo apt update
-  $ sudo apt install yubikey-manager
-
-==== FreeBSD
-Althought not being officially supported on this platform, YubiKey Manager can be
-installed on FreeBSD. It's available via its ports tree or as pre-built package.
-Should you opt to install and use YubiKey Manager on this platform, please be aware
-that it's **NOT** maintained by Yubico.
-
-To install the binary package, use `pkg install pyXY-yubikey-manager`, with `pyXY`
-specifying the version of Python the package was built for, so in order to install
-YubiKey Manager for Python 3.8, use:
-
-  # pkg install py38-yubikey-manager
-
-For more information about how to install packages or ports on FreeBSD, please refer
-to its official documentation: https://docs.freebsd.org/en/books/handbook/ports[FreeBSD Handbook].
-
-In order to use `ykman otp` commands, you need to make sure the _uhid(4)_ driver
-attaches to the USB device:
-
-  # usbconfig ugenX.Y add_quirk UQ_KBD_IGNORE
-  # usbconfig ugenX.Y reset
-
-The correct device to operate on _(ugenX.Y)_ can be determined using
-`usbconfig list`.
-
-When using FreeBSD 13 or higher, you can switch to the more modern _hidraw(4)_
-driver. This allows YubiKey Manager to access OTP HID in a non-exclusive way,
-so that the key will still function as a USB keyboard:
-
-  # sysrc kld_list+="hidraw hkbd"
-  # cat >>/boot/loader.conf<<EOF
-  hw.usb.usbhid.enable="1"
-  hw.usb.quirk.0="0x1050 0x0010 0 0xffff UQ_KBD_IGNORE"  # YKS_OTP
-  hw.usb.quirk.1="0x1050 0x0110 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP
-  hw.usb.quirk.2="0x1050 0x0111 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_CCID
-  hw.usb.quirk.3="0x1050 0x0114 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO
-  hw.usb.quirk.4="0x1050 0x0116 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO_CCID
-  hw.usb.quirk.5="0x1050 0x0401 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP
-  hw.usb.quirk.6="0x1050 0x0403 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO
-  hw.usb.quirk.7="0x1050 0x0405 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_CCID
-  hw.usb.quirk.8="0x1050 0x0407 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO_CCID
-  hw.usb.quirk.9="0x1050 0x0410 0 0xffff UQ_KBD_IGNORE"  # YKP_OTP_FIDO
-  EOF
-  # reboot
-
-==== From source (for development)
-To install from source, see the link:doc/Development.adoc[development]
-instructions.
-
-=== Shell completion
-
-Experimental shell completion for the command line tool is available, provided
-by the underlying CLI library (`click`) but it is not enabled by default. To
-enable it, run this command once (for Bash):
-
-  $ source <(_YKMAN_COMPLETE=bash_source ykman | sudo tee /etc/bash_completion.d/ykman)
-
-More information on shell completion (including instructions for zch) is
-available here:
-https://click.palletsprojects.com/en/8.0.x/shell-completion
+== YubiKey Manager CLI
+image:https://github.com/Yubico/yubikey-manager/workflows/build/badge.svg["Build Status", link="https://github.com/Yubico/yubikey-manager/actions"]
+
+Python 3.7 (or later) library and command line tool for configuring a YubiKey.
+If you're looking for the graphical application, it's https://developers.yubico.com/yubikey-manager-qt/[here].
+
+=== Usage
+For more usage information and examples, see the https://docs.yubico.com/software/yubikey/tools/ykman/Using_the_ykman_CLI.html[YubiKey Manager CLI User Manual].
+
+....
+Usage: ykman [OPTIONS] COMMAND [ARGS]...
+
+  Configure your YubiKey via the command line.
+
+  Examples:
+
+    List connected YubiKeys, only output serial number:
+    $ ykman list --serials
+
+    Show information about YubiKey with serial number 0123456:
+    $ ykman --device 0123456 info
+
+Options:
+  -d, --device SERIAL             specify which YubiKey to interact with by serial number
+  -r, --reader NAME               specify a YubiKey by smart card reader name (can't be used with --device or list)
+  -l, --log-level [ERROR|WARNING|INFO|DEBUG|TRAFFIC]
+                                  enable logging at given verbosity level
+  --log-file FILE                 write log to FILE instead of printing to stderr (requires --log-level)
+  --diagnose                      show diagnostics information useful for troubleshooting
+  -v, --version                   show version information about the app
+  --full-help                     show --help output, including hidden commands
+  -h, --help                      show this message and exit
+
+Commands:
+  info     show general information
+  list     list connected YubiKeys
+  config   enable or disable applications
+  fido     manage the FIDO applications
+  oath     manage the OATH application
+  openpgp  manage the OpenPGP application
+  otp      manage the YubiOTP application
+  piv      manage the PIV application
+....
+
+The `--help` argument can also be used to get detailed information about specific
+subcommands:
+
+    ykman oath --help
+
+=== Versioning/Compatibility
+This project follows https://semver.org/[Semantic Versioning]. Any project
+depending on yubikey-manager should take care when specifying version ranges to
+not include any untested major version, as it is likely to have backwards
+incompatible changes. For example, you should NOT depend on ">=5", as it has no
+upper bound. Instead, depend on ">=5, <6", as any release before 6 will be
+compatible.
+
+Note that any private variables (names starting with '_') are not part of the
+public API, and may be changed between versions at any time.
+
+=== Installation
+YubiKey Manager can be installed independently of platform by using pip (or
+equivalent):
+
+  pip install --user yubikey-manager
+
+On Linux platforms you will need `pcscd` installed and running to be able to
+communicate with a YubiKey over the SmartCard interface. Additionally, you may
+need to set permissions for your user to access YubiKeys via the HID interfaces.
+More information available link:doc/Device_Permissions.adoc[here].
+
+Some of the libraries used by yubikey-manager have C-extensions, and may require
+additional dependencies to build, such as http://www.swig.org/[swig] and
+potentially https://pcsclite.apdu.fr/[PCSC lite].
+
+=== Pre-build packages
+Pre-built packages specific to your platform may be available from Yubico or
+third parties. Please refer to your platforms native package manager for
+detailed instructions on how to install, if available.
+
+==== Windows
+A Windows installer is available to download from the
+https://github.com/Yubico/yubikey-manager/releases/latest[Releases page].
+
+==== MacOS
+A MacOS installer is available to download from the
+https://github.com/Yubico/yubikey-manager/releases/latest[Releases page].
+
+Additionally, packages are available from Homebrew and MacPorts.
+
+===== Input Monitoring access on MacOS
+When running one of the `ykman otp` commands you may run into an error such as:
+`Failed to open device for communication: -536870174`. This indicates a problem
+with the permission to access the OTP (keyboard) USB interface.
+  
+To access a YubiKey over this interface the application needs the `Input
+Monitoring` permission. If you are not automatically prompted to grant this
+permission, you may have to do so manually. Note that it is the _terminal_ you
+are using that needs the permission, not the ykman executable.
+
+To add your terminal application to the `Input Monitoring` permission list, go
+to `System Preferences -> Security & Privacy -> Privacy -> Input Monitoring` to
+resolve this.
+
+==== Linux
+Packages are available for several Linux distributions by third party package
+maintainers.
+Yubico also provides packages for Ubuntu in the yubico/stable PPA:
+
+  $ sudo apt-add-repository ppa:yubico/stable
+  $ sudo apt update
+  $ sudo apt install yubikey-manager
+
+==== FreeBSD
+Althought not being officially supported on this platform, YubiKey Manager can be
+installed on FreeBSD. It's available via its ports tree or as pre-built package.
+Should you opt to install and use YubiKey Manager on this platform, please be aware
+that it's **NOT** maintained by Yubico.
+
+To install the binary package, use `pkg install pyXY-yubikey-manager`, with `pyXY`
+specifying the version of Python the package was built for, so in order to install
+YubiKey Manager for Python 3.8, use:
+
+  # pkg install py38-yubikey-manager
+
+For more information about how to install packages or ports on FreeBSD, please refer
+to its official documentation: https://docs.freebsd.org/en/books/handbook/ports[FreeBSD Handbook].
+
+In order to use `ykman otp` commands, you need to make sure the _uhid(4)_ driver
+attaches to the USB device:
+
+  # usbconfig ugenX.Y add_quirk UQ_KBD_IGNORE
+  # usbconfig ugenX.Y reset
+
+The correct device to operate on _(ugenX.Y)_ can be determined using
+`usbconfig list`.
+
+When using FreeBSD 13 or higher, you can switch to the more modern _hidraw(4)_
+driver. This allows YubiKey Manager to access OTP HID in a non-exclusive way,
+so that the key will still function as a USB keyboard:
+
+  # sysrc kld_list+="hidraw hkbd"
+  # cat >>/boot/loader.conf<<EOF
+  hw.usb.usbhid.enable="1"
+  hw.usb.quirk.0="0x1050 0x0010 0 0xffff UQ_KBD_IGNORE"  # YKS_OTP
+  hw.usb.quirk.1="0x1050 0x0110 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP
+  hw.usb.quirk.2="0x1050 0x0111 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_CCID
+  hw.usb.quirk.3="0x1050 0x0114 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO
+  hw.usb.quirk.4="0x1050 0x0116 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO_CCID
+  hw.usb.quirk.5="0x1050 0x0401 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP
+  hw.usb.quirk.6="0x1050 0x0403 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO
+  hw.usb.quirk.7="0x1050 0x0405 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_CCID
+  hw.usb.quirk.8="0x1050 0x0407 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO_CCID
+  hw.usb.quirk.9="0x1050 0x0410 0 0xffff UQ_KBD_IGNORE"  # YKP_OTP_FIDO
+  EOF
+  # reboot
+
+==== From source (for development)
+To install from source, see the link:doc/Development.adoc[development]
+instructions.
+
+=== Shell completion
+
+Experimental shell completion for the command line tool is available, provided
+by the underlying CLI library (`click`) but it is not enabled by default. To
+enable it, run this command once (for Bash):
+
+  $ source <(_YKMAN_COMPLETE=bash_source ykman | sudo tee /etc/bash_completion.d/ykman)
+
+More information on shell completion (including instructions for zch) is
+available here:
+https://click.palletsprojects.com/en/8.0.x/shell-completion
```

### Comparing `yubikey_manager-5.1.0/pyproject.toml` & `yubikey_manager-5.1.1/pyproject.toml`

 * *Files 22% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-[tool.poetry]
-name = "yubikey-manager"
-version = "5.1.0"
-description = "Tool for managing your YubiKey configuration."
-authors = ["Dain Nilsson <dain@yubico.com>"]
-license = "BSD"
-homepage = "https://github.com/Yubico/yubikey-manager"
-repository = "https://github.com/Yubico/yubikey-manager"
-keywords = ["yubikey", "yubiotp", "piv", "fido"]
-classifiers = [
-  "Development Status :: 5 - Production/Stable",
-  "Intended Audience :: End Users/Desktop",
-  "Topic :: Security :: Cryptography",
-  "Topic :: Utilities"
-]
-include = [
-  { path = "COPYING", format = "sdist"},
-  { path = "NEWS", format = "sdist"},
-  { path = "README.adoc", format = "sdist"},
-  "man/",
-  "tests/",
-]
-packages = [
-  { include = "yubikit" },
-  { include = "ykman" },
-]
-
-
-[tool.poetry.dependencies]
-python = "^3.7"
-cryptography = ">=3.0, <43"
-pyscard = "^2.0"
-fido2 = "^1.0"
-click = "^8.0"
-pywin32 = {version = ">=223", platform = "win32"}
-keyring = "^23.4"
-
-[tool.poetry.dev-dependencies]
-pytest = "^7.2"
-makefun = "^1.9.5"
-pyinstaller = {version = "^5.7", python = "<3.12"}
-
-[tool.poetry.scripts]
-ykman = "ykman._cli.__main__:main"
-
-[build-system]
-requires = ["poetry-core>=1.0.0"]
-build-backend = "poetry.core.masonry.api"
-
-[tool.pytest.ini_options]
-testpaths = ["tests"]
+[tool.poetry]
+name = "yubikey-manager"
+version = "5.1.1"
+description = "Tool for managing your YubiKey configuration."
+authors = ["Dain Nilsson <dain@yubico.com>"]
+license = "BSD"
+homepage = "https://github.com/Yubico/yubikey-manager"
+repository = "https://github.com/Yubico/yubikey-manager"
+keywords = ["yubikey", "yubiotp", "piv", "fido"]
+classifiers = [
+  "Development Status :: 5 - Production/Stable",
+  "Intended Audience :: End Users/Desktop",
+  "Topic :: Security :: Cryptography",
+  "Topic :: Utilities"
+]
+include = [
+  { path = "COPYING", format = "sdist"},
+  { path = "NEWS", format = "sdist"},
+  { path = "README.adoc", format = "sdist"},
+  "man/",
+  "tests/",
+]
+packages = [
+  { include = "yubikit" },
+  { include = "ykman" },
+]
+
+
+[tool.poetry.dependencies]
+python = "^3.7"
+cryptography = ">=3.0, <43"
+pyscard = "^2.0"
+fido2 = "^1.0"
+click = "^8.0"
+pywin32 = {version = ">=223", platform = "win32"}
+keyring = "^23.4"
+
+[tool.poetry.dev-dependencies]
+pytest = "^7.2"
+makefun = "^1.9.5"
+pyinstaller = {version = "^5.7", python = "<3.12"}
+
+[tool.poetry.scripts]
+ykman = "ykman._cli.__main__:main"
+
+[build-system]
+requires = ["poetry-core>=1.0.0"]
+build-backend = "poetry.core.masonry.api"
+
+[tool.pytest.ini_options]
+testpaths = ["tests"]
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/conftest.py` & `yubikey_manager-5.1.1/tests/device/cli/conftest.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,34 +1,34 @@
-from yubikit.core import TRANSPORT
-from ykman._cli.__main__ import cli, _DefaultFormatter
-from ykman._cli.aliases import apply_aliases
-from ykman._cli.util import CliFail
-from click.testing import CliRunner
-from functools import partial
-import logging
-import pytest
-
-
-@pytest.fixture(scope="module")
-def ykman_cli(device, info):
-    if device.transport == TRANSPORT.NFC:
-        return partial(_ykman_cli, "--reader", device.reader.name)
-    elif info.serial is not None:
-        return partial(_ykman_cli, "--device", info.serial)
-    else:
-        return _ykman_cli
-
-
-def _ykman_cli(*argv, **kwargs):
-    handler = logging.StreamHandler()
-    handler.setLevel(logging.WARNING)
-    handler.setFormatter(_DefaultFormatter())
-    logging.getLogger().addHandler(handler)
-
-    argv = apply_aliases(["ykman"] + [str(a) for a in argv])
-    runner = CliRunner(mix_stderr=False)
-    result = runner.invoke(cli, argv[1:], obj={}, **kwargs)
-    if result.exit_code != 0:
-        if isinstance(result.exception, CliFail):
-            raise SystemExit()
-        raise result.exception
-    return result
+from yubikit.core import TRANSPORT
+from ykman._cli.__main__ import cli, _DefaultFormatter
+from ykman._cli.aliases import apply_aliases
+from ykman._cli.util import CliFail
+from click.testing import CliRunner
+from functools import partial
+import logging
+import pytest
+
+
+@pytest.fixture(scope="module")
+def ykman_cli(device, info):
+    if device.transport == TRANSPORT.NFC:
+        return partial(_ykman_cli, "--reader", device.reader.name)
+    elif info.serial is not None:
+        return partial(_ykman_cli, "--device", info.serial)
+    else:
+        return _ykman_cli
+
+
+def _ykman_cli(*argv, **kwargs):
+    handler = logging.StreamHandler()
+    handler.setLevel(logging.WARNING)
+    handler.setFormatter(_DefaultFormatter())
+    logging.getLogger().addHandler(handler)
+
+    argv = apply_aliases(["ykman"] + [str(a) for a in argv])
+    runner = CliRunner(mix_stderr=False)
+    result = runner.invoke(cli, argv[1:], obj={}, **kwargs)
+    if result.exit_code != 0:
+        if isinstance(result.exception, CliFail):
+            raise SystemExit()
+        raise result.exception
+    return result
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_fips.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_fips.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-from yubikit.management import CAPABILITY
-from yubikit.core import NotSupportedError
-from ....util import open_file
-from ... import condition
-import pytest
-
-
-@pytest.fixture(autouse=True)
-@condition.yk4_fips(True)
-@condition.capability(CAPABILITY.PIV)
-def ensure_piv(ykman_cli):
-    ykman_cli("piv", "reset", "-f")
-
-
-class TestFIPS:
-    def test_rsa1024_generate_blocked(self, ykman_cli):
-        with pytest.raises(NotSupportedError):
-            ykman_cli("piv", "keys", "generate", "9a", "-a", "RSA1024", "-")
-
-    def test_rsa1024_import_blocked(self, ykman_cli):
-        with pytest.raises(NotSupportedError):
-            with open_file("rsa_1024_key.pem") as f:
-                ykman_cli("piv", "keys", "import", "9a", f.name)
+from yubikit.management import CAPABILITY
+from yubikit.core import NotSupportedError
+from ....util import open_file
+from ... import condition
+import pytest
+
+
+@pytest.fixture(autouse=True)
+@condition.yk4_fips(True)
+@condition.capability(CAPABILITY.PIV)
+def ensure_piv(ykman_cli):
+    ykman_cli("piv", "reset", "-f")
+
+
+class TestFIPS:
+    def test_rsa1024_generate_blocked(self, ykman_cli):
+        with pytest.raises(NotSupportedError):
+            ykman_cli("piv", "keys", "generate", "9a", "-a", "RSA1024", "-")
+
+    def test_rsa1024_import_blocked(self, ykman_cli):
+        with pytest.raises(NotSupportedError):
+            with open_file("rsa_1024_key.pem") as f:
+                ykman_cli("piv", "keys", "import", "9a", f.name)
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_generate_cert_and_csr.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_generate_cert_and_csr.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,306 +1,306 @@
-from binascii import b2a_hex
-from cryptography import x509
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.asymmetric import ec, rsa, padding
-from .util import DEFAULT_PIN, DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY
-from ... import condition
-import pytest
-
-
-def _verify_cert(cert, pubkey):
-    cert_signature = cert.signature
-    cert_bytes = cert.tbs_certificate_bytes
-
-    if isinstance(pubkey, rsa.RSAPublicKey):
-        pubkey.verify(
-            cert_signature,
-            cert_bytes,
-            padding.PKCS1v15(),
-            cert.signature_hash_algorithm,
-        )
-    elif isinstance(pubkey, ec.EllipticCurvePublicKey):
-        pubkey.verify(
-            cert_signature, cert_bytes, ec.ECDSA(cert.signature_hash_algorithm)
-        )
-    else:
-        raise ValueError("Unsupported public key value")
-
-
-def not_roca(version):
-    return not ((4, 2, 0) <= version < (4, 3, 5))
-
-
-class TestNonDefaultMgmKey:
-    @pytest.fixture(autouse=True)
-    def set_mgmt_key(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-P",
-            DEFAULT_PIN,
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            "-n",
-            NON_DEFAULT_MANAGEMENT_KEY,
-        )
-
-    def _test_generate_self_signed(self, ykman_cli, slot, algo):
-        pubkey_output = ykman_cli(
-            "piv",
-            "keys",
-            "generate",
-            slot,
-            "-a",
-            algo,
-            "-m",
-            NON_DEFAULT_MANAGEMENT_KEY,
-            "-",
-        ).output
-        ykman_cli(
-            "piv",
-            "certificates",
-            "generate",
-            slot,
-            "-m",
-            NON_DEFAULT_MANAGEMENT_KEY,
-            "-s",
-            "subject-" + algo,
-            "-P",
-            DEFAULT_PIN,
-            "-",
-            input=pubkey_output,
-        )
-        output = ykman_cli("piv", "certificates", "export", slot, "-").output
-        cert = x509.load_pem_x509_certificate(output.encode(), default_backend())
-        _verify_cert(cert, cert.public_key())
-        fingerprint = b2a_hex(cert.fingerprint(hashes.SHA256())).decode("ascii")
-
-        output = ykman_cli("piv", "info").output
-        assert fingerprint in output
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9a_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9a", "RSA1024")
-
-    def test_generate_self_signed_slot_9a_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9a", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9c_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9c", "RSA1024")
-
-    def test_generate_self_signed_slot_9c_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9c", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9d_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9d", "RSA1024")
-
-    def test_generate_self_signed_slot_9d_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9d", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9e_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9e", "RSA1024")
-
-    def test_generate_self_signed_slot_9e_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9e", "ECCP256")
-
-    def _test_generate_csr(self, ykman_cli, slot, algo):
-        subject_input = "subject-" + algo
-        pubkey_output = ykman_cli(
-            "piv",
-            "keys",
-            "generate",
-            slot,
-            "-a",
-            algo,
-            "-m",
-            NON_DEFAULT_MANAGEMENT_KEY,
-            "-",
-        ).output
-        csr_output = ykman_cli(
-            "piv",
-            "certificates",
-            "request",
-            slot,
-            "-P",
-            DEFAULT_PIN,
-            "-",
-            "-",
-            "-s",
-            subject_input,
-            input=pubkey_output,
-        ).output
-        csr = x509.load_pem_x509_csr(csr_output.encode("utf-8"), default_backend())
-        subject_output = csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[
-            0
-        ].value
-
-        assert subject_input == subject_output
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9a_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9a", "RSA1024")
-
-    def test_generate_csr_slot_9a_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9a", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9c_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9c", "RSA1024")
-
-    def test_generate_csr_slot_9c_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9c", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9d_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9d", "RSA1024")
-
-    def test_generate_csr_slot_9d_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9d", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9e_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9e", "RSA1024")
-
-    def test_generate_csr_slot_9e_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9e", "ECCP256")
-
-
-class TestProtectedMgmKey:
-    @pytest.fixture(autouse=True)
-    def protect_mgmt_key(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-p",
-            "-P",
-            DEFAULT_PIN,
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-        )
-
-    def _test_generate_self_signed(self, ykman_cli, slot, algo):
-        pubkey_output = ykman_cli(
-            "piv", "keys", "generate", slot, "-a", algo, "-P", DEFAULT_PIN, "-"
-        ).output
-        ykman_cli(
-            "piv",
-            "certificates",
-            "generate",
-            slot,
-            "-P",
-            DEFAULT_PIN,
-            "-s",
-            "subject-" + algo,
-            "-",
-            input=pubkey_output,
-        )
-        output = ykman_cli("piv", "certificates", "export", slot, "-").output
-        cert = x509.load_pem_x509_certificate(output.encode(), default_backend())
-        _verify_cert(cert, cert.public_key())
-        fingerprint = b2a_hex(cert.fingerprint(hashes.SHA256())).decode("ascii")
-
-        output = ykman_cli("piv", "info").output
-        assert fingerprint in output
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9a_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9a", "RSA1024")
-
-    def test_generate_self_signed_slot_9a_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9a", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9c_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9c", "RSA1024")
-
-    def test_generate_self_signed_slot_9c_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9c", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9d_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9d", "RSA1024")
-
-    def test_generate_self_signed_slot_9d_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9d", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_self_signed_slot_9e_rsa1024(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9e", "RSA1024")
-
-    def test_generate_self_signed_slot_9e_eccp256(self, ykman_cli):
-        self._test_generate_self_signed(ykman_cli, "9e", "ECCP256")
-
-    def _test_generate_csr(self, ykman_cli, slot, algo):
-        subject_input = "subject-" + algo
-        pubkey_output = ykman_cli(
-            "piv", "keys", "generate", slot, "-a", algo, "-P", DEFAULT_PIN, "-"
-        ).output
-        csr_output = ykman_cli(
-            "piv",
-            "certificates",
-            "request",
-            slot,
-            "-P",
-            DEFAULT_PIN,
-            "-",
-            "-",
-            "-s",
-            subject_input,
-            input=pubkey_output,
-        ).output
-        csr = x509.load_pem_x509_csr(csr_output.encode("utf-8"), default_backend())
-        subject_output = csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[
-            0
-        ].value
-
-        assert subject_input == subject_output
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9a_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9a", "RSA1024")
-
-    def test_generate_csr_slot_9a_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9a", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9c_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9c", "RSA1024")
-
-    def test_generate_csr_slot_9c_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9c", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9d_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9d", "RSA1024")
-
-    def test_generate_csr_slot_9d_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9d", "ECCP256")
-
-    @condition.yk4_fips(False)
-    @condition.check(not_roca)
-    def test_generate_csr_slot_9e_rsa1024(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9e", "RSA1024")
-
-    def test_generate_csr_slot_9e_eccp256(self, ykman_cli):
-        self._test_generate_csr(ykman_cli, "9e", "ECCP256")
+from binascii import b2a_hex
+from cryptography import x509
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import ec, rsa, padding
+from .util import DEFAULT_PIN, DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY
+from ... import condition
+import pytest
+
+
+def _verify_cert(cert, pubkey):
+    cert_signature = cert.signature
+    cert_bytes = cert.tbs_certificate_bytes
+
+    if isinstance(pubkey, rsa.RSAPublicKey):
+        pubkey.verify(
+            cert_signature,
+            cert_bytes,
+            padding.PKCS1v15(),
+            cert.signature_hash_algorithm,
+        )
+    elif isinstance(pubkey, ec.EllipticCurvePublicKey):
+        pubkey.verify(
+            cert_signature, cert_bytes, ec.ECDSA(cert.signature_hash_algorithm)
+        )
+    else:
+        raise ValueError("Unsupported public key value")
+
+
+def not_roca(version):
+    return not ((4, 2, 0) <= version < (4, 3, 5))
+
+
+class TestNonDefaultMgmKey:
+    @pytest.fixture(autouse=True)
+    def set_mgmt_key(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-P",
+            DEFAULT_PIN,
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            "-n",
+            NON_DEFAULT_MANAGEMENT_KEY,
+        )
+
+    def _test_generate_self_signed(self, ykman_cli, slot, algo):
+        pubkey_output = ykman_cli(
+            "piv",
+            "keys",
+            "generate",
+            slot,
+            "-a",
+            algo,
+            "-m",
+            NON_DEFAULT_MANAGEMENT_KEY,
+            "-",
+        ).output
+        ykman_cli(
+            "piv",
+            "certificates",
+            "generate",
+            slot,
+            "-m",
+            NON_DEFAULT_MANAGEMENT_KEY,
+            "-s",
+            "subject-" + algo,
+            "-P",
+            DEFAULT_PIN,
+            "-",
+            input=pubkey_output,
+        )
+        output = ykman_cli("piv", "certificates", "export", slot, "-").output
+        cert = x509.load_pem_x509_certificate(output.encode(), default_backend())
+        _verify_cert(cert, cert.public_key())
+        fingerprint = b2a_hex(cert.fingerprint(hashes.SHA256())).decode("ascii")
+
+        output = ykman_cli("piv", "info").output
+        assert fingerprint in output
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9a_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9a", "RSA1024")
+
+    def test_generate_self_signed_slot_9a_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9a", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9c_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9c", "RSA1024")
+
+    def test_generate_self_signed_slot_9c_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9c", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9d_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9d", "RSA1024")
+
+    def test_generate_self_signed_slot_9d_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9d", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9e_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9e", "RSA1024")
+
+    def test_generate_self_signed_slot_9e_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9e", "ECCP256")
+
+    def _test_generate_csr(self, ykman_cli, slot, algo):
+        subject_input = "subject-" + algo
+        pubkey_output = ykman_cli(
+            "piv",
+            "keys",
+            "generate",
+            slot,
+            "-a",
+            algo,
+            "-m",
+            NON_DEFAULT_MANAGEMENT_KEY,
+            "-",
+        ).output
+        csr_output = ykman_cli(
+            "piv",
+            "certificates",
+            "request",
+            slot,
+            "-P",
+            DEFAULT_PIN,
+            "-",
+            "-",
+            "-s",
+            subject_input,
+            input=pubkey_output,
+        ).output
+        csr = x509.load_pem_x509_csr(csr_output.encode("utf-8"), default_backend())
+        subject_output = csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[
+            0
+        ].value
+
+        assert subject_input == subject_output
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9a_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9a", "RSA1024")
+
+    def test_generate_csr_slot_9a_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9a", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9c_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9c", "RSA1024")
+
+    def test_generate_csr_slot_9c_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9c", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9d_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9d", "RSA1024")
+
+    def test_generate_csr_slot_9d_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9d", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9e_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9e", "RSA1024")
+
+    def test_generate_csr_slot_9e_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9e", "ECCP256")
+
+
+class TestProtectedMgmKey:
+    @pytest.fixture(autouse=True)
+    def protect_mgmt_key(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-p",
+            "-P",
+            DEFAULT_PIN,
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+        )
+
+    def _test_generate_self_signed(self, ykman_cli, slot, algo):
+        pubkey_output = ykman_cli(
+            "piv", "keys", "generate", slot, "-a", algo, "-P", DEFAULT_PIN, "-"
+        ).output
+        ykman_cli(
+            "piv",
+            "certificates",
+            "generate",
+            slot,
+            "-P",
+            DEFAULT_PIN,
+            "-s",
+            "subject-" + algo,
+            "-",
+            input=pubkey_output,
+        )
+        output = ykman_cli("piv", "certificates", "export", slot, "-").output
+        cert = x509.load_pem_x509_certificate(output.encode(), default_backend())
+        _verify_cert(cert, cert.public_key())
+        fingerprint = b2a_hex(cert.fingerprint(hashes.SHA256())).decode("ascii")
+
+        output = ykman_cli("piv", "info").output
+        assert fingerprint in output
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9a_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9a", "RSA1024")
+
+    def test_generate_self_signed_slot_9a_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9a", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9c_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9c", "RSA1024")
+
+    def test_generate_self_signed_slot_9c_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9c", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9d_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9d", "RSA1024")
+
+    def test_generate_self_signed_slot_9d_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9d", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_self_signed_slot_9e_rsa1024(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9e", "RSA1024")
+
+    def test_generate_self_signed_slot_9e_eccp256(self, ykman_cli):
+        self._test_generate_self_signed(ykman_cli, "9e", "ECCP256")
+
+    def _test_generate_csr(self, ykman_cli, slot, algo):
+        subject_input = "subject-" + algo
+        pubkey_output = ykman_cli(
+            "piv", "keys", "generate", slot, "-a", algo, "-P", DEFAULT_PIN, "-"
+        ).output
+        csr_output = ykman_cli(
+            "piv",
+            "certificates",
+            "request",
+            slot,
+            "-P",
+            DEFAULT_PIN,
+            "-",
+            "-",
+            "-s",
+            subject_input,
+            input=pubkey_output,
+        ).output
+        csr = x509.load_pem_x509_csr(csr_output.encode("utf-8"), default_backend())
+        subject_output = csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[
+            0
+        ].value
+
+        assert subject_input == subject_output
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9a_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9a", "RSA1024")
+
+    def test_generate_csr_slot_9a_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9a", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9c_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9c", "RSA1024")
+
+    def test_generate_csr_slot_9c_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9c", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9d_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9d", "RSA1024")
+
+    def test_generate_csr_slot_9d_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9d", "ECCP256")
+
+    @condition.yk4_fips(False)
+    @condition.check(not_roca)
+    def test_generate_csr_slot_9e_rsa1024(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9e", "RSA1024")
+
+    def test_generate_csr_slot_9e_eccp256(self, ykman_cli):
+        self._test_generate_csr(ykman_cli, "9e", "ECCP256")
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_management_key.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_management_key.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,182 +1,182 @@
-from .util import (
-    old_new_new,
-    DEFAULT_PIN,
-    DEFAULT_MANAGEMENT_KEY,
-    NON_DEFAULT_MANAGEMENT_KEY,
-)
-import re
-import pytest
-
-
-class TestManagementKey:
-    def test_change_management_key_force_fails_without_generate(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-P",
-                DEFAULT_PIN,
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-                "-f",
-            )
-
-    def test_change_management_key_protect_random(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-p",
-            "-P",
-            DEFAULT_PIN,
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-        )
-        output = ykman_cli("piv", "info").output
-        assert "Management key is stored on the YubiKey, protected by PIN" in output
-
-        with pytest.raises(SystemExit):
-            # Should fail - wrong current key
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-p",
-                "-P",
-                DEFAULT_PIN,
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-            )
-
-        # Should succeed - PIN as key
-        ykman_cli("piv", "access", "change-management-key", "-p", "-P", DEFAULT_PIN)
-
-    def test_change_management_key_protect_prompt(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-p",
-            "-P",
-            DEFAULT_PIN,
-            input=DEFAULT_MANAGEMENT_KEY,
-        )
-        output = ykman_cli("piv", "info").output
-        assert "Management key is stored on the YubiKey, protected by PIN" in output
-
-        with pytest.raises(SystemExit):
-            # Should fail - wrong current key
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-p",
-                "-P",
-                DEFAULT_PIN,
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-            )
-
-        # Should succeed - PIN as key
-        ykman_cli("piv", "access", "change-management-key", "-p", "-P", DEFAULT_PIN)
-
-    def test_change_management_key_no_protect_generate(self, ykman_cli):
-        output = ykman_cli(
-            "piv", "access", "change-management-key", "-m", DEFAULT_MANAGEMENT_KEY, "-g"
-        ).output
-
-        assert re.match(
-            r"^Generated management key: [a-f0-9]{48}$", output, re.MULTILINE
-        )
-
-        output = ykman_cli("piv", "info").output
-        assert "Management key is stored on the YubiKey" not in output
-
-    def test_change_management_key_no_protect_arg(self, ykman_cli):
-        output = ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            "-n",
-            NON_DEFAULT_MANAGEMENT_KEY,
-        ).output
-        assert "" == output
-        output = ykman_cli("piv", "info").output
-        assert "Management key is stored on the YubiKey" not in output
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-                "-n",
-                NON_DEFAULT_MANAGEMENT_KEY,
-            )
-
-        output = ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            "-m",
-            NON_DEFAULT_MANAGEMENT_KEY,
-            "-n",
-            DEFAULT_MANAGEMENT_KEY,
-        ).output
-        assert "" == output
-
-    def test_change_management_key_no_protect_arg_bad_length(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-                "-n",
-                "10020304050607080102030405060708",
-            )
-
-    def test_change_management_key_no_protect_prompt(self, ykman_cli):
-        output = ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            input=old_new_new(DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY),
-        ).output
-        assert "Generated" not in output
-        output = ykman_cli("piv", "info").output
-        assert "Management key is stored on the YubiKey" not in output
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                input=old_new_new(DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY),
-            )
-
-        ykman_cli(
-            "piv",
-            "access",
-            "change-management-key",
-            input=old_new_new(NON_DEFAULT_MANAGEMENT_KEY, DEFAULT_MANAGEMENT_KEY),
-        )
-        assert "Generated" not in output
-
-    def test_change_management_key_new_key_conflicts_with_generate(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv",
-                "access",
-                "change-management-key",
-                "-m",
-                DEFAULT_MANAGEMENT_KEY,
-                "-n",
-                NON_DEFAULT_MANAGEMENT_KEY,
-                "-g",
-            )
+from .util import (
+    old_new_new,
+    DEFAULT_PIN,
+    DEFAULT_MANAGEMENT_KEY,
+    NON_DEFAULT_MANAGEMENT_KEY,
+)
+import re
+import pytest
+
+
+class TestManagementKey:
+    def test_change_management_key_force_fails_without_generate(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-P",
+                DEFAULT_PIN,
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+                "-f",
+            )
+
+    def test_change_management_key_protect_random(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-p",
+            "-P",
+            DEFAULT_PIN,
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+        )
+        output = ykman_cli("piv", "info").output
+        assert "Management key is stored on the YubiKey, protected by PIN" in output
+
+        with pytest.raises(SystemExit):
+            # Should fail - wrong current key
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-p",
+                "-P",
+                DEFAULT_PIN,
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+            )
+
+        # Should succeed - PIN as key
+        ykman_cli("piv", "access", "change-management-key", "-p", "-P", DEFAULT_PIN)
+
+    def test_change_management_key_protect_prompt(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-p",
+            "-P",
+            DEFAULT_PIN,
+            input=DEFAULT_MANAGEMENT_KEY,
+        )
+        output = ykman_cli("piv", "info").output
+        assert "Management key is stored on the YubiKey, protected by PIN" in output
+
+        with pytest.raises(SystemExit):
+            # Should fail - wrong current key
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-p",
+                "-P",
+                DEFAULT_PIN,
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+            )
+
+        # Should succeed - PIN as key
+        ykman_cli("piv", "access", "change-management-key", "-p", "-P", DEFAULT_PIN)
+
+    def test_change_management_key_no_protect_generate(self, ykman_cli):
+        output = ykman_cli(
+            "piv", "access", "change-management-key", "-m", DEFAULT_MANAGEMENT_KEY, "-g"
+        ).output
+
+        assert re.match(
+            r"^Generated management key: [a-f0-9]{48}$", output, re.MULTILINE
+        )
+
+        output = ykman_cli("piv", "info").output
+        assert "Management key is stored on the YubiKey" not in output
+
+    def test_change_management_key_no_protect_arg(self, ykman_cli):
+        output = ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            "-n",
+            NON_DEFAULT_MANAGEMENT_KEY,
+        ).output
+        assert "" == output
+        output = ykman_cli("piv", "info").output
+        assert "Management key is stored on the YubiKey" not in output
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+                "-n",
+                NON_DEFAULT_MANAGEMENT_KEY,
+            )
+
+        output = ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            "-m",
+            NON_DEFAULT_MANAGEMENT_KEY,
+            "-n",
+            DEFAULT_MANAGEMENT_KEY,
+        ).output
+        assert "" == output
+
+    def test_change_management_key_no_protect_arg_bad_length(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+                "-n",
+                "10020304050607080102030405060708",
+            )
+
+    def test_change_management_key_no_protect_prompt(self, ykman_cli):
+        output = ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            input=old_new_new(DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY),
+        ).output
+        assert "Generated" not in output
+        output = ykman_cli("piv", "info").output
+        assert "Management key is stored on the YubiKey" not in output
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                input=old_new_new(DEFAULT_MANAGEMENT_KEY, NON_DEFAULT_MANAGEMENT_KEY),
+            )
+
+        ykman_cli(
+            "piv",
+            "access",
+            "change-management-key",
+            input=old_new_new(NON_DEFAULT_MANAGEMENT_KEY, DEFAULT_MANAGEMENT_KEY),
+        )
+        assert "Generated" not in output
+
+    def test_change_management_key_new_key_conflicts_with_generate(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv",
+                "access",
+                "change-management-key",
+                "-m",
+                DEFAULT_MANAGEMENT_KEY,
+                "-n",
+                NON_DEFAULT_MANAGEMENT_KEY,
+                "-g",
+            )
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_misc.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_misc.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,48 +1,48 @@
-from yubikit.piv import OBJECT_ID
-import pytest
-
-
-DEFAULT_MANAGEMENT_KEY = "010203040506070801020304050607080102030405060708"
-
-
-class TestMisc:
-    def setUp(self, ykman_cli):
-        ykman_cli("piv", "reset", "-f")
-
-    def test_info(self, ykman_cli):
-        output = ykman_cli("piv", "info").output
-        assert "PIV version:" in output
-
-    def test_reset(self, ykman_cli):
-        output = ykman_cli("piv", "reset", "-f").output
-        assert "Success!" in output
-
-    def test_export_invalid_certificate_fails(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            hex(OBJECT_ID.AUTHENTICATION),
-            "-",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            input="This is not a cert",
-        )
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv", "certificates", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
-            )
-
-    def test_info_with_invalid_certificate_does_not_crash(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            hex(OBJECT_ID.AUTHENTICATION),
-            "-",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            input="This is not a cert",
-        )
-        ykman_cli("piv", "info")
+from yubikit.piv import OBJECT_ID
+import pytest
+
+
+DEFAULT_MANAGEMENT_KEY = "010203040506070801020304050607080102030405060708"
+
+
+class TestMisc:
+    def setUp(self, ykman_cli):
+        ykman_cli("piv", "reset", "-f")
+
+    def test_info(self, ykman_cli):
+        output = ykman_cli("piv", "info").output
+        assert "PIV version:" in output
+
+    def test_reset(self, ykman_cli):
+        output = ykman_cli("piv", "reset", "-f").output
+        assert "Success!" in output
+
+    def test_export_invalid_certificate_fails(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            hex(OBJECT_ID.AUTHENTICATION),
+            "-",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            input="This is not a cert",
+        )
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv", "certificates", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
+            )
+
+    def test_info_with_invalid_certificate_does_not_crash(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            hex(OBJECT_ID.AUTHENTICATION),
+            "-",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            input="This is not a cert",
+        )
+        ykman_cli("piv", "info")
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_pin_puk.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_pin_puk.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,65 +1,65 @@
-from .util import (
-    old_new_new,
-    DEFAULT_PIN,
-    NON_DEFAULT_PIN,
-    DEFAULT_PUK,
-    NON_DEFAULT_PUK,
-)
-
-import pytest
-
-
-class TestPin:
-    def test_change_pin(self, ykman_cli):
-        ykman_cli(
-            "piv", "access", "change-pin", "-P", DEFAULT_PIN, "-n", NON_DEFAULT_PIN
-        )
-        ykman_cli(
-            "piv", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
-        )
-
-    def test_change_pin_prompt(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-pin",
-            input=old_new_new(DEFAULT_PIN, NON_DEFAULT_PIN),
-        )
-        ykman_cli(
-            "piv",
-            "access",
-            "change-pin",
-            input=old_new_new(NON_DEFAULT_PIN, DEFAULT_PIN),
-        )
-
-
-class TestPuk:
-    def test_change_puk(self, ykman_cli):
-        o1 = ykman_cli(
-            "piv", "access", "change-puk", "-p", DEFAULT_PUK, "-n", NON_DEFAULT_PUK
-        ).output
-        assert "New PUK set." in o1
-
-        o2 = ykman_cli(
-            "piv", "access", "change-puk", "-p", NON_DEFAULT_PUK, "-n", DEFAULT_PUK
-        ).output
-        assert "New PUK set." in o2
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "piv", "access", "change-puk", "-p", NON_DEFAULT_PUK, "-n", DEFAULT_PUK
-            )
-
-    def test_change_puk_prompt(self, ykman_cli):
-        ykman_cli(
-            "piv",
-            "access",
-            "change-puk",
-            input=old_new_new(DEFAULT_PUK, NON_DEFAULT_PUK),
-        )
-        ykman_cli(
-            "piv",
-            "access",
-            "change-puk",
-            input=old_new_new(NON_DEFAULT_PUK, DEFAULT_PUK),
-        )
+from .util import (
+    old_new_new,
+    DEFAULT_PIN,
+    NON_DEFAULT_PIN,
+    DEFAULT_PUK,
+    NON_DEFAULT_PUK,
+)
+
+import pytest
+
+
+class TestPin:
+    def test_change_pin(self, ykman_cli):
+        ykman_cli(
+            "piv", "access", "change-pin", "-P", DEFAULT_PIN, "-n", NON_DEFAULT_PIN
+        )
+        ykman_cli(
+            "piv", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
+        )
+
+    def test_change_pin_prompt(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-pin",
+            input=old_new_new(DEFAULT_PIN, NON_DEFAULT_PIN),
+        )
+        ykman_cli(
+            "piv",
+            "access",
+            "change-pin",
+            input=old_new_new(NON_DEFAULT_PIN, DEFAULT_PIN),
+        )
+
+
+class TestPuk:
+    def test_change_puk(self, ykman_cli):
+        o1 = ykman_cli(
+            "piv", "access", "change-puk", "-p", DEFAULT_PUK, "-n", NON_DEFAULT_PUK
+        ).output
+        assert "New PUK set." in o1
+
+        o2 = ykman_cli(
+            "piv", "access", "change-puk", "-p", NON_DEFAULT_PUK, "-n", DEFAULT_PUK
+        ).output
+        assert "New PUK set." in o2
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "piv", "access", "change-puk", "-p", NON_DEFAULT_PUK, "-n", DEFAULT_PUK
+            )
+
+    def test_change_puk_prompt(self, ykman_cli):
+        ykman_cli(
+            "piv",
+            "access",
+            "change-puk",
+            input=old_new_new(DEFAULT_PUK, NON_DEFAULT_PUK),
+        )
+        ykman_cli(
+            "piv",
+            "access",
+            "change-puk",
+            input=old_new_new(NON_DEFAULT_PUK, DEFAULT_PUK),
+        )
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/piv/test_read_write_object.py` & `yubikey_manager-5.1.1/tests/device/cli/piv/test_read_write_object.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,114 +1,114 @@
-import os
-
-from cryptography.hazmat.primitives import serialization
-from ....util import generate_self_signed_certificate
-from yubikit.core import Tlv
-from yubikit.piv import OBJECT_ID, SLOT
-import pytest
-
-
-DEFAULT_MANAGEMENT_KEY = "010203040506070801020304050607080102030405060708"
-
-
-class TestReadWriteObject:
-    def test_write_read_preserves_ansi_escapes(self, ykman_cli):
-        red = b"\x00\x1b[31m"
-        blue = b"\x00\x1b[34m"
-        reset = b"\x00\x1b[0m"
-        data = (
-            b"Hello, "
-            + red
-            + b"red"
-            + reset
-            + b" and "
-            + blue
-            + b"blue"
-            + reset
-            + b" world!"
-        )
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            "0x5f0001",
-            "-",
-            input=data,
-        )
-        output_data = ykman_cli(
-            "piv", "objects", "export", "0x5f0001", "-"
-        ).stdout_bytes
-        assert data == output_data
-
-    def test_read_write_read_is_noop(self, ykman_cli):
-        data = os.urandom(32)
-
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            hex(OBJECT_ID.AUTHENTICATION),
-            "-",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            input=data,
-        )
-
-        output1 = ykman_cli(
-            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
-        ).stdout_bytes
-        assert output1 == data
-
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            hex(OBJECT_ID.AUTHENTICATION),
-            "-",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            input=output1,
-        )
-
-        output2 = ykman_cli(
-            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
-        ).stdout_bytes
-        assert output2 == data
-
-    def test_read_write_certificate_as_object(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-")
-
-        cert = generate_self_signed_certificate()
-        cert_bytes_der = cert.public_bytes(encoding=serialization.Encoding.DER)
-
-        input_tlv = Tlv(0x70, cert_bytes_der) + Tlv(0x71, b"\0") + Tlv(0xFE, b"")
-
-        ykman_cli(
-            "piv",
-            "objects",
-            "import",
-            hex(OBJECT_ID.AUTHENTICATION),
-            "-",
-            "-m",
-            DEFAULT_MANAGEMENT_KEY,
-            input=input_tlv,
-        )
-
-        output1 = ykman_cli(
-            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
-        ).stdout_bytes
-        output_cert_bytes = Tlv.parse_dict(output1)[0x70]
-        assert output_cert_bytes == cert_bytes_der
-
-        output2 = ykman_cli(
-            "piv",
-            "certificates",
-            "export",
-            hex(SLOT.AUTHENTICATION),
-            "-",
-            "--format",
-            "DER",
-        ).stdout_bytes
-        assert output2 == cert_bytes_der
+import os
+
+from cryptography.hazmat.primitives import serialization
+from ....util import generate_self_signed_certificate
+from yubikit.core import Tlv
+from yubikit.piv import OBJECT_ID, SLOT
+import pytest
+
+
+DEFAULT_MANAGEMENT_KEY = "010203040506070801020304050607080102030405060708"
+
+
+class TestReadWriteObject:
+    def test_write_read_preserves_ansi_escapes(self, ykman_cli):
+        red = b"\x00\x1b[31m"
+        blue = b"\x00\x1b[34m"
+        reset = b"\x00\x1b[0m"
+        data = (
+            b"Hello, "
+            + red
+            + b"red"
+            + reset
+            + b" and "
+            + blue
+            + b"blue"
+            + reset
+            + b" world!"
+        )
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            "0x5f0001",
+            "-",
+            input=data,
+        )
+        output_data = ykman_cli(
+            "piv", "objects", "export", "0x5f0001", "-"
+        ).stdout_bytes
+        assert data == output_data
+
+    def test_read_write_read_is_noop(self, ykman_cli):
+        data = os.urandom(32)
+
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            hex(OBJECT_ID.AUTHENTICATION),
+            "-",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            input=data,
+        )
+
+        output1 = ykman_cli(
+            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
+        ).stdout_bytes
+        assert output1 == data
+
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            hex(OBJECT_ID.AUTHENTICATION),
+            "-",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            input=output1,
+        )
+
+        output2 = ykman_cli(
+            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
+        ).stdout_bytes
+        assert output2 == data
+
+    def test_read_write_certificate_as_object(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-")
+
+        cert = generate_self_signed_certificate()
+        cert_bytes_der = cert.public_bytes(encoding=serialization.Encoding.DER)
+
+        input_tlv = Tlv(0x70, cert_bytes_der) + Tlv(0x71, b"\0") + Tlv(0xFE, b"")
+
+        ykman_cli(
+            "piv",
+            "objects",
+            "import",
+            hex(OBJECT_ID.AUTHENTICATION),
+            "-",
+            "-m",
+            DEFAULT_MANAGEMENT_KEY,
+            input=input_tlv,
+        )
+
+        output1 = ykman_cli(
+            "piv", "objects", "export", hex(OBJECT_ID.AUTHENTICATION), "-"
+        ).stdout_bytes
+        output_cert_bytes = Tlv.parse_dict(output1)[0x70]
+        assert output_cert_bytes == cert_bytes_der
+
+        output2 = ykman_cli(
+            "piv",
+            "certificates",
+            "export",
+            hex(SLOT.AUTHENTICATION),
+            "-",
+            "--format",
+            "DER",
+        ).stdout_bytes
+        assert output2 == cert_bytes_der
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/test_misc.py` & `yubikey_manager-5.1.1/tests/device/cli/test_misc.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-from .. import condition
-import pytest
-
-
-class TestYkmanInfo:
-    def test_ykman_info(self, ykman_cli, info):
-        output = ykman_cli("info").output
-        assert "Device type:" in output
-        if info.serial is not None:
-            assert "Serial number:" in output
-        assert "Firmware version:" in output
-
-    @condition.yk4_fips(False)
-    def test_ykman_info_does_not_report_fips_for_non_fips_device(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("info", "--check-fips")
-
-    @condition.yk4_fips(True)
-    def test_ykman_info_reports_fips_status(self, ykman_cli):
-        info = ykman_cli("info", "--check-fips").output
-        assert "FIPS Approved Mode:" in info
-        assert "  FIDO U2F:" in info
-        assert "  OATH:" in info
-        assert "  OTP:" in info
+from .. import condition
+import pytest
+
+
+class TestYkmanInfo:
+    def test_ykman_info(self, ykman_cli, info):
+        output = ykman_cli("info").output
+        assert "Device type:" in output
+        if info.serial is not None:
+            assert "Serial number:" in output
+        assert "Firmware version:" in output
+
+    @condition.yk4_fips(False)
+    def test_ykman_info_does_not_report_fips_for_non_fips_device(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("info", "--check-fips")
+
+    @condition.yk4_fips(True)
+    def test_ykman_info_reports_fips_status(self, ykman_cli):
+        info = ykman_cli("info", "--check-fips").output
+        assert "FIPS Approved Mode:" in info
+        assert "  FIDO U2F:" in info
+        assert "  OATH:" in info
+        assert "  OTP:" in info
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/test_oath.py` & `yubikey_manager-5.1.1/tests/device/cli/test_oath.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,287 +1,287 @@
-# -*- coding: utf-8 -*-
-
-from ykman.oath import STEAM_CHAR_TABLE
-from yubikit.management import CAPABILITY
-from .. import condition
-from base64 import b32encode
-import pytest
-
-
-URI_HOTP_EXAMPLE = (
-    "otpauth://hotp/Example:demo@example.com?"
-    "secret=JBSWY3DPK5XXE3DEJ5TE6QKUJA======&issuer=Example&counter=1"
-)
-
-URI_TOTP_EXAMPLE = (
-    "otpauth://totp/ACME%20Co:john.doe@email.com?"
-    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
-    "&algorithm=SHA1&digits=6&period=30"
-)
-
-URI_TOTP_EXAMPLE_B = (
-    "otpauth://totp/ACME%20Co:john.doe.b@email.com?"
-    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
-    "&algorithm=SHA1&digits=6&period=30"
-)
-
-URI_TOTP_EXAMPLE_EXTRA_PARAMETER = (
-    "otpauth://totp/ACME%20Co:john.doe.extra@email.com?"
-    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
-    "&algorithm=SHA1&digits=6&period=30&skid=JKS3424d"
-)
-
-PASSWORD = "aaaa"
-
-
-@pytest.fixture(autouse=True)
-@condition.capability(CAPABILITY.OATH)
-def preconditions(ykman_cli):
-    ykman_cli("oath", "reset", "-f")
-
-
-class TestOATH:
-    def test_oath_info(self, ykman_cli):
-        output = ykman_cli("oath", "info").output
-        assert "version:" in output
-
-    @condition.yk4_fips(False)
-    def test_info_does_not_indicate_fips_mode_for_non_fips_key(self, ykman_cli):
-        info = ykman_cli("oath", "info").output
-        assert "FIPS:" not in info
-
-    def test_oath_add_credential(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "test-name", "abba")
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "test-name" in creds
-
-    def test_oath_add_credential_prompt(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "test-name-2", input="abba")
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "test-name-2" in creds
-
-    def test_oath_add_credential_with_space(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "test-name-space", "ab ba")
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "test-name-space" in creds
-
-    def test_oath_hidden_cred(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "_hidden:name", "abba")
-        creds = ykman_cli("oath", "accounts", "code").output
-        assert "_hidden:name" not in creds
-        creds = ykman_cli("oath", "accounts", "code", "-H").output
-        assert "_hidden:name" in creds
-
-    def test_oath_add_uri_hotp(self, ykman_cli):
-        ykman_cli("oath", "accounts", "uri", URI_HOTP_EXAMPLE)
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "Example:demo" in creds
-
-    def test_oath_add_uri_totp(self, ykman_cli):
-        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE)
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "john.doe" in creds
-
-    def test_oath_add_uri_totp_extra_parameter(self, ykman_cli):
-        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE_EXTRA_PARAMETER)
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "john.doe.extra" in creds
-
-    def test_oath_add_uri_totp_prompt(self, ykman_cli):
-        ykman_cli("oath", "accounts", "uri", input=URI_TOTP_EXAMPLE_B)
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "john.doe" in creds
-
-    def test_oath_code(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "test-name2", "abba")
-        creds = ykman_cli("oath", "accounts", "code").output
-        assert "test-name2" in creds
-
-    def test_oath_code_query_single(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "query-me", "abba")
-        creds = ykman_cli("oath", "accounts", "code", "query-me").output
-        assert "query-me" in creds
-
-    def test_oath_code_query_multiple(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "foo", "abba")
-        ykman_cli("oath", "accounts", "add", "query-me", "abba")
-        ykman_cli("oath", "accounts", "add", "bar", "abba")
-        lines = (
-            ykman_cli("oath", "accounts", "code", "query").output.strip().splitlines()
-        )
-        assert len(lines) == 1
-        assert "query-me" in lines[0]
-
-    def test_oath_reset(self, ykman_cli):
-        output = ykman_cli("oath", "reset", "-f").output
-        assert "Success! All OATH accounts have been deleted from the YubiKey" in output
-
-    def test_oath_hotp_vectors_6(self, ykman_cli):
-        ykman_cli(
-            "oath",
-            "accounts",
-            "add",
-            "-o",
-            "HOTP",
-            "testvector",
-            b32encode(b"12345678901234567890").decode(),
-        )
-        for code in ["755224", "287082", "359152", "969429", "338314"]:
-            words = ykman_cli("oath", "accounts", "code", "testvector").output.split()
-            assert code in words
-
-    def test_oath_hotp_vectors_8(self, ykman_cli):
-        ykman_cli(
-            "oath",
-            "accounts",
-            "add",
-            "-o",
-            "HOTP",
-            "-d",
-            "8",
-            "testvector8",
-            b32encode(b"12345678901234567890").decode(),
-        )
-        for code in ["84755224", "94287082", "37359152", "26969429", "40338314"]:
-            words = ykman_cli("oath", "accounts", "code", "testvector8").output.split()
-            assert code in words
-
-    def test_oath_hotp_code(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "hotp-cred", "abba")
-        words = ykman_cli("oath", "accounts", "code", "hotp-cred").output.split()
-        assert "659165" in words
-
-    def test_oath_hotp_code_single(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "hotp-cred", "abba")
-        words = ykman_cli(
-            "oath", "accounts", "code", "hotp-cred", "--single"
-        ).output.split()
-        assert "659165" in words
-
-    def test_oath_totp_steam_code(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "Steam:steam-cred", "abba")
-        cred = ykman_cli("oath", "accounts", "code", "steam-cred").output.strip()
-        code = cred.split()[-1]
-        assert 5 == len(code), f"cred wrong length: {code!r}"
-        assert all(
-            c in STEAM_CHAR_TABLE for c in code
-        ), f"{code!r} contains non-steam characters"
-
-    def test_oath_totp_steam_code_single(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "Steam:steam-cred", "abba")
-        code = ykman_cli("oath", "accounts", "code", "-s", "steam-cred").output.strip()
-        assert 5 == len(code), f"cred wrong length: {code!r}"
-        assert all(
-            c in STEAM_CHAR_TABLE for c in code
-        ), f"{code!r} contains non-steam characters"
-
-    def test_oath_code_output_no_touch(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "TOTP:normal", "aaaa")
-        ykman_cli("oath", "accounts", "add", "Steam:normal", "aaba")
-        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "HOTP:normal", "abaa")
-
-        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
-        entries = {line.split()[0]: line for line in lines}
-        assert "HOTP Account" in entries["HOTP:normal"]
-
-        code = entries["Steam:normal"].split()[-1]
-        assert 5 == len(code), f"cred wrong length: {code!r}"
-        assert all(
-            c in STEAM_CHAR_TABLE for c in code
-        ), f"{code!r} contains non-steam characters"
-
-        code = entries["TOTP:normal"].split()[-1]
-        assert 6 == len(code)
-        int(code)
-
-    @condition.min_version(4)
-    def test_oath_code_output(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "TOTP:normal", "aaaa")
-        ykman_cli("oath", "accounts", "add", "--touch", "TOTP:touch", "aaab")
-        ykman_cli("oath", "accounts", "add", "Steam:normal", "aaba")
-        ykman_cli("oath", "accounts", "add", "--touch", "Steam:touch", "aabb")
-        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "HOTP:normal", "abaa")
-
-        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
-        entries = {line.split()[0]: line for line in lines}
-        assert "Requires Touch" in entries["TOTP:touch"]
-        assert "Requires Touch" in entries["Steam:touch"]
-        assert "HOTP Account" in entries["HOTP:normal"]
-
-        code = entries["Steam:normal"].split()[-1]
-        assert 5 == len(code), f"cred wrong length: {code!r}"
-        assert all(
-            c in STEAM_CHAR_TABLE for c in code
-        ), f"{code!r} contains non-steam characters"
-
-        code = entries["TOTP:normal"].split()[-1]
-        assert 6 == len(code)
-        int(code)
-
-    @condition.min_version(4)
-    def test_oath_totp_steam_touch_not_in_code_output(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "--touch", "Steam:steam-cred", "abba")
-        ykman_cli("oath", "accounts", "add", "TOTP:totp-cred", "abba")
-        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
-        assert "Requires Touch" in lines[0]
-
-    def test_oath_delete(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "delete-me", "abba")
-        ykman_cli("oath", "accounts", "delete", "delete-me", "-f")
-        assert "delete-me", ykman_cli("oath", "accounts" not in "list")
-
-    def test_oath_unicode(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "", "abba")
-        ykman_cli("oath", "accounts", "code")
-        ykman_cli("oath", "accounts", "list")
-        ykman_cli("oath", "accounts", "delete", "", "-f")
-
-    @condition.yk4_fips(False)
-    @condition.min_version(4, 3, 1)
-    def test_oath_sha512(self, ykman_cli):
-        ykman_cli("oath", "accounts", "add", "abba", "abba", "--algorithm", "SHA512")
-        ykman_cli("oath", "accounts", "delete", "abba", "-f")
-
-    # NEO credential capacity may vary based on configuration
-    @condition.min_version(4)
-    def test_add_32_creds(self, ykman_cli):
-        for i in range(32):
-            ykman_cli("oath", "accounts", "add", "test" + str(i), "abba")
-            output = ykman_cli("oath", "accounts", "list").output
-            lines = output.strip().split("\n")
-            assert len(lines) == i + 1
-
-        with pytest.raises(SystemExit):
-            ykman_cli("oath", "accounts", "add", "testx", "abba")
-
-    @condition.min_version(5, 3, 1)
-    def test_rename(self, ykman_cli):
-        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE)
-        ykman_cli(
-            "oath", "accounts", "rename", "john.doe", "Example:user@example.com", "-f"
-        )
-
-        creds = ykman_cli("oath", "accounts", "list").output
-        assert "john.doe" not in creds
-        assert "Example:user@example.com" in creds
-
-
-class TestOathFips:
-    @pytest.fixture(autouse=True)
-    @condition.yk4_fips(True)
-    def check_fips(self):
-        pass
-
-    def test_no_fips_mode_without_password(self, ykman_cli):
-        output = ykman_cli("oath", "info").output
-        assert "FIPS Approved Mode: No" in output
-
-    def test_fips_mode_with_password(self, ykman_cli):
-        ykman_cli("oath", "access", "change", "-n", PASSWORD)
-        output = ykman_cli("oath", "info").output
-        assert "FIPS Approved Mode: Yes" in output
-
-    def test_sha512_not_supported(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "oath", "accounts", "add", "abba", "abba", "--algorithm", "SHA512"
-            )
+# -*- coding: utf-8 -*-
+
+from ykman.oath import STEAM_CHAR_TABLE
+from yubikit.management import CAPABILITY
+from .. import condition
+from base64 import b32encode
+import pytest
+
+
+URI_HOTP_EXAMPLE = (
+    "otpauth://hotp/Example:demo@example.com?"
+    "secret=JBSWY3DPK5XXE3DEJ5TE6QKUJA======&issuer=Example&counter=1"
+)
+
+URI_TOTP_EXAMPLE = (
+    "otpauth://totp/ACME%20Co:john.doe@email.com?"
+    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
+    "&algorithm=SHA1&digits=6&period=30"
+)
+
+URI_TOTP_EXAMPLE_B = (
+    "otpauth://totp/ACME%20Co:john.doe.b@email.com?"
+    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
+    "&algorithm=SHA1&digits=6&period=30"
+)
+
+URI_TOTP_EXAMPLE_EXTRA_PARAMETER = (
+    "otpauth://totp/ACME%20Co:john.doe.extra@email.com?"
+    "secret=HXDMVJECJJWSRB3HWIZR4IFUGFTMXBOZ&issuer=ACME%20Co"
+    "&algorithm=SHA1&digits=6&period=30&skid=JKS3424d"
+)
+
+PASSWORD = "aaaa"
+
+
+@pytest.fixture(autouse=True)
+@condition.capability(CAPABILITY.OATH)
+def preconditions(ykman_cli):
+    ykman_cli("oath", "reset", "-f")
+
+
+class TestOATH:
+    def test_oath_info(self, ykman_cli):
+        output = ykman_cli("oath", "info").output
+        assert "version:" in output
+
+    @condition.yk4_fips(False)
+    def test_info_does_not_indicate_fips_mode_for_non_fips_key(self, ykman_cli):
+        info = ykman_cli("oath", "info").output
+        assert "FIPS:" not in info
+
+    def test_oath_add_credential(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "test-name", "abba")
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "test-name" in creds
+
+    def test_oath_add_credential_prompt(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "test-name-2", input="abba")
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "test-name-2" in creds
+
+    def test_oath_add_credential_with_space(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "test-name-space", "ab ba")
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "test-name-space" in creds
+
+    def test_oath_hidden_cred(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "_hidden:name", "abba")
+        creds = ykman_cli("oath", "accounts", "code").output
+        assert "_hidden:name" not in creds
+        creds = ykman_cli("oath", "accounts", "code", "-H").output
+        assert "_hidden:name" in creds
+
+    def test_oath_add_uri_hotp(self, ykman_cli):
+        ykman_cli("oath", "accounts", "uri", URI_HOTP_EXAMPLE)
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "Example:demo" in creds
+
+    def test_oath_add_uri_totp(self, ykman_cli):
+        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE)
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "john.doe" in creds
+
+    def test_oath_add_uri_totp_extra_parameter(self, ykman_cli):
+        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE_EXTRA_PARAMETER)
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "john.doe.extra" in creds
+
+    def test_oath_add_uri_totp_prompt(self, ykman_cli):
+        ykman_cli("oath", "accounts", "uri", input=URI_TOTP_EXAMPLE_B)
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "john.doe" in creds
+
+    def test_oath_code(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "test-name2", "abba")
+        creds = ykman_cli("oath", "accounts", "code").output
+        assert "test-name2" in creds
+
+    def test_oath_code_query_single(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "query-me", "abba")
+        creds = ykman_cli("oath", "accounts", "code", "query-me").output
+        assert "query-me" in creds
+
+    def test_oath_code_query_multiple(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "foo", "abba")
+        ykman_cli("oath", "accounts", "add", "query-me", "abba")
+        ykman_cli("oath", "accounts", "add", "bar", "abba")
+        lines = (
+            ykman_cli("oath", "accounts", "code", "query").output.strip().splitlines()
+        )
+        assert len(lines) == 1
+        assert "query-me" in lines[0]
+
+    def test_oath_reset(self, ykman_cli):
+        output = ykman_cli("oath", "reset", "-f").output
+        assert "Success! All OATH accounts have been deleted from the YubiKey" in output
+
+    def test_oath_hotp_vectors_6(self, ykman_cli):
+        ykman_cli(
+            "oath",
+            "accounts",
+            "add",
+            "-o",
+            "HOTP",
+            "testvector",
+            b32encode(b"12345678901234567890").decode(),
+        )
+        for code in ["755224", "287082", "359152", "969429", "338314"]:
+            words = ykman_cli("oath", "accounts", "code", "testvector").output.split()
+            assert code in words
+
+    def test_oath_hotp_vectors_8(self, ykman_cli):
+        ykman_cli(
+            "oath",
+            "accounts",
+            "add",
+            "-o",
+            "HOTP",
+            "-d",
+            "8",
+            "testvector8",
+            b32encode(b"12345678901234567890").decode(),
+        )
+        for code in ["84755224", "94287082", "37359152", "26969429", "40338314"]:
+            words = ykman_cli("oath", "accounts", "code", "testvector8").output.split()
+            assert code in words
+
+    def test_oath_hotp_code(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "hotp-cred", "abba")
+        words = ykman_cli("oath", "accounts", "code", "hotp-cred").output.split()
+        assert "659165" in words
+
+    def test_oath_hotp_code_single(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "hotp-cred", "abba")
+        words = ykman_cli(
+            "oath", "accounts", "code", "hotp-cred", "--single"
+        ).output.split()
+        assert "659165" in words
+
+    def test_oath_totp_steam_code(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "Steam:steam-cred", "abba")
+        cred = ykman_cli("oath", "accounts", "code", "steam-cred").output.strip()
+        code = cred.split()[-1]
+        assert 5 == len(code), f"cred wrong length: {code!r}"
+        assert all(
+            c in STEAM_CHAR_TABLE for c in code
+        ), f"{code!r} contains non-steam characters"
+
+    def test_oath_totp_steam_code_single(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "Steam:steam-cred", "abba")
+        code = ykman_cli("oath", "accounts", "code", "-s", "steam-cred").output.strip()
+        assert 5 == len(code), f"cred wrong length: {code!r}"
+        assert all(
+            c in STEAM_CHAR_TABLE for c in code
+        ), f"{code!r} contains non-steam characters"
+
+    def test_oath_code_output_no_touch(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "TOTP:normal", "aaaa")
+        ykman_cli("oath", "accounts", "add", "Steam:normal", "aaba")
+        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "HOTP:normal", "abaa")
+
+        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
+        entries = {line.split()[0]: line for line in lines}
+        assert "HOTP Account" in entries["HOTP:normal"]
+
+        code = entries["Steam:normal"].split()[-1]
+        assert 5 == len(code), f"cred wrong length: {code!r}"
+        assert all(
+            c in STEAM_CHAR_TABLE for c in code
+        ), f"{code!r} contains non-steam characters"
+
+        code = entries["TOTP:normal"].split()[-1]
+        assert 6 == len(code)
+        int(code)
+
+    @condition.min_version(4)
+    def test_oath_code_output(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "TOTP:normal", "aaaa")
+        ykman_cli("oath", "accounts", "add", "--touch", "TOTP:touch", "aaab")
+        ykman_cli("oath", "accounts", "add", "Steam:normal", "aaba")
+        ykman_cli("oath", "accounts", "add", "--touch", "Steam:touch", "aabb")
+        ykman_cli("oath", "accounts", "add", "-o", "HOTP", "HOTP:normal", "abaa")
+
+        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
+        entries = {line.split()[0]: line for line in lines}
+        assert "Requires Touch" in entries["TOTP:touch"]
+        assert "Requires Touch" in entries["Steam:touch"]
+        assert "HOTP Account" in entries["HOTP:normal"]
+
+        code = entries["Steam:normal"].split()[-1]
+        assert 5 == len(code), f"cred wrong length: {code!r}"
+        assert all(
+            c in STEAM_CHAR_TABLE for c in code
+        ), f"{code!r} contains non-steam characters"
+
+        code = entries["TOTP:normal"].split()[-1]
+        assert 6 == len(code)
+        int(code)
+
+    @condition.min_version(4)
+    def test_oath_totp_steam_touch_not_in_code_output(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "--touch", "Steam:steam-cred", "abba")
+        ykman_cli("oath", "accounts", "add", "TOTP:totp-cred", "abba")
+        lines = ykman_cli("oath", "accounts", "code").output.strip().splitlines()
+        assert "Requires Touch" in lines[0]
+
+    def test_oath_delete(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "delete-me", "abba")
+        ykman_cli("oath", "accounts", "delete", "delete-me", "-f")
+        assert "delete-me", ykman_cli("oath", "accounts" not in "list")
+
+    def test_oath_unicode(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "", "abba")
+        ykman_cli("oath", "accounts", "code")
+        ykman_cli("oath", "accounts", "list")
+        ykman_cli("oath", "accounts", "delete", "", "-f")
+
+    @condition.yk4_fips(False)
+    @condition.min_version(4, 3, 1)
+    def test_oath_sha512(self, ykman_cli):
+        ykman_cli("oath", "accounts", "add", "abba", "abba", "--algorithm", "SHA512")
+        ykman_cli("oath", "accounts", "delete", "abba", "-f")
+
+    # NEO credential capacity may vary based on configuration
+    @condition.min_version(4)
+    def test_add_32_creds(self, ykman_cli):
+        for i in range(32):
+            ykman_cli("oath", "accounts", "add", "test" + str(i), "abba")
+            output = ykman_cli("oath", "accounts", "list").output
+            lines = output.strip().split("\n")
+            assert len(lines) == i + 1
+
+        with pytest.raises(SystemExit):
+            ykman_cli("oath", "accounts", "add", "testx", "abba")
+
+    @condition.min_version(5, 3, 1)
+    def test_rename(self, ykman_cli):
+        ykman_cli("oath", "accounts", "uri", URI_TOTP_EXAMPLE)
+        ykman_cli(
+            "oath", "accounts", "rename", "john.doe", "Example:user@example.com", "-f"
+        )
+
+        creds = ykman_cli("oath", "accounts", "list").output
+        assert "john.doe" not in creds
+        assert "Example:user@example.com" in creds
+
+
+class TestOathFips:
+    @pytest.fixture(autouse=True)
+    @condition.yk4_fips(True)
+    def check_fips(self):
+        pass
+
+    def test_no_fips_mode_without_password(self, ykman_cli):
+        output = ykman_cli("oath", "info").output
+        assert "FIPS Approved Mode: No" in output
+
+    def test_fips_mode_with_password(self, ykman_cli):
+        ykman_cli("oath", "access", "change", "-n", PASSWORD)
+        output = ykman_cli("oath", "info").output
+        assert "FIPS Approved Mode: Yes" in output
+
+    def test_sha512_not_supported(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "oath", "accounts", "add", "abba", "abba", "--algorithm", "SHA512"
+            )
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/test_openpgp.py` & `yubikey_manager-5.1.1/tests/device/cli/test_openpgp.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,211 +1,211 @@
-from yubikit.management import CAPABILITY
-from .. import condition
-import pytest
-
-DEFAULT_PIN = "123456"
-NON_DEFAULT_PIN = "654321"
-DEFAULT_ADMIN_PIN = "12345678"
-NON_DEFAULT_ADMIN_PIN = "87654321"
-
-
-def old_new_new(old, new):
-    return f"{old}\n{new}\n{new}\n"
-
-
-@pytest.fixture(autouse=True)
-@condition.capability(CAPABILITY.OPENPGP)
-def preconditions(ykman_cli):
-    ykman_cli("openpgp", "reset", "-f")
-
-
-class TestOpenPGP:
-    def test_openpgp_info(self, ykman_cli):
-        output = ykman_cli("openpgp", "info").output
-        assert "OpenPGP version:" in output
-
-    def test_openpgp_reset(self, ykman_cli):
-        output = ykman_cli("openpgp", "reset", "-f").output
-        assert "Success! All data has been cleared and default PINs are set." in output
-
-
-class TestPin:
-    def test_change_pin(self, ykman_cli):
-        ykman_cli(
-            "openpgp", "access", "change-pin", "-P", DEFAULT_PIN, "-n", NON_DEFAULT_PIN
-        )
-        ykman_cli(
-            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
-        )
-
-    def test_change_pin_prompt(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-pin",
-            input=old_new_new(DEFAULT_PIN, NON_DEFAULT_PIN),
-        )
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-pin",
-            input=old_new_new(NON_DEFAULT_PIN, DEFAULT_PIN),
-        )
-
-
-class TestAdminPin:
-    def test_change_admin_pin(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-admin-pin",
-            "-a",
-            DEFAULT_ADMIN_PIN,
-            "-n",
-            NON_DEFAULT_ADMIN_PIN,
-        )
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-admin-pin",
-            "-a",
-            NON_DEFAULT_ADMIN_PIN,
-            "-n",
-            DEFAULT_ADMIN_PIN,
-        )
-
-    def test_change_pin_prompt(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-admin-pin",
-            input=old_new_new(DEFAULT_ADMIN_PIN, NON_DEFAULT_ADMIN_PIN),
-        )
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-admin-pin",
-            input=old_new_new(NON_DEFAULT_ADMIN_PIN, DEFAULT_ADMIN_PIN),
-        )
-
-
-class TestResetPin:
-    def ensure_pin_changed(self, ykman_cli):
-        ykman_cli(
-            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
-        )
-
-    def test_set_and_use_reset_code(self, ykman_cli):
-        reset_code = "12345678"
-
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-reset-code",
-            "-a",
-            DEFAULT_ADMIN_PIN,
-            "-r",
-            reset_code,
-        )
-
-        ykman_cli(
-            "openpgp",
-            "access",
-            "unblock-pin",
-            "-r",
-            reset_code,
-            "-n",
-            NON_DEFAULT_PIN,
-        )
-
-        self.ensure_pin_changed(ykman_cli)
-
-    def test_set_and_use_reset_code_prompt(self, ykman_cli):
-        reset_code = "87654321"
-
-        ykman_cli(
-            "openpgp",
-            "access",
-            "change-reset-code",
-            input=old_new_new(DEFAULT_ADMIN_PIN, reset_code),
-        )
-
-        ykman_cli(
-            "openpgp",
-            "access",
-            "unblock-pin",
-            input=old_new_new(reset_code, NON_DEFAULT_PIN),
-        )
-
-        ykman_cli(
-            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
-        )
-
-    def test_unblock_pin_with_admin_pin(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "unblock-pin",
-            "-a",
-            DEFAULT_ADMIN_PIN,
-            "-n",
-            NON_DEFAULT_PIN,
-        )
-
-        self.ensure_pin_changed(ykman_cli)
-
-    def test_unblock_pin_with_admin_pin_prompt(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "unblock-pin",
-            "--admin-pin",
-            "-",
-            input=old_new_new(DEFAULT_ADMIN_PIN, NON_DEFAULT_PIN),
-        )
-
-        self.ensure_pin_changed(ykman_cli)
-
-
-class TestForceSignature:
-    def test_set_force_sig(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "set-signature-policy",
-            "ALWAYS",
-            "-a",
-            DEFAULT_ADMIN_PIN,
-        )
-
-        output = ykman_cli("openpgp", "info").output
-        assert "Always" in output
-
-        ykman_cli(
-            "openpgp", "access", "set-signature-policy", "ONCE", "-a", DEFAULT_ADMIN_PIN
-        )
-
-        output = ykman_cli("openpgp", "info").output
-        assert "Once" in output
-
-    def test_set_force_sig_prompt(self, ykman_cli):
-        ykman_cli(
-            "openpgp",
-            "access",
-            "set-signature-policy",
-            "ALWAYS",
-            input=DEFAULT_ADMIN_PIN,
-        )
-
-        output = ykman_cli("openpgp", "info").output
-        assert "Always" in output
-
-        ykman_cli(
-            "openpgp",
-            "access",
-            "set-signature-policy",
-            "ONCE",
-            input=DEFAULT_ADMIN_PIN,
-        )
-
-        output = ykman_cli("openpgp", "info").output
-        assert "Once" in output
+from yubikit.management import CAPABILITY
+from .. import condition
+import pytest
+
+DEFAULT_PIN = "123456"
+NON_DEFAULT_PIN = "654321"
+DEFAULT_ADMIN_PIN = "12345678"
+NON_DEFAULT_ADMIN_PIN = "87654321"
+
+
+def old_new_new(old, new):
+    return f"{old}\n{new}\n{new}\n"
+
+
+@pytest.fixture(autouse=True)
+@condition.capability(CAPABILITY.OPENPGP)
+def preconditions(ykman_cli):
+    ykman_cli("openpgp", "reset", "-f")
+
+
+class TestOpenPGP:
+    def test_openpgp_info(self, ykman_cli):
+        output = ykman_cli("openpgp", "info").output
+        assert "OpenPGP version:" in output
+
+    def test_openpgp_reset(self, ykman_cli):
+        output = ykman_cli("openpgp", "reset", "-f").output
+        assert "Success! All data has been cleared and default PINs are set." in output
+
+
+class TestPin:
+    def test_change_pin(self, ykman_cli):
+        ykman_cli(
+            "openpgp", "access", "change-pin", "-P", DEFAULT_PIN, "-n", NON_DEFAULT_PIN
+        )
+        ykman_cli(
+            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
+        )
+
+    def test_change_pin_prompt(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-pin",
+            input=old_new_new(DEFAULT_PIN, NON_DEFAULT_PIN),
+        )
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-pin",
+            input=old_new_new(NON_DEFAULT_PIN, DEFAULT_PIN),
+        )
+
+
+class TestAdminPin:
+    def test_change_admin_pin(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-admin-pin",
+            "-a",
+            DEFAULT_ADMIN_PIN,
+            "-n",
+            NON_DEFAULT_ADMIN_PIN,
+        )
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-admin-pin",
+            "-a",
+            NON_DEFAULT_ADMIN_PIN,
+            "-n",
+            DEFAULT_ADMIN_PIN,
+        )
+
+    def test_change_pin_prompt(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-admin-pin",
+            input=old_new_new(DEFAULT_ADMIN_PIN, NON_DEFAULT_ADMIN_PIN),
+        )
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-admin-pin",
+            input=old_new_new(NON_DEFAULT_ADMIN_PIN, DEFAULT_ADMIN_PIN),
+        )
+
+
+class TestResetPin:
+    def ensure_pin_changed(self, ykman_cli):
+        ykman_cli(
+            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
+        )
+
+    def test_set_and_use_reset_code(self, ykman_cli):
+        reset_code = "12345678"
+
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-reset-code",
+            "-a",
+            DEFAULT_ADMIN_PIN,
+            "-r",
+            reset_code,
+        )
+
+        ykman_cli(
+            "openpgp",
+            "access",
+            "unblock-pin",
+            "-r",
+            reset_code,
+            "-n",
+            NON_DEFAULT_PIN,
+        )
+
+        self.ensure_pin_changed(ykman_cli)
+
+    def test_set_and_use_reset_code_prompt(self, ykman_cli):
+        reset_code = "87654321"
+
+        ykman_cli(
+            "openpgp",
+            "access",
+            "change-reset-code",
+            input=old_new_new(DEFAULT_ADMIN_PIN, reset_code),
+        )
+
+        ykman_cli(
+            "openpgp",
+            "access",
+            "unblock-pin",
+            input=old_new_new(reset_code, NON_DEFAULT_PIN),
+        )
+
+        ykman_cli(
+            "openpgp", "access", "change-pin", "-P", NON_DEFAULT_PIN, "-n", DEFAULT_PIN
+        )
+
+    def test_unblock_pin_with_admin_pin(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "unblock-pin",
+            "-a",
+            DEFAULT_ADMIN_PIN,
+            "-n",
+            NON_DEFAULT_PIN,
+        )
+
+        self.ensure_pin_changed(ykman_cli)
+
+    def test_unblock_pin_with_admin_pin_prompt(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "unblock-pin",
+            "--admin-pin",
+            "-",
+            input=old_new_new(DEFAULT_ADMIN_PIN, NON_DEFAULT_PIN),
+        )
+
+        self.ensure_pin_changed(ykman_cli)
+
+
+class TestForceSignature:
+    def test_set_force_sig(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "set-signature-policy",
+            "ALWAYS",
+            "-a",
+            DEFAULT_ADMIN_PIN,
+        )
+
+        output = ykman_cli("openpgp", "info").output
+        assert "Always" in output
+
+        ykman_cli(
+            "openpgp", "access", "set-signature-policy", "ONCE", "-a", DEFAULT_ADMIN_PIN
+        )
+
+        output = ykman_cli("openpgp", "info").output
+        assert "Once" in output
+
+    def test_set_force_sig_prompt(self, ykman_cli):
+        ykman_cli(
+            "openpgp",
+            "access",
+            "set-signature-policy",
+            "ALWAYS",
+            input=DEFAULT_ADMIN_PIN,
+        )
+
+        output = ykman_cli("openpgp", "info").output
+        assert "Always" in output
+
+        ykman_cli(
+            "openpgp",
+            "access",
+            "set-signature-policy",
+            "ONCE",
+            input=DEFAULT_ADMIN_PIN,
+        )
+
+        output = ykman_cli("openpgp", "info").output
+        assert "Once" in output
```

### Comparing `yubikey_manager-5.1.0/tests/device/cli/test_otp.py` & `yubikey_manager-5.1.1/tests/device/cli/test_otp.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,668 +1,668 @@
-#  vim: set fileencoding=utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.management import CAPABILITY
-from .. import condition
-from time import sleep
-
-import re
-import pytest
-
-
-@pytest.fixture(autouse=True)
-@condition.capability(CAPABILITY.OTP)
-def ensure_otp():
-    pass
-
-
-class TestSlotStatus:
-    def test_ykman_otp_info(self, ykman_cli):
-        info = ykman_cli("otp", "info").output
-        assert "Slot 1:" in info
-        assert "Slot 2:" in info
-
-    def test_ykman_swap_slots(self, ykman_cli):
-        info = ykman_cli("otp", "info").output
-        if "programmed" not in info:
-            ykman_cli("otp", "static", "2", "incredible")
-        output = ykman_cli("otp", "swap", "-f").output
-        assert "Swapping slots..." in output
-        output = ykman_cli("otp", "swap", "-f").output
-        assert "Swapping slots..." in output
-
-    @condition.yk4_fips(False)
-    def test_ykman_otp_info_does_not_indicate_fips_mode_for_non_fips_key(
-        self, ykman_cli
-    ):  # noqa: E501
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode:" not in info
-
-
-class TestReclaimTimeout:
-    def test_update_after_reclaim(self, ykman_cli):
-        info = ykman_cli("otp", "info").output
-        if "programmed" not in info:
-            ykman_cli("otp", "static", "2", "incredible")
-        ykman_cli("otp", "swap", "-f")
-        ykman_cli("otp", "swap", "-f")
-        sleep(4)  # Ensure reclaim
-        ykman_cli("otp", "swap", "-f")
-        ykman_cli("otp", "swap", "-f")
-
-
-class TestSlotStaticPassword:
-    @pytest.fixture(autouse=True)
-    def delete_slot(self, ykman_cli):
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-        yield None
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-
-    def test_too_long(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "static", "2", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
-
-    def test_unsupported_chars(self, ykman_cli):
-        with pytest.raises(ValueError):
-            ykman_cli("otp", "static", "2", "")
-        with pytest.raises(ValueError):
-            ykman_cli("otp", "static", "2", "@")
-
-    def test_provide_valid_pw(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "higngdukgerjktbbikrhirngtlkkttkb")
-        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
-
-    def test_provide_valid_pw_prompt(self, ykman_cli):
-        ykman_cli("otp", "static", "2", input="higngdukgerjktbbikrhirngtlkkttkb\ny\n")
-        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
-
-    def test_generate_pw_too_long(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "static", "2", "--generate", "--length", "39")
-
-    def test_generate_pw_blank_length(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "static", "2", "--generate", "--length")
-
-    def test_generate_zero_length(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "static", "2", "--generate", "--length", "0")
-
-    def test_generate_pw(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "38")
-        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
-
-    def test_generate_pw_default_length(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate")
-        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
-
-    def test_us_scancodes(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "abcABC123", "--keyboard-layout", "US")
-        ykman_cli("otp", "static", "2", "@!)", "-f", "--keyboard-layout", "US")
-
-    def test_de_scancodes(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "abcABC123", "--keyboard-layout", "DE")
-        ykman_cli("otp", "static", "2", "", "-f", "--keyboard-layout", "DE")
-
-    def test_overwrite_prompt(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "bbb")
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "static", "2", "ccc")
-        ykman_cli("otp", "static", "2", "ddd", "-f")
-        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
-
-
-class TestSlotProgramming:
-    @pytest.fixture(autouse=True)
-    def delete_slot(self, ykman_cli):
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-        yield None
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-
-    def test_ykman_program_otp_slot_2(self, ykman_cli):
-        ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "--public-id",
-            "vvccccfiluij",
-            "--private-id",
-            "267e0a88949b",
-            "--key",
-            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
-            "-f",
-        )
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_prompt(self, ykman_cli):
-        ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            input="vvccccfiluij\n"
-            "267e0a88949b\n"
-            "b8e31ab90bb8830e3c1fe1b483a8e0d4\n"
-            "y\n",
-        )
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_options(self, ykman_cli):
-        output = ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "--public-id",
-            "vvccccfiluij",
-            "--private-id",
-            "267e0a88949b",
-            "--key",
-            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
-            "-f",
-        ).output
-        assert "" == output
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_generated_all(self, ykman_cli):
-        output = ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "-f",
-            "--serial-public-id",
-            "--generate-private-id",
-            "--generate-key",
-        ).output
-        assert "Using YubiKey serial as public ID" in output
-        assert "Using a randomly generated private ID" in output
-        assert "Using a randomly generated secret key" in output
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_serial_public_id(self, ykman_cli):
-        output = ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "--serial-public-id",
-            "--private-id",
-            "267e0a88949b",
-            "--key",
-            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
-            "-f",
-        ).output
-        assert "Using YubiKey serial as public ID" in output
-        assert "generated private ID" not in output
-        assert "generated secret key" not in output
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_invalid_public_id(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "yubiotp", "-P", "imnotmodhex!")
-
-    def test_ykman_program_otp_slot_2_generated_private_id(self, ykman_cli):
-        output = ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "--public-id",
-            "vvccccfiluij",
-            "--generate-private-id",
-            "--key",
-            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
-            "-f",
-        ).output
-        assert "serial as public ID" not in output
-        assert "Using a randomly generated private ID" in output
-        assert "generated secret key" not in output
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_generated_secret_key(self, ykman_cli):
-        output = ykman_cli(
-            "otp",
-            "yubiotp",
-            "2",
-            "--public-id",
-            "vvccccfiluij",
-            "--private-id",
-            "267e0a88949b",
-            "--generate-key",
-            "-f",
-        ).output
-        assert "serial as public ID" not in output
-        assert "generated private ID" not in output
-        assert "Using a randomly generated secret key" in output
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_serial_id_conflicts_public_id(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "yubiotp",
-                "2",
-                "-f",
-                "--serial-public-id",
-                "--public-id",
-                "vvccccfiluij",
-                "--generate-private-id",
-                "--generate-key",
-            )
-        self._check_slot_2_not_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_generate_id_conflicts_private_id(
-        self, ykman_cli
-    ):  # noqa: E501
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "yubiotp",
-                "2",
-                "-f",
-                "--serial-public-id",
-                "--generate-private-id",
-                "--private-id",
-                "267e0a88949b",
-                "--generate-key",
-            )
-        self._check_slot_2_not_programmed(ykman_cli)
-
-    def test_ykman_program_otp_slot_2_generate_key_conflicts_key(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "yubiotp",
-                "2",
-                "-f",
-                "--serial-public-id",
-                "--generate-private-id",
-                "--generate-key",
-                "--key",
-                "b8e31ab90bb8830e3c1fe1b483a8e0d4",
-            )
-        self._check_slot_2_not_programmed(ykman_cli)
-
-    def test_ykman_program_chalresp_slot_2(self, ykman_cli):
-        ykman_cli("otp", "chalresp", "2", "abba", "-f")
-        self._check_slot_2_programmed(ykman_cli)
-        ykman_cli("otp", "chalresp", "2", "--totp", "abba", "-f")
-        self._check_slot_2_programmed(ykman_cli)
-        ykman_cli("otp", "chalresp", "2", "--touch", "abba", "-f")
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_chalresp_slot_2_force_fails_without_key(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "chalresp", "2", "-f")
-        self._check_slot_2_not_programmed(ykman_cli)
-
-    def test_ykman_program_chalresp_slot_2_generated(self, ykman_cli):
-        output = ykman_cli("otp", "chalresp", "2", "-f", "-g").output
-        assert re.match(
-            r"Using a randomly generated key \(hex\): [0-9a-f]{40}$", output
-        )
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_chalresp_slot_2_generated_fails_if_also_given(
-        self, ykman_cli
-    ):  # noqa: E501
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "chalresp", "2", "-f", "-g", "abababab")
-
-    def test_ykman_program_chalresp_slot_2_prompt(self, ykman_cli):
-        ykman_cli("otp", "chalresp", "2", input="abba\ny\n")
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_hotp_slot_2(self, ykman_cli):
-        ykman_cli("otp", "hotp", "2", "27KIZZE3SD7GE2FVJJBAXEI3I6RRTPGM", "-f")
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_ykman_program_hotp_slot_2_prompt(self, ykman_cli):
-        ykman_cli("otp", "hotp", "2", input="abba\ny\n")
-        self._check_slot_2_programmed(ykman_cli)
-
-    def test_update_settings_enter_slot_2(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "-f", "-g", "-l", "20")
-        output = ykman_cli("otp", "settings", "2", "-f", "--no-enter").output
-        assert "Updating settings for slot" in output
-
-    def test_delete_slot_2(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "-f", "-g", "-l", "20")
-        output = ykman_cli("otp", "delete", "2", "-f").output
-        assert "Deleting the configuration" in output
-        status = ykman_cli("otp", "info").output
-        assert "Slot 2: empty" in status
-
-    def test_access_code_slot_2(self, ykman_cli):
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "111111111111",
-            "static",
-            "2",
-            "--generate",
-            "--length",
-            "10",
-        )
-        self._check_slot_2_programmed(ykman_cli)
-        self._check_slot_2_has_access_code(ykman_cli)
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
-        status = ykman_cli("otp", "info").output
-        assert "Slot 2: empty" in status
-
-    @condition.min_version(4, 3, 2)
-    @condition.max_version(4, 3, 5)
-    def test_update_access_code_fails_on_yk_432_to_435(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        self._check_slot_2_programmed(ykman_cli)
-
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
-
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "111111111111",
-            "static",
-            "2",
-            "-f",
-            "--generate",
-            "--length",
-            "10",
-        )
-
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "delete", "2", "-f")
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "--access-code",
-                "111111111111",
-                "settings",
-                "--new-access-code",
-                "222222222222",
-                "2",
-                "-f",
-            )
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
-
-    @condition.min_version(4, 3, 2)
-    @condition.max_version(4, 3, 5)
-    def test_delete_access_code_fails_on_yk_432_to_435(self, ykman_cli):
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "111111111111",
-            "static",
-            "2",
-            "--generate",
-            "--length",
-            "10",
-        )
-
-        self._check_slot_2_programmed(ykman_cli)
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "--access-code",
-                "111111111111",
-                "settings",
-                "--delete-access-code",
-                "2",
-                "-f",
-            )
-
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "delete", "2", "-f")
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
-
-    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
-    def test_update_access_code_slot_2(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        self._check_slot_2_programmed(ykman_cli)
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
-        self._check_slot_2_has_access_code(ykman_cli)
-
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "111111111111",
-            "settings",
-            "--delete-access-code",
-            "2",
-            "-f",
-        )
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        ykman_cli("otp", "delete", "2", "-f")
-
-    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
-    def test_update_access_code_prompt_slot_2(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        self._check_slot_2_programmed(ykman_cli)
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        ykman_cli(
-            "otp", "settings", "--new-access-code", "-", "2", "-f", input="111111111111"
-        )
-        self._check_slot_2_has_access_code(ykman_cli)
-
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "-",
-            "settings",
-            "--delete-access-code",
-            "2",
-            "-f",
-            input="111111111111",
-        )
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        ykman_cli("otp", "delete", "2", "-f")
-
-    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
-    def test_new_access_code_conflicts_with_delete_access_code(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        self._check_slot_2_programmed(ykman_cli)
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "settings",
-                "--delete-access-code",
-                "--new-access-code",
-                "111111111111",
-                "2",
-                "-f",
-            )
-        self._check_slot_2_does_not_have_access_code(ykman_cli)
-
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
-
-        with pytest.raises(SystemExit):
-            ykman_cli(
-                "otp",
-                "settings",
-                "--delete-access-code",
-                "--new-access-code",
-                "111111111111",
-                "2",
-                "-f",
-            )
-        self._check_slot_2_has_access_code(ykman_cli)
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
-
-    def _check_slot_2_programmed(self, ykman_cli):
-        status = ykman_cli("otp", "info").output
-        assert "Slot 2: programmed" in status
-
-    def _check_slot_2_not_programmed(self, ykman_cli):
-        status = ykman_cli("otp", "info").output
-        assert "Slot 2: empty" in status
-
-    def _check_slot_2_has_access_code(self, ykman_cli):
-        with pytest.raises(SystemExit):
-            ykman_cli("otp", "settings", "--pacing", "0", "2", "-f")
-
-        ykman_cli(
-            "otp",
-            "--access-code",
-            "111111111111",
-            "settings",
-            "--pacing",
-            "0",
-            "2",
-            "-f",
-        )
-
-    def _check_slot_2_does_not_have_access_code(self, ykman_cli):
-        ykman_cli("otp", "settings", "--pacing", "0", "2", "-f")
-
-
-class TestSlotCalculate:
-    @pytest.fixture(autouse=True)
-    def delete_slot(self, ykman_cli):
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-        yield None
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-
-    def test_calculate_hex(self, ykman_cli):
-        ykman_cli("otp", "chalresp", "2", "abba", "-f")
-        output = ykman_cli("otp", "calculate", "2", "abba").output
-        assert "f8de2586056d89d8b961a072d1245a495d2155e1" in output
-
-    def test_calculate_totp(self, ykman_cli):
-        ykman_cli("otp", "chalresp", "2", "abba", "-f")
-        output = ykman_cli("otp", "calculate", "2", "999", "-T").output
-        assert "533486" == output.strip()
-        output = ykman_cli("otp", "calculate", "2", "999", "-T", "-d", "8").output
-        assert "04533486" == output.strip()
-        output = ykman_cli("otp", "calculate", "2", "-T").output
-        assert 6 == len(output.strip())
-        output = ykman_cli("otp", "calculate", "2", "-T", "-d", "8").output
-        assert 8 == len(output.strip())
-
-
-class TestFipsMode:
-    @pytest.fixture(autouse=True)
-    @condition.yk4_fips(True)
-    def delete_slots(self, ykman_cli):
-        try:
-            ykman_cli("otp", "delete", "1", "-f")
-        except SystemExit:
-            pass
-        try:
-            ykman_cli("otp", "delete", "2", "-f")
-        except SystemExit:
-            pass
-        yield None
-
-    def test_not_fips_mode_if_no_slot_programmed(self, ykman_cli):
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-    def test_not_fips_mode_if_slot_1_not_programmed(self, ykman_cli):
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-    def test_not_fips_mode_if_slot_2_not_programmed(self, ykman_cli):
-        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-    def test_not_fips_mode_if_no_slot_has_access_code(self, ykman_cli):
-        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-    def test_not_fips_mode_if_only_slot_1_has_access_code(self, ykman_cli):
-        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "1", "-f")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "1", "-f")
-
-    def test_not_fips_mode_if_only_slot_2_has_access_code(self, ykman_cli):
-        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
-        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
-
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: No" in info
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
-
-    def test_fips_mode_if_both_slots_have_access_code(self, ykman_cli):
-        ykman_cli("otp", "static", "--generate", "--length", "10", "1", "-f")
-        ykman_cli("otp", "static", "--generate", "--length", "10", "2", "-f")
-
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "1", "-f")
-        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
-
-        info = ykman_cli("otp", "info").output
-        assert "FIPS Approved Mode: Yes" in info
-
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "1", "-f")
-        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+#  vim: set fileencoding=utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.management import CAPABILITY
+from .. import condition
+from time import sleep
+
+import re
+import pytest
+
+
+@pytest.fixture(autouse=True)
+@condition.capability(CAPABILITY.OTP)
+def ensure_otp():
+    pass
+
+
+class TestSlotStatus:
+    def test_ykman_otp_info(self, ykman_cli):
+        info = ykman_cli("otp", "info").output
+        assert "Slot 1:" in info
+        assert "Slot 2:" in info
+
+    def test_ykman_swap_slots(self, ykman_cli):
+        info = ykman_cli("otp", "info").output
+        if "programmed" not in info:
+            ykman_cli("otp", "static", "2", "incredible")
+        output = ykman_cli("otp", "swap", "-f").output
+        assert "Swapping slots..." in output
+        output = ykman_cli("otp", "swap", "-f").output
+        assert "Swapping slots..." in output
+
+    @condition.yk4_fips(False)
+    def test_ykman_otp_info_does_not_indicate_fips_mode_for_non_fips_key(
+        self, ykman_cli
+    ):  # noqa: E501
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode:" not in info
+
+
+class TestReclaimTimeout:
+    def test_update_after_reclaim(self, ykman_cli):
+        info = ykman_cli("otp", "info").output
+        if "programmed" not in info:
+            ykman_cli("otp", "static", "2", "incredible")
+        ykman_cli("otp", "swap", "-f")
+        ykman_cli("otp", "swap", "-f")
+        sleep(4)  # Ensure reclaim
+        ykman_cli("otp", "swap", "-f")
+        ykman_cli("otp", "swap", "-f")
+
+
+class TestSlotStaticPassword:
+    @pytest.fixture(autouse=True)
+    def delete_slot(self, ykman_cli):
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+        yield None
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+
+    def test_too_long(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "static", "2", "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
+
+    def test_unsupported_chars(self, ykman_cli):
+        with pytest.raises(ValueError):
+            ykman_cli("otp", "static", "2", "")
+        with pytest.raises(ValueError):
+            ykman_cli("otp", "static", "2", "@")
+
+    def test_provide_valid_pw(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "higngdukgerjktbbikrhirngtlkkttkb")
+        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
+
+    def test_provide_valid_pw_prompt(self, ykman_cli):
+        ykman_cli("otp", "static", "2", input="higngdukgerjktbbikrhirngtlkkttkb\ny\n")
+        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
+
+    def test_generate_pw_too_long(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "static", "2", "--generate", "--length", "39")
+
+    def test_generate_pw_blank_length(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "static", "2", "--generate", "--length")
+
+    def test_generate_zero_length(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "static", "2", "--generate", "--length", "0")
+
+    def test_generate_pw(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "38")
+        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
+
+    def test_generate_pw_default_length(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate")
+        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
+
+    def test_us_scancodes(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "abcABC123", "--keyboard-layout", "US")
+        ykman_cli("otp", "static", "2", "@!)", "-f", "--keyboard-layout", "US")
+
+    def test_de_scancodes(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "abcABC123", "--keyboard-layout", "DE")
+        ykman_cli("otp", "static", "2", "", "-f", "--keyboard-layout", "DE")
+
+    def test_overwrite_prompt(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "bbb")
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "static", "2", "ccc")
+        ykman_cli("otp", "static", "2", "ddd", "-f")
+        assert "Slot 2: programmed" in ykman_cli("otp", "info").output
+
+
+class TestSlotProgramming:
+    @pytest.fixture(autouse=True)
+    def delete_slot(self, ykman_cli):
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+        yield None
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+
+    def test_ykman_program_otp_slot_2(self, ykman_cli):
+        ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "--public-id",
+            "vvccccfiluij",
+            "--private-id",
+            "267e0a88949b",
+            "--key",
+            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
+            "-f",
+        )
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_prompt(self, ykman_cli):
+        ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            input="vvccccfiluij\n"
+            "267e0a88949b\n"
+            "b8e31ab90bb8830e3c1fe1b483a8e0d4\n"
+            "y\n",
+        )
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_options(self, ykman_cli):
+        output = ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "--public-id",
+            "vvccccfiluij",
+            "--private-id",
+            "267e0a88949b",
+            "--key",
+            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
+            "-f",
+        ).output
+        assert "" == output
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_generated_all(self, ykman_cli):
+        output = ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "-f",
+            "--serial-public-id",
+            "--generate-private-id",
+            "--generate-key",
+        ).output
+        assert "Using YubiKey serial as public ID" in output
+        assert "Using a randomly generated private ID" in output
+        assert "Using a randomly generated secret key" in output
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_serial_public_id(self, ykman_cli):
+        output = ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "--serial-public-id",
+            "--private-id",
+            "267e0a88949b",
+            "--key",
+            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
+            "-f",
+        ).output
+        assert "Using YubiKey serial as public ID" in output
+        assert "generated private ID" not in output
+        assert "generated secret key" not in output
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_invalid_public_id(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "yubiotp", "-P", "imnotmodhex!")
+
+    def test_ykman_program_otp_slot_2_generated_private_id(self, ykman_cli):
+        output = ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "--public-id",
+            "vvccccfiluij",
+            "--generate-private-id",
+            "--key",
+            "b8e31ab90bb8830e3c1fe1b483a8e0d4",
+            "-f",
+        ).output
+        assert "serial as public ID" not in output
+        assert "Using a randomly generated private ID" in output
+        assert "generated secret key" not in output
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_generated_secret_key(self, ykman_cli):
+        output = ykman_cli(
+            "otp",
+            "yubiotp",
+            "2",
+            "--public-id",
+            "vvccccfiluij",
+            "--private-id",
+            "267e0a88949b",
+            "--generate-key",
+            "-f",
+        ).output
+        assert "serial as public ID" not in output
+        assert "generated private ID" not in output
+        assert "Using a randomly generated secret key" in output
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_serial_id_conflicts_public_id(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "yubiotp",
+                "2",
+                "-f",
+                "--serial-public-id",
+                "--public-id",
+                "vvccccfiluij",
+                "--generate-private-id",
+                "--generate-key",
+            )
+        self._check_slot_2_not_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_generate_id_conflicts_private_id(
+        self, ykman_cli
+    ):  # noqa: E501
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "yubiotp",
+                "2",
+                "-f",
+                "--serial-public-id",
+                "--generate-private-id",
+                "--private-id",
+                "267e0a88949b",
+                "--generate-key",
+            )
+        self._check_slot_2_not_programmed(ykman_cli)
+
+    def test_ykman_program_otp_slot_2_generate_key_conflicts_key(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "yubiotp",
+                "2",
+                "-f",
+                "--serial-public-id",
+                "--generate-private-id",
+                "--generate-key",
+                "--key",
+                "b8e31ab90bb8830e3c1fe1b483a8e0d4",
+            )
+        self._check_slot_2_not_programmed(ykman_cli)
+
+    def test_ykman_program_chalresp_slot_2(self, ykman_cli):
+        ykman_cli("otp", "chalresp", "2", "abba", "-f")
+        self._check_slot_2_programmed(ykman_cli)
+        ykman_cli("otp", "chalresp", "2", "--totp", "abba", "-f")
+        self._check_slot_2_programmed(ykman_cli)
+        ykman_cli("otp", "chalresp", "2", "--touch", "abba", "-f")
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_chalresp_slot_2_force_fails_without_key(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "chalresp", "2", "-f")
+        self._check_slot_2_not_programmed(ykman_cli)
+
+    def test_ykman_program_chalresp_slot_2_generated(self, ykman_cli):
+        output = ykman_cli("otp", "chalresp", "2", "-f", "-g").output
+        assert re.match(
+            r"Using a randomly generated key \(hex\): [0-9a-f]{40}$", output
+        )
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_chalresp_slot_2_generated_fails_if_also_given(
+        self, ykman_cli
+    ):  # noqa: E501
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "chalresp", "2", "-f", "-g", "abababab")
+
+    def test_ykman_program_chalresp_slot_2_prompt(self, ykman_cli):
+        ykman_cli("otp", "chalresp", "2", input="abba\ny\n")
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_hotp_slot_2(self, ykman_cli):
+        ykman_cli("otp", "hotp", "2", "27KIZZE3SD7GE2FVJJBAXEI3I6RRTPGM", "-f")
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_ykman_program_hotp_slot_2_prompt(self, ykman_cli):
+        ykman_cli("otp", "hotp", "2", input="abba\ny\n")
+        self._check_slot_2_programmed(ykman_cli)
+
+    def test_update_settings_enter_slot_2(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "-f", "-g", "-l", "20")
+        output = ykman_cli("otp", "settings", "2", "-f", "--no-enter").output
+        assert "Updating settings for slot" in output
+
+    def test_delete_slot_2(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "-f", "-g", "-l", "20")
+        output = ykman_cli("otp", "delete", "2", "-f").output
+        assert "Deleting the configuration" in output
+        status = ykman_cli("otp", "info").output
+        assert "Slot 2: empty" in status
+
+    def test_access_code_slot_2(self, ykman_cli):
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "111111111111",
+            "static",
+            "2",
+            "--generate",
+            "--length",
+            "10",
+        )
+        self._check_slot_2_programmed(ykman_cli)
+        self._check_slot_2_has_access_code(ykman_cli)
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+        status = ykman_cli("otp", "info").output
+        assert "Slot 2: empty" in status
+
+    @condition.min_version(4, 3, 2)
+    @condition.max_version(4, 3, 5)
+    def test_update_access_code_fails_on_yk_432_to_435(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        self._check_slot_2_programmed(ykman_cli)
+
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
+
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "111111111111",
+            "static",
+            "2",
+            "-f",
+            "--generate",
+            "--length",
+            "10",
+        )
+
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "delete", "2", "-f")
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "--access-code",
+                "111111111111",
+                "settings",
+                "--new-access-code",
+                "222222222222",
+                "2",
+                "-f",
+            )
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+
+    @condition.min_version(4, 3, 2)
+    @condition.max_version(4, 3, 5)
+    def test_delete_access_code_fails_on_yk_432_to_435(self, ykman_cli):
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "111111111111",
+            "static",
+            "2",
+            "--generate",
+            "--length",
+            "10",
+        )
+
+        self._check_slot_2_programmed(ykman_cli)
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "--access-code",
+                "111111111111",
+                "settings",
+                "--delete-access-code",
+                "2",
+                "-f",
+            )
+
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "delete", "2", "-f")
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+
+    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
+    def test_update_access_code_slot_2(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        self._check_slot_2_programmed(ykman_cli)
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
+        self._check_slot_2_has_access_code(ykman_cli)
+
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "111111111111",
+            "settings",
+            "--delete-access-code",
+            "2",
+            "-f",
+        )
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        ykman_cli("otp", "delete", "2", "-f")
+
+    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
+    def test_update_access_code_prompt_slot_2(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        self._check_slot_2_programmed(ykman_cli)
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        ykman_cli(
+            "otp", "settings", "--new-access-code", "-", "2", "-f", input="111111111111"
+        )
+        self._check_slot_2_has_access_code(ykman_cli)
+
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "-",
+            "settings",
+            "--delete-access-code",
+            "2",
+            "-f",
+            input="111111111111",
+        )
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        ykman_cli("otp", "delete", "2", "-f")
+
+    @condition.check(lambda version: not (4, 3, 2) <= version <= (4, 3, 5))
+    def test_new_access_code_conflicts_with_delete_access_code(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        self._check_slot_2_programmed(ykman_cli)
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "settings",
+                "--delete-access-code",
+                "--new-access-code",
+                "111111111111",
+                "2",
+                "-f",
+            )
+        self._check_slot_2_does_not_have_access_code(ykman_cli)
+
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
+
+        with pytest.raises(SystemExit):
+            ykman_cli(
+                "otp",
+                "settings",
+                "--delete-access-code",
+                "--new-access-code",
+                "111111111111",
+                "2",
+                "-f",
+            )
+        self._check_slot_2_has_access_code(ykman_cli)
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+
+    def _check_slot_2_programmed(self, ykman_cli):
+        status = ykman_cli("otp", "info").output
+        assert "Slot 2: programmed" in status
+
+    def _check_slot_2_not_programmed(self, ykman_cli):
+        status = ykman_cli("otp", "info").output
+        assert "Slot 2: empty" in status
+
+    def _check_slot_2_has_access_code(self, ykman_cli):
+        with pytest.raises(SystemExit):
+            ykman_cli("otp", "settings", "--pacing", "0", "2", "-f")
+
+        ykman_cli(
+            "otp",
+            "--access-code",
+            "111111111111",
+            "settings",
+            "--pacing",
+            "0",
+            "2",
+            "-f",
+        )
+
+    def _check_slot_2_does_not_have_access_code(self, ykman_cli):
+        ykman_cli("otp", "settings", "--pacing", "0", "2", "-f")
+
+
+class TestSlotCalculate:
+    @pytest.fixture(autouse=True)
+    def delete_slot(self, ykman_cli):
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+        yield None
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+
+    def test_calculate_hex(self, ykman_cli):
+        ykman_cli("otp", "chalresp", "2", "abba", "-f")
+        output = ykman_cli("otp", "calculate", "2", "abba").output
+        assert "f8de2586056d89d8b961a072d1245a495d2155e1" in output
+
+    def test_calculate_totp(self, ykman_cli):
+        ykman_cli("otp", "chalresp", "2", "abba", "-f")
+        output = ykman_cli("otp", "calculate", "2", "999", "-T").output
+        assert "533486" == output.strip()
+        output = ykman_cli("otp", "calculate", "2", "999", "-T", "-d", "8").output
+        assert "04533486" == output.strip()
+        output = ykman_cli("otp", "calculate", "2", "-T").output
+        assert 6 == len(output.strip())
+        output = ykman_cli("otp", "calculate", "2", "-T", "-d", "8").output
+        assert 8 == len(output.strip())
+
+
+class TestFipsMode:
+    @pytest.fixture(autouse=True)
+    @condition.yk4_fips(True)
+    def delete_slots(self, ykman_cli):
+        try:
+            ykman_cli("otp", "delete", "1", "-f")
+        except SystemExit:
+            pass
+        try:
+            ykman_cli("otp", "delete", "2", "-f")
+        except SystemExit:
+            pass
+        yield None
+
+    def test_not_fips_mode_if_no_slot_programmed(self, ykman_cli):
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+    def test_not_fips_mode_if_slot_1_not_programmed(self, ykman_cli):
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+    def test_not_fips_mode_if_slot_2_not_programmed(self, ykman_cli):
+        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+    def test_not_fips_mode_if_no_slot_has_access_code(self, ykman_cli):
+        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+    def test_not_fips_mode_if_only_slot_1_has_access_code(self, ykman_cli):
+        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "1", "-f")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "1", "-f")
+
+    def test_not_fips_mode_if_only_slot_2_has_access_code(self, ykman_cli):
+        ykman_cli("otp", "static", "1", "--generate", "--length", "10")
+        ykman_cli("otp", "static", "2", "--generate", "--length", "10")
+
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: No" in info
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
+
+    def test_fips_mode_if_both_slots_have_access_code(self, ykman_cli):
+        ykman_cli("otp", "static", "--generate", "--length", "10", "1", "-f")
+        ykman_cli("otp", "static", "--generate", "--length", "10", "2", "-f")
+
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "1", "-f")
+        ykman_cli("otp", "settings", "--new-access-code", "111111111111", "2", "-f")
+
+        info = ykman_cli("otp", "info").output
+        assert "FIPS Approved Mode: Yes" in info
+
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "1", "-f")
+        ykman_cli("otp", "--access-code", "111111111111", "delete", "2", "-f")
```

### Comparing `yubikey_manager-5.1.0/tests/device/condition.py` & `yubikey_manager-5.1.1/tests/device/condition.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-from inspect import signature, Parameter, isgeneratorfunction
-from makefun import wraps
-
-import pytest
-
-
-def check(check, message="Condition not satisfied"):
-    check_sig = signature(check)
-    message = check.__doc__ or message
-
-    def deco(func):
-        func_sig = signature(func)
-        added_params = []
-        for p in check_sig.parameters:
-            if p not in func_sig.parameters:
-                added_params.append(Parameter(p, kind=Parameter.POSITIONAL_OR_KEYWORD))
-        new_sig = func_sig.replace(
-            parameters=list(func_sig.parameters.values()) + added_params
-        )
-
-        def make_func_args(args, kwargs):
-            check_args = {k: v for k, v in kwargs.items() if k in check_sig.parameters}
-            if not check(**check_args):
-                pytest.skip(message)
-            return {k: v for k, v in kwargs.items() if k in func_sig.parameters}
-
-        if isgeneratorfunction(func):
-
-            def wrapper(*args, **kwargs):
-                yield from func(**make_func_args(args, kwargs))
-
-        else:
-
-            def wrapper(*args, **kwargs):
-                return func(**make_func_args(args, kwargs))
-
-        return wraps(func, new_sig=new_sig)(wrapper)
-
-    return deco
-
-
-def transport(required_transport):
-    return check(
-        lambda transport: transport == required_transport,
-        f"Requires {required_transport.name}",
-    )
-
-
-def has_transport(transport):
-    return check(
-        lambda info: info.supported_capabilities.get(transport),
-        f"Requires {transport.name}",
-    )
-
-
-def capability(capability, transport=None):
-    return check(
-        lambda info, device: capability
-        in info.config.enabled_capabilities.get(transport or device.transport, []),
-        f"Requires {capability}",
-    )
-
-
-def min_version(major, minor=0, micro=0):
-    if isinstance(major, tuple):
-        vers = major
-    else:
-        vers = (major, minor, micro)
-    return check(lambda version: version >= vers, f"Version < {vers}")
-
-
-def max_version(major, minor=0, micro=0):
-    if isinstance(major, tuple):
-        vers = major
-    else:
-        vers = (major, minor, micro)
-    return check(lambda version: version <= vers, f"Version > {vers}")
-
-
-def yk4_fips(status=True):
-    return check(
-        lambda info: status == (info.is_fips and info.version[0] == 4),
-        f"Requires YK4 FIPS = {status}",
-    )
+from inspect import signature, Parameter, isgeneratorfunction
+from makefun import wraps
+
+import pytest
+
+
+def check(check, message="Condition not satisfied"):
+    check_sig = signature(check)
+    message = check.__doc__ or message
+
+    def deco(func):
+        func_sig = signature(func)
+        added_params = []
+        for p in check_sig.parameters:
+            if p not in func_sig.parameters:
+                added_params.append(Parameter(p, kind=Parameter.POSITIONAL_OR_KEYWORD))
+        new_sig = func_sig.replace(
+            parameters=list(func_sig.parameters.values()) + added_params
+        )
+
+        def make_func_args(args, kwargs):
+            check_args = {k: v for k, v in kwargs.items() if k in check_sig.parameters}
+            if not check(**check_args):
+                pytest.skip(message)
+            return {k: v for k, v in kwargs.items() if k in func_sig.parameters}
+
+        if isgeneratorfunction(func):
+
+            def wrapper(*args, **kwargs):
+                yield from func(**make_func_args(args, kwargs))
+
+        else:
+
+            def wrapper(*args, **kwargs):
+                return func(**make_func_args(args, kwargs))
+
+        return wraps(func, new_sig=new_sig)(wrapper)
+
+    return deco
+
+
+def transport(required_transport):
+    return check(
+        lambda transport: transport == required_transport,
+        f"Requires {required_transport.name}",
+    )
+
+
+def has_transport(transport):
+    return check(
+        lambda info: info.supported_capabilities.get(transport),
+        f"Requires {transport.name}",
+    )
+
+
+def capability(capability, transport=None):
+    return check(
+        lambda info, device: capability
+        in info.config.enabled_capabilities.get(transport or device.transport, []),
+        f"Requires {capability}",
+    )
+
+
+def min_version(major, minor=0, micro=0):
+    if isinstance(major, tuple):
+        vers = major
+    else:
+        vers = (major, minor, micro)
+    return check(lambda version: version >= vers, f"Version < {vers}")
+
+
+def max_version(major, minor=0, micro=0):
+    if isinstance(major, tuple):
+        vers = major
+    else:
+        vers = (major, minor, micro)
+    return check(lambda version: version <= vers, f"Version > {vers}")
+
+
+def yk4_fips(status=True):
+    return check(
+        lambda info: status == (info.is_fips and info.version[0] == 4),
+        f"Requires YK4 FIPS = {status}",
+    )
```

### Comparing `yubikey_manager-5.1.0/tests/device/test_oath.py` & `yubikey_manager-5.1.1/tests/device/test_oath.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,243 +1,243 @@
-import pytest
-
-from yubikit.core.smartcard import ApduError, AID, SW
-from yubikit.management import CAPABILITY
-from yubikit.oath import (
-    OathSession,
-    CredentialData,
-    HASH_ALGORITHM,
-    OATH_TYPE,
-)
-from . import condition
-
-
-KEY = bytes.fromhex("01020304050607080102030405060708")
-
-
-@pytest.fixture
-@condition.capability(CAPABILITY.OATH)
-def session(ccid_connection):
-    oath = OathSession(ccid_connection)
-    oath.reset()
-    yield oath
-
-
-CRED_DATA = CredentialData("name", OATH_TYPE.TOTP, HASH_ALGORITHM.SHA1, b"secret")
-
-
-class TestFunctions:
-    @condition.min_version(5, 3)
-    def test_rename(self, session):
-        cred = session.put_credential(CRED_DATA)
-        new_id = session.rename_credential(cred.id, "newname", "newissuer")
-        with pytest.raises(ApduError):
-            session.calculate(cred.id, b"challenge")
-        session.calculate(new_id, b"challenge")
-
-    @condition.min_version(5, 3)
-    def test_rename_to_existing(self, session):
-        cred = session.put_credential(CRED_DATA)
-        new_id = session.rename_credential(cred.id, "newname", "newissuer")
-        with pytest.raises(ApduError):
-            session.rename_credential(new_id, "newname", "newissuer")
-
-
-class TestLockPreventsAccess:
-    @pytest.fixture(autouse=True)
-    def set_lock(self, session):
-        assert not session.locked
-        session.put_credential(CRED_DATA)
-        session.set_key(KEY)
-
-        # Force re-select to lock
-        session.protocol.connection.connection.disconnect()
-        session.protocol.connection.connection.connect()
-        session.protocol.select(AID.OATH)
-
-    def test_list(self, session):
-        with pytest.raises(ApduError) as ctx:
-            session.list_credentials()
-        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
-
-    def test_calculate(self, session):
-        with pytest.raises(ApduError) as ctx:
-            session.calculate(CRED_DATA.get_id(), b"challenge")
-        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
-
-    def test_calculate_all(self, session):
-        with pytest.raises(ApduError) as ctx:
-            session.calculate_all()
-        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
-
-    def test_delete(self, session):
-        with pytest.raises(ApduError) as ctx:
-            session.delete_credential(CRED_DATA.get_id())
-        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
-
-    @condition.min_version(5, 3)
-    def test_rename(self, session):
-        with pytest.raises(ApduError) as ctx:
-            session.rename_credential(CRED_DATA.get_id(), "renamed")
-        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
-
-
-HMAC_VECTORS = {
-    b"\x0B"
-    * 20: {
-        b"Hi There": {
-            HASH_ALGORITHM.SHA256: bytes.fromhex(
-                "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7"
-            ),
-            HASH_ALGORITHM.SHA512: bytes.fromhex(
-                "87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cde"
-                "daa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854"
-            ),
-        }
-    },
-    b"Jefe": {
-        b"what do ya want for nothing?": {
-            HASH_ALGORITHM.SHA256: bytes.fromhex(
-                "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843"
-            ),
-            HASH_ALGORITHM.SHA512: bytes.fromhex(
-                "164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea250554"
-                "9758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737"
-            ),
-        }
-    },
-    b"\xAA"
-    * 20: {
-        b"\xDD"
-        * 50: {
-            HASH_ALGORITHM.SHA256: bytes.fromhex(
-                "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe"
-            ),
-            HASH_ALGORITHM.SHA512: bytes.fromhex(
-                "fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33b2279d39"
-                "bf3e848279a722c806b485a47e67c807b946a337bee8942674278859e13292fb"
-            ),
-        }
-    },
-    bytes.fromhex("0102030405060708090a0b0c0d0e0f10111213141516171819"): {
-        b"\xCD"
-        * 50: {
-            HASH_ALGORITHM.SHA256: bytes.fromhex(
-                "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b"
-            ),
-            HASH_ALGORITHM.SHA512: bytes.fromhex(
-                "b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050361ee3db"
-                "a91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2de2adebeb10a298dd"
-            ),
-        }
-    },
-}
-
-
-HMAC_PARAMS = [
-    (key, timestamp, algo, HMAC_VECTORS[key][timestamp][algo])
-    for key in HMAC_VECTORS
-    for timestamp in HMAC_VECTORS[key]
-    for algo in HMAC_VECTORS[key][timestamp]
-]
-
-
-def _ids_hmac(params):
-    key, challenge, hash_algorithm, expected = params
-    key_s = key.hex() if len(key) < 6 else key[:6].hex() + "..."
-    challenge_s = challenge.hex() if len(challenge) < 6 else challenge[:6].hex() + "..."
-    return f"{hash_algorithm.name}-{key_s}-{challenge_s}"
-
-
-class TestHmacVectors:
-    @pytest.mark.parametrize("params", HMAC_PARAMS, ids=_ids_hmac)
-    def test_vector(self, info, session, params):
-        key, challenge, hash_algorithm, expected = params
-        if hash_algorithm == HASH_ALGORITHM.SHA512:
-            if info.version[0] <= 4:
-                if info.is_fips or info.version < (4, 3, 1):
-                    pytest.skip("SHA512 requires (non-FIPS) YubiKey 4.3.1 or later")
-        cred = session.put_credential(
-            CredentialData("test", OATH_TYPE.TOTP, hash_algorithm, key)
-        )
-        value = session.calculate(cred.id, challenge)
-        assert value == expected
-
-
-TOTP_VECTOR_KEYS = {
-    HASH_ALGORITHM.SHA1: b"12345678901234567890",
-    HASH_ALGORITHM.SHA256: b"12345678901234567890123456789012",
-    HASH_ALGORITHM.SHA512: b"12345678901234567890123456789012"
-    b"34567890123456789012345678901234",
-}
-TOTP_VECTORS = {
-    59: {
-        HASH_ALGORITHM.SHA1: "94287082",
-        HASH_ALGORITHM.SHA256: "46119246",
-        HASH_ALGORITHM.SHA512: "90693936",
-    },
-    1111111109: {
-        HASH_ALGORITHM.SHA1: "07081804",
-        HASH_ALGORITHM.SHA256: "68084774",
-        HASH_ALGORITHM.SHA512: "25091201",
-    },
-}
-
-
-TOTP_PARAMS = [
-    (timestamp, algo, TOTP_VECTORS[timestamp][algo], TOTP_VECTOR_KEYS[algo])
-    for timestamp in TOTP_VECTORS
-    for algo in TOTP_VECTORS[timestamp]
-]
-
-
-class TestTotpVectors:
-    @pytest.mark.parametrize("digits", [6, 8])
-    @pytest.mark.parametrize(
-        "params", TOTP_PARAMS, ids=lambda x: "{1.name}-{0}".format(*x)
-    )
-    def test_vector(self, info, session, params, digits):
-        timestamp, hash_algorithm, value, key = params
-        if hash_algorithm == HASH_ALGORITHM.SHA512:
-            if info.version[0] <= 4:
-                if info.is_fips or info.version < (4, 3, 1):
-                    pytest.skip("SHA512 requires (non-FIPS) YubiKey 4.3.1 or later")
-
-        cred = session.put_credential(
-            CredentialData("test", OATH_TYPE.TOTP, hash_algorithm, key, digits)
-        )
-        code = session.calculate_code(cred, timestamp)
-        assert len(code.value) == digits
-        assert value.endswith(code.value)
-
-
-HOTP_VECTORS = {
-    b"12345678901234567890": [
-        "84755224",
-        "94287082",
-        "37359152",
-        "26969429",
-        "40338314",
-        "68254676",
-        "18287922",
-        "82162583",
-        "73399871",
-        "45520489",
-    ]
-}
-
-
-class TestHotpVectors:
-    @pytest.mark.parametrize("digits", [6, 8])
-    @pytest.mark.parametrize(
-        "params", HOTP_VECTORS.items(), ids=lambda x: "{0}".format(*x)
-    )
-    def test_vector(self, session, params, digits):
-        key, values = params
-
-        cred = session.put_credential(
-            CredentialData("test", OATH_TYPE.HOTP, HASH_ALGORITHM.SHA1, key, digits)
-        )
-        for expected in values:
-            code = session.calculate_code(cred)
-            assert len(code.value) == digits
-            assert expected.endswith(code.value)
+import pytest
+
+from yubikit.core.smartcard import ApduError, AID, SW
+from yubikit.management import CAPABILITY
+from yubikit.oath import (
+    OathSession,
+    CredentialData,
+    HASH_ALGORITHM,
+    OATH_TYPE,
+)
+from . import condition
+
+
+KEY = bytes.fromhex("01020304050607080102030405060708")
+
+
+@pytest.fixture
+@condition.capability(CAPABILITY.OATH)
+def session(ccid_connection):
+    oath = OathSession(ccid_connection)
+    oath.reset()
+    yield oath
+
+
+CRED_DATA = CredentialData("name", OATH_TYPE.TOTP, HASH_ALGORITHM.SHA1, b"secret")
+
+
+class TestFunctions:
+    @condition.min_version(5, 3)
+    def test_rename(self, session):
+        cred = session.put_credential(CRED_DATA)
+        new_id = session.rename_credential(cred.id, "newname", "newissuer")
+        with pytest.raises(ApduError):
+            session.calculate(cred.id, b"challenge")
+        session.calculate(new_id, b"challenge")
+
+    @condition.min_version(5, 3)
+    def test_rename_to_existing(self, session):
+        cred = session.put_credential(CRED_DATA)
+        new_id = session.rename_credential(cred.id, "newname", "newissuer")
+        with pytest.raises(ApduError):
+            session.rename_credential(new_id, "newname", "newissuer")
+
+
+class TestLockPreventsAccess:
+    @pytest.fixture(autouse=True)
+    def set_lock(self, session):
+        assert not session.locked
+        session.put_credential(CRED_DATA)
+        session.set_key(KEY)
+
+        # Force re-select to lock
+        session.protocol.connection.connection.disconnect()
+        session.protocol.connection.connection.connect()
+        session.protocol.select(AID.OATH)
+
+    def test_list(self, session):
+        with pytest.raises(ApduError) as ctx:
+            session.list_credentials()
+        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
+
+    def test_calculate(self, session):
+        with pytest.raises(ApduError) as ctx:
+            session.calculate(CRED_DATA.get_id(), b"challenge")
+        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
+
+    def test_calculate_all(self, session):
+        with pytest.raises(ApduError) as ctx:
+            session.calculate_all()
+        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
+
+    def test_delete(self, session):
+        with pytest.raises(ApduError) as ctx:
+            session.delete_credential(CRED_DATA.get_id())
+        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
+
+    @condition.min_version(5, 3)
+    def test_rename(self, session):
+        with pytest.raises(ApduError) as ctx:
+            session.rename_credential(CRED_DATA.get_id(), "renamed")
+        assert ctx.value.sw == SW.SECURITY_CONDITION_NOT_SATISFIED
+
+
+HMAC_VECTORS = {
+    b"\x0B"
+    * 20: {
+        b"Hi There": {
+            HASH_ALGORITHM.SHA256: bytes.fromhex(
+                "b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7"
+            ),
+            HASH_ALGORITHM.SHA512: bytes.fromhex(
+                "87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cde"
+                "daa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854"
+            ),
+        }
+    },
+    b"Jefe": {
+        b"what do ya want for nothing?": {
+            HASH_ALGORITHM.SHA256: bytes.fromhex(
+                "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843"
+            ),
+            HASH_ALGORITHM.SHA512: bytes.fromhex(
+                "164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea250554"
+                "9758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737"
+            ),
+        }
+    },
+    b"\xAA"
+    * 20: {
+        b"\xDD"
+        * 50: {
+            HASH_ALGORITHM.SHA256: bytes.fromhex(
+                "773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe"
+            ),
+            HASH_ALGORITHM.SHA512: bytes.fromhex(
+                "fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33b2279d39"
+                "bf3e848279a722c806b485a47e67c807b946a337bee8942674278859e13292fb"
+            ),
+        }
+    },
+    bytes.fromhex("0102030405060708090a0b0c0d0e0f10111213141516171819"): {
+        b"\xCD"
+        * 50: {
+            HASH_ALGORITHM.SHA256: bytes.fromhex(
+                "82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b"
+            ),
+            HASH_ALGORITHM.SHA512: bytes.fromhex(
+                "b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050361ee3db"
+                "a91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2de2adebeb10a298dd"
+            ),
+        }
+    },
+}
+
+
+HMAC_PARAMS = [
+    (key, timestamp, algo, HMAC_VECTORS[key][timestamp][algo])
+    for key in HMAC_VECTORS
+    for timestamp in HMAC_VECTORS[key]
+    for algo in HMAC_VECTORS[key][timestamp]
+]
+
+
+def _ids_hmac(params):
+    key, challenge, hash_algorithm, expected = params
+    key_s = key.hex() if len(key) < 6 else key[:6].hex() + "..."
+    challenge_s = challenge.hex() if len(challenge) < 6 else challenge[:6].hex() + "..."
+    return f"{hash_algorithm.name}-{key_s}-{challenge_s}"
+
+
+class TestHmacVectors:
+    @pytest.mark.parametrize("params", HMAC_PARAMS, ids=_ids_hmac)
+    def test_vector(self, info, session, params):
+        key, challenge, hash_algorithm, expected = params
+        if hash_algorithm == HASH_ALGORITHM.SHA512:
+            if info.version[0] <= 4:
+                if info.is_fips or info.version < (4, 3, 1):
+                    pytest.skip("SHA512 requires (non-FIPS) YubiKey 4.3.1 or later")
+        cred = session.put_credential(
+            CredentialData("test", OATH_TYPE.TOTP, hash_algorithm, key)
+        )
+        value = session.calculate(cred.id, challenge)
+        assert value == expected
+
+
+TOTP_VECTOR_KEYS = {
+    HASH_ALGORITHM.SHA1: b"12345678901234567890",
+    HASH_ALGORITHM.SHA256: b"12345678901234567890123456789012",
+    HASH_ALGORITHM.SHA512: b"12345678901234567890123456789012"
+    b"34567890123456789012345678901234",
+}
+TOTP_VECTORS = {
+    59: {
+        HASH_ALGORITHM.SHA1: "94287082",
+        HASH_ALGORITHM.SHA256: "46119246",
+        HASH_ALGORITHM.SHA512: "90693936",
+    },
+    1111111109: {
+        HASH_ALGORITHM.SHA1: "07081804",
+        HASH_ALGORITHM.SHA256: "68084774",
+        HASH_ALGORITHM.SHA512: "25091201",
+    },
+}
+
+
+TOTP_PARAMS = [
+    (timestamp, algo, TOTP_VECTORS[timestamp][algo], TOTP_VECTOR_KEYS[algo])
+    for timestamp in TOTP_VECTORS
+    for algo in TOTP_VECTORS[timestamp]
+]
+
+
+class TestTotpVectors:
+    @pytest.mark.parametrize("digits", [6, 8])
+    @pytest.mark.parametrize(
+        "params", TOTP_PARAMS, ids=lambda x: "{1.name}-{0}".format(*x)
+    )
+    def test_vector(self, info, session, params, digits):
+        timestamp, hash_algorithm, value, key = params
+        if hash_algorithm == HASH_ALGORITHM.SHA512:
+            if info.version[0] <= 4:
+                if info.is_fips or info.version < (4, 3, 1):
+                    pytest.skip("SHA512 requires (non-FIPS) YubiKey 4.3.1 or later")
+
+        cred = session.put_credential(
+            CredentialData("test", OATH_TYPE.TOTP, hash_algorithm, key, digits)
+        )
+        code = session.calculate_code(cred, timestamp)
+        assert len(code.value) == digits
+        assert value.endswith(code.value)
+
+
+HOTP_VECTORS = {
+    b"12345678901234567890": [
+        "84755224",
+        "94287082",
+        "37359152",
+        "26969429",
+        "40338314",
+        "68254676",
+        "18287922",
+        "82162583",
+        "73399871",
+        "45520489",
+    ]
+}
+
+
+class TestHotpVectors:
+    @pytest.mark.parametrize("digits", [6, 8])
+    @pytest.mark.parametrize(
+        "params", HOTP_VECTORS.items(), ids=lambda x: "{0}".format(*x)
+    )
+    def test_vector(self, session, params, digits):
+        key, values = params
+
+        cred = session.put_credential(
+            CredentialData("test", OATH_TYPE.HOTP, HASH_ALGORITHM.SHA1, key, digits)
+        )
+        for expected in values:
+            code = session.calculate_code(cred)
+            assert len(code.value) == digits
+            assert expected.endswith(code.value)
```

### Comparing `yubikey_manager-5.1.0/tests/device/test_piv.py` & `yubikey_manager-5.1.1/tests/device/test_piv.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,610 +1,610 @@
-import datetime
-import random
-import pytest
-
-from cryptography import x509
-from cryptography.hazmat.primitives import hashes, serialization
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
-
-from yubikit.core import NotSupportedError
-from yubikit.core.smartcard import AID, ApduError
-from yubikit.management import CAPABILITY
-from yubikit.piv import (
-    PivSession,
-    ALGORITHM,
-    KEY_TYPE,
-    PIN_POLICY,
-    TOUCH_POLICY,
-    SLOT,
-    MANAGEMENT_KEY_TYPE,
-    InvalidPinError,
-)
-from ykman.piv import (
-    check_key,
-    get_pivman_data,
-    get_pivman_protected_data,
-    generate_self_signed_certificate,
-    generate_csr,
-    pivman_set_mgm_key,
-)
-from ykman.util import parse_certificates, parse_private_key
-from ..util import open_file
-from . import condition
-
-
-DEFAULT_PIN = "123456"
-NON_DEFAULT_PIN = "654321"
-DEFAULT_PUK = "12345678"
-NON_DEFAULT_PUK = "87654321"
-DEFAULT_MANAGEMENT_KEY = bytes.fromhex(
-    "010203040506070801020304050607080102030405060708"
-)
-NON_DEFAULT_MANAGEMENT_KEY = bytes.fromhex(
-    "010103040506070801020304050607080102030405060708"
-)
-
-NOW = datetime.datetime.now()
-
-
-def get_test_cert():
-    with open_file("rsa_2048_cert.pem") as f:
-        return parse_certificates(f.read(), None)[0]
-
-
-def get_test_key():
-    with open_file("rsa_2048_key.pem") as f:
-        return parse_private_key(f.read(), None)
-
-
-@pytest.fixture
-@condition.capability(CAPABILITY.PIV)
-def session(ccid_connection):
-    piv = PivSession(ccid_connection)
-    piv.reset()
-    yield piv
-    reset_state(piv)
-
-
-def not_roca(version):
-    return not ((4, 2, 0) <= version < (4, 3, 5))
-
-
-def reset_state(session):
-    session.protocol.connection.connection.disconnect()
-    session.protocol.connection.connection.connect()
-    session.protocol.select(AID.PIV)
-
-
-def assert_mgm_key_is(session, key):
-    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, key)
-
-
-def assert_mgm_key_is_not(session, key):
-    with pytest.raises(ApduError):
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, key)
-
-
-def generate_key(
-    session,
-    slot=SLOT.AUTHENTICATION,
-    alg=KEY_TYPE.ECCP256,
-    pin_policy=PIN_POLICY.DEFAULT,
-):
-    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-    key = session.generate_key(slot, alg, pin_policy=pin_policy)
-    reset_state(session)
-    return key
-
-
-def import_key(
-    session,
-    slot=SLOT.AUTHENTICATION,
-    key_type=KEY_TYPE.ECCP256,
-    pin_policy=PIN_POLICY.DEFAULT,
-):
-
-    if key_type.algorithm == ALGORITHM.RSA:
-        private_key = rsa.generate_private_key(
-            65537, key_type.bit_len, default_backend()
-        )
-    elif key_type == KEY_TYPE.ECCP256:
-        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
-    elif key_type == KEY_TYPE.ECCP384:
-        private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())
-    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-    session.put_key(slot, private_key, pin_policy)
-    reset_state(session)
-    return private_key.public_key()
-
-
-def verify_cert_signature(cert, public_key=None):
-    if not public_key:
-        public_key = cert.public_key
-    args = [cert.signature, cert.tbs_certificate_bytes, cert.signature_hash_algorithm]
-    if KEY_TYPE.from_public_key(public_key).algorithm == ALGORITHM.RSA:
-        args.insert(2, padding.PKCS1v15())
-    else:
-        args[2] = ec.ECDSA(args[2])
-    public_key.verify(*args)
-
-
-class TestCertificateSignatures:
-    @pytest.mark.parametrize("key_type", list(KEY_TYPE))
-    @pytest.mark.parametrize(
-        "hash_algorithm", (hashes.SHA256, hashes.SHA384, hashes.SHA512)
-    )
-    def test_generate_self_signed_certificate(
-        self, info, session, key_type, hash_algorithm
-    ):
-        if key_type == KEY_TYPE.ECCP384 and session.version < (4, 0, 0):
-            pytest.skip("ECCP384 requires YubiKey 4 or later")
-        if key_type == KEY_TYPE.RSA1024 and info.is_fips and info.version[0] == 4:
-            pytest.skip("RSA1024 not available on YubiKey FIPS")
-
-        slot = SLOT.SIGNATURE
-        public_key = import_key(session, slot, key_type)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.verify_pin(DEFAULT_PIN)
-        cert = generate_self_signed_certificate(
-            session, slot, public_key, "CN=alice", NOW, NOW, hash_algorithm
-        )
-
-        assert cert.public_key().public_numbers() == public_key.public_numbers()
-        verify_cert_signature(cert, public_key)
-
-
-class TestKeyManagement:
-    def test_delete_certificate_requires_authentication(self, session):
-        generate_key(session, SLOT.AUTHENTICATION)
-
-        with pytest.raises(ApduError):
-            session.delete_certificate(SLOT.AUTHENTICATION)
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.delete_certificate(SLOT.AUTHENTICATION)
-
-    def test_generate_csr_works(self, session):
-        public_key = generate_key(session, SLOT.AUTHENTICATION)
-
-        session.verify_pin(DEFAULT_PIN)
-        csr = generate_csr(session, SLOT.AUTHENTICATION, public_key, "CN=alice")
-
-        assert csr.public_key().public_numbers() == public_key.public_numbers()
-        assert (
-            csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[0].value
-            == "alice"
-        )
-
-    def test_generate_self_signed_certificate_requires_pin(self, session):
-        session.verify_pin(DEFAULT_PIN)
-        public_key = generate_key(session, SLOT.AUTHENTICATION)
-
-        with pytest.raises(ApduError):
-            generate_self_signed_certificate(
-                session, SLOT.AUTHENTICATION, public_key, "CN=alice", NOW, NOW
-            )
-
-        session.verify_pin(DEFAULT_PIN)
-        generate_self_signed_certificate(
-            session, SLOT.AUTHENTICATION, public_key, "CN=alice", NOW, NOW
-        )
-
-    @pytest.mark.parametrize("slot", (SLOT.SIGNATURE, SLOT.AUTHENTICATION))
-    def test_generate_self_signed_certificate(self, session, slot):
-        public_key = generate_key(session, slot)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.verify_pin(DEFAULT_PIN)
-        cert = generate_self_signed_certificate(
-            session, slot, public_key, "CN=alice", NOW, NOW
-        )
-
-        assert cert.public_key().public_numbers() == public_key.public_numbers()
-        assert (
-            cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[0].value
-            == "alice"
-        )
-
-    def test_generate_key_requires_authentication(self, session):
-        with pytest.raises(ApduError):
-            session.generate_key(
-                SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, touch_policy=TOUCH_POLICY.DEFAULT
-            )
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.generate_key(SLOT.AUTHENTICATION, KEY_TYPE.ECCP256)
-
-    def test_put_certificate_requires_authentication(self, session):
-        cert = get_test_cert()
-        with pytest.raises(ApduError):
-            session.put_certificate(SLOT.AUTHENTICATION, cert)
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.put_certificate(SLOT.AUTHENTICATION, cert)
-
-    def _test_put_key_pairing(self, session, alg1, alg2):
-        # Set up a key in the slot and create a certificate for it
-        public_key = generate_key(session, SLOT.AUTHENTICATION, alg=alg1)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.verify_pin(DEFAULT_PIN)
-        cert = generate_self_signed_certificate(
-            session, SLOT.AUTHENTICATION, public_key, "CN=test", NOW, NOW
-        )
-        session.put_certificate(SLOT.AUTHENTICATION, cert)
-        assert check_key(session, SLOT.AUTHENTICATION, cert.public_key())
-
-        cert2 = session.get_certificate(SLOT.AUTHENTICATION)
-        assert cert == cert2
-
-        session.delete_certificate(SLOT.AUTHENTICATION)
-
-        # Overwrite the key with one of the same type
-        generate_key(session, SLOT.AUTHENTICATION, alg=alg1)
-        session.verify_pin(DEFAULT_PIN)
-        assert not check_key(session, SLOT.AUTHENTICATION, cert.public_key())
-
-        # Overwrite the key with one of a different type
-        generate_key(session, SLOT.AUTHENTICATION, alg=alg2)
-        session.verify_pin(DEFAULT_PIN)
-        assert not check_key(session, SLOT.AUTHENTICATION, cert.public_key())
-
-    @condition.check(not_roca)
-    @condition.yk4_fips(False)
-    def test_put_certificate_verifies_key_pairing_rsa1024(self, session):
-        self._test_put_key_pairing(session, KEY_TYPE.RSA1024, KEY_TYPE.ECCP256)
-
-    @condition.check(not_roca)
-    def test_put_certificate_verifies_key_pairing_rsa2048(self, session):
-        self._test_put_key_pairing(session, KEY_TYPE.RSA2048, KEY_TYPE.ECCP256)
-
-    @condition.check(not_roca)
-    def test_put_certificate_verifies_key_pairing_eccp256_a(self, session):
-        self._test_put_key_pairing(session, KEY_TYPE.ECCP256, KEY_TYPE.RSA2048)
-
-    @condition.min_version(4)
-    def test_put_certificate_verifies_key_pairing_eccp256_b(self, session):
-        self._test_put_key_pairing(session, KEY_TYPE.ECCP256, KEY_TYPE.ECCP384)
-
-    @condition.min_version(4)
-    def test_put_certificate_verifies_key_pairing_eccp384(self, session):
-        self._test_put_key_pairing(session, KEY_TYPE.ECCP384, KEY_TYPE.ECCP256)
-
-    def test_put_key_requires_authentication(self, session):
-        private_key = get_test_key()
-        with pytest.raises(ApduError):
-            session.put_key(SLOT.AUTHENTICATION, private_key)
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.put_key(SLOT.AUTHENTICATION, private_key)
-
-    def test_get_certificate_does_not_require_authentication(self, session):
-        cert = get_test_cert()
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.put_certificate(SLOT.AUTHENTICATION, cert)
-        reset_state(session)
-
-        assert session.get_certificate(SLOT.AUTHENTICATION)
-
-
-class TestManagementKeyReadOnly:
-    """
-    Tests after which the management key is always the default management
-    key. Placing compatible tests here reduces the amount of slow reset
-    calls needed.
-    """
-
-    def test_authenticate_twice_does_not_throw(self, session):
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-
-    def test_reset_resets_has_stored_key_flag(self, session):
-        pivman = get_pivman_data(session)
-        assert not pivman.has_stored_key
-
-        session.verify_pin(DEFAULT_PIN)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        pivman_set_mgm_key(
-            session,
-            NON_DEFAULT_MANAGEMENT_KEY,
-            MANAGEMENT_KEY_TYPE.TDES,
-            store_on_device=True,
-        )
-
-        pivman = get_pivman_data(session)
-        assert pivman.has_stored_key
-
-        reset_state(session)
-        session.reset()
-
-        pivman = get_pivman_data(session)
-        assert not pivman.has_stored_key
-
-    # Should this really fail?
-    def disabled_test_reset_while_verified_throws_nice_ValueError(self, session):
-        session.verify_pin(DEFAULT_PIN)
-        with pytest.raises(ValueError) as cm:
-            session.reset()
-        assert "Cannot read remaining tries from status word: 9000" in str(cm.exception)
-
-    def test_set_mgm_key_does_not_change_key_if_not_authenticated(self, session):
-        with pytest.raises(ApduError):
-            session.set_management_key(
-                MANAGEMENT_KEY_TYPE.TDES, NON_DEFAULT_MANAGEMENT_KEY
-            )
-        assert_mgm_key_is(session, DEFAULT_MANAGEMENT_KEY)
-
-    @condition.min_version(3, 5)
-    def test_set_stored_mgm_key_does_not_destroy_key_if_pin_not_verified(self, session):
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        with pytest.raises(ApduError):
-            pivman_set_mgm_key(
-                session,
-                NON_DEFAULT_MANAGEMENT_KEY,
-                MANAGEMENT_KEY_TYPE.TDES,
-                store_on_device=True,
-            )
-
-        assert_mgm_key_is(session, DEFAULT_MANAGEMENT_KEY)
-
-
-class TestManagementKeyReadWrite:
-    """
-    Tests after which the management key may not be the default management
-    key.
-    """
-
-    def test_set_mgm_key_changes_mgm_key(self, session):
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, NON_DEFAULT_MANAGEMENT_KEY)
-
-        assert_mgm_key_is_not(session, DEFAULT_MANAGEMENT_KEY)
-        assert_mgm_key_is(session, NON_DEFAULT_MANAGEMENT_KEY)
-
-    def test_set_stored_mgm_key_succeeds_if_pin_is_verified(self, session):
-        session.verify_pin(DEFAULT_PIN)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        pivman_set_mgm_key(
-            session,
-            NON_DEFAULT_MANAGEMENT_KEY,
-            MANAGEMENT_KEY_TYPE.TDES,
-            store_on_device=True,
-        )
-
-        assert_mgm_key_is_not(session, DEFAULT_MANAGEMENT_KEY)
-        assert_mgm_key_is(session, NON_DEFAULT_MANAGEMENT_KEY)
-
-        pivman_prot = get_pivman_protected_data(session)
-        assert pivman_prot.key == NON_DEFAULT_MANAGEMENT_KEY
-
-        pivman_prot = get_pivman_protected_data(session)
-        assert_mgm_key_is(session, pivman_prot.key)
-
-
-def sign(session, slot, key_type, message):
-    return session.sign(slot, key_type, message, hashes.SHA256(), padding.PKCS1v15())
-
-
-class TestOperations:
-    @condition.min_version(4)
-    def test_sign_with_pin_policy_always_requires_pin_every_time(self, session):
-        generate_key(session, pin_policy=PIN_POLICY.ALWAYS)
-
-        with pytest.raises(ApduError):
-            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-
-        session.verify_pin(DEFAULT_PIN)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-        with pytest.raises(ApduError):
-            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-
-        session.verify_pin(DEFAULT_PIN)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-    @condition.yk4_fips(False)
-    @condition.min_version(4)
-    def test_sign_with_pin_policy_never_does_not_require_pin(self, session):
-        generate_key(session, pin_policy=PIN_POLICY.NEVER)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-    @condition.yk4_fips(True)
-    def test_pin_policy_never_blocked_on_fips(self, session):
-        with pytest.raises(NotSupportedError):
-            generate_key(session, pin_policy=PIN_POLICY.NEVER)
-
-    @condition.min_version(4)
-    def test_sign_with_pin_policy_once_requires_pin_once_per_session(self, session):
-        generate_key(session, pin_policy=PIN_POLICY.ONCE)
-
-        with pytest.raises(ApduError):
-            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-
-        session.verify_pin(DEFAULT_PIN)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-        reset_state(session)
-
-        with pytest.raises(ApduError):
-            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-
-        session.verify_pin(DEFAULT_PIN)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
-        assert sig
-
-    def test_signature_can_be_verified_by_public_key(self, session):
-        public_key = generate_key(session)
-
-        signed_data = bytes(random.randint(0, 255) for i in range(32))
-
-        session.verify_pin(DEFAULT_PIN)
-        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, signed_data)
-        assert sig
-
-        public_key.verify(sig, signed_data, ec.ECDSA(hashes.SHA256()))
-
-
-def block_pin(session):
-    while session.get_pin_attempts() > 0:
-        try:
-            session.verify_pin(NON_DEFAULT_PIN)
-        except Exception:
-            pass
-
-
-class TestUnblockPin:
-    def test_unblock_pin_requires_no_previous_authentication(self, session):
-        session.unblock_pin(DEFAULT_PUK, NON_DEFAULT_PIN)
-
-    def test_unblock_pin_with_wrong_puk_throws_InvalidPinError(self, session):
-        with pytest.raises(InvalidPinError):
-            session.unblock_pin(NON_DEFAULT_PUK, NON_DEFAULT_PIN)
-
-    def test_unblock_pin_resets_pin_and_retries(self, session):
-        session.reset()
-        reset_state(session)
-
-        block_pin(session)
-
-        with pytest.raises(InvalidPinError):
-            session.verify_pin(DEFAULT_PIN)
-
-        session.unblock_pin(DEFAULT_PUK, NON_DEFAULT_PIN)
-
-        assert session.get_pin_attempts() == 3
-        session.verify_pin(NON_DEFAULT_PIN)
-
-    def test_set_pin_retries_requires_pin_and_mgm_key(self, session):
-        # Fails with no authentication
-        with pytest.raises(ApduError):
-            session.set_pin_attempts(4, 4)
-
-        # Fails with only PIN
-        session.verify_pin(DEFAULT_PIN)
-        with pytest.raises(ApduError):
-            session.set_pin_attempts(4, 4)
-
-        reset_state(session)
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        # Fails with only management key (requirement added in 0.1.3)
-        if session.version >= (0, 1, 3):
-            with pytest.raises(ApduError):
-                session.set_pin_attempts(4, 4)
-
-        # Succeeds with both PIN and management key
-        session.verify_pin(DEFAULT_PIN)
-        session.set_pin_attempts(4, 4)
-
-    def test_set_pin_retries_sets_pin_and_puk_tries(self, session):
-        pin_tries = 9
-        puk_tries = 7
-
-        session.verify_pin(DEFAULT_PIN)
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.set_pin_attempts(pin_tries, puk_tries)
-
-        reset_state(session)
-
-        assert session.get_pin_attempts() == pin_tries
-        with pytest.raises(InvalidPinError) as ctx:
-            session.change_puk(NON_DEFAULT_PUK, DEFAULT_PUK)
-        assert ctx.value.attempts_remaining == puk_tries - 1
-
-
-class TestMetadata:
-    @pytest.fixture(autouse=True)
-    @condition.min_version(5, 3)
-    def preconditions(self):
-        pass
-
-    def test_pin_metadata(self, session):
-        data = session.get_pin_metadata()
-        assert data.default_value is True
-        assert data.total_attempts == 3
-        assert data.attempts_remaining == 3
-
-    def test_management_key_metadata(self, session):
-        data = session.get_management_key_metadata()
-        assert data.key_type == MANAGEMENT_KEY_TYPE.TDES
-        assert data.default_value is True
-        assert data.touch_policy is TOUCH_POLICY.NEVER
-
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.set_management_key(
-            MANAGEMENT_KEY_TYPE.AES192, NON_DEFAULT_MANAGEMENT_KEY
-        )
-        data = session.get_management_key_metadata()
-        assert data.key_type == MANAGEMENT_KEY_TYPE.AES192
-        assert data.default_value is False
-        assert data.touch_policy is TOUCH_POLICY.NEVER
-
-        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        data = session.get_management_key_metadata()
-        assert data.default_value is True
-
-        session.set_management_key(MANAGEMENT_KEY_TYPE.AES192, DEFAULT_MANAGEMENT_KEY)
-        data = session.get_management_key_metadata()
-        assert data.default_value is False
-
-    @pytest.mark.parametrize("key_type", list(KEY_TYPE))
-    def test_slot_metadata_generate(self, session, key_type):
-        slot = SLOT.SIGNATURE
-        key = generate_key(session, slot, key_type)
-        data = session.get_slot_metadata(slot)
-
-        assert data.key_type == key_type
-        assert data.pin_policy == PIN_POLICY.ALWAYS
-        assert data.touch_policy == TOUCH_POLICY.NEVER
-        assert data.generated is True
-        assert data.public_key.public_bytes(
-            encoding=serialization.Encoding.DER,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        ) == key.public_bytes(
-            encoding=serialization.Encoding.DER,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        )
-
-    @pytest.mark.parametrize(
-        "key",
-        [
-            rsa.generate_private_key(65537, 1024, default_backend()),
-            rsa.generate_private_key(65537, 2048, default_backend()),
-            ec.generate_private_key(ec.SECP256R1(), default_backend()),
-            ec.generate_private_key(ec.SECP384R1(), default_backend()),
-        ],
-    )
-    @pytest.mark.parametrize(
-        "slot, pin_policy",
-        [
-            (SLOT.AUTHENTICATION, PIN_POLICY.ONCE),
-            (SLOT.SIGNATURE, PIN_POLICY.ALWAYS),
-            (SLOT.KEY_MANAGEMENT, PIN_POLICY.ONCE),
-            (SLOT.CARD_AUTH, PIN_POLICY.NEVER),
-        ],
-    )
-    def test_slot_metadata_put(self, session, key, slot, pin_policy):
-        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
-        session.put_key(slot, key)
-        data = session.get_slot_metadata(slot)
-
-        assert data.key_type == KEY_TYPE.from_public_key(key.public_key())
-        assert data.pin_policy == pin_policy
-        assert data.touch_policy == TOUCH_POLICY.NEVER
-        assert data.generated is False
-        assert data.public_key.public_bytes(
-            encoding=serialization.Encoding.DER,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        ) == key.public_key().public_bytes(
-            encoding=serialization.Encoding.DER,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        )
+import datetime
+import random
+import pytest
+
+from cryptography import x509
+from cryptography.hazmat.primitives import hashes, serialization
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
+
+from yubikit.core import NotSupportedError
+from yubikit.core.smartcard import AID, ApduError
+from yubikit.management import CAPABILITY
+from yubikit.piv import (
+    PivSession,
+    ALGORITHM,
+    KEY_TYPE,
+    PIN_POLICY,
+    TOUCH_POLICY,
+    SLOT,
+    MANAGEMENT_KEY_TYPE,
+    InvalidPinError,
+)
+from ykman.piv import (
+    check_key,
+    get_pivman_data,
+    get_pivman_protected_data,
+    generate_self_signed_certificate,
+    generate_csr,
+    pivman_set_mgm_key,
+)
+from ykman.util import parse_certificates, parse_private_key
+from ..util import open_file
+from . import condition
+
+
+DEFAULT_PIN = "123456"
+NON_DEFAULT_PIN = "654321"
+DEFAULT_PUK = "12345678"
+NON_DEFAULT_PUK = "87654321"
+DEFAULT_MANAGEMENT_KEY = bytes.fromhex(
+    "010203040506070801020304050607080102030405060708"
+)
+NON_DEFAULT_MANAGEMENT_KEY = bytes.fromhex(
+    "010103040506070801020304050607080102030405060708"
+)
+
+NOW = datetime.datetime.now()
+
+
+def get_test_cert():
+    with open_file("rsa_2048_cert.pem") as f:
+        return parse_certificates(f.read(), None)[0]
+
+
+def get_test_key():
+    with open_file("rsa_2048_key.pem") as f:
+        return parse_private_key(f.read(), None)
+
+
+@pytest.fixture
+@condition.capability(CAPABILITY.PIV)
+def session(ccid_connection):
+    piv = PivSession(ccid_connection)
+    piv.reset()
+    yield piv
+    reset_state(piv)
+
+
+def not_roca(version):
+    return not ((4, 2, 0) <= version < (4, 3, 5))
+
+
+def reset_state(session):
+    session.protocol.connection.connection.disconnect()
+    session.protocol.connection.connection.connect()
+    session.protocol.select(AID.PIV)
+
+
+def assert_mgm_key_is(session, key):
+    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, key)
+
+
+def assert_mgm_key_is_not(session, key):
+    with pytest.raises(ApduError):
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, key)
+
+
+def generate_key(
+    session,
+    slot=SLOT.AUTHENTICATION,
+    alg=KEY_TYPE.ECCP256,
+    pin_policy=PIN_POLICY.DEFAULT,
+):
+    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+    key = session.generate_key(slot, alg, pin_policy=pin_policy)
+    reset_state(session)
+    return key
+
+
+def import_key(
+    session,
+    slot=SLOT.AUTHENTICATION,
+    key_type=KEY_TYPE.ECCP256,
+    pin_policy=PIN_POLICY.DEFAULT,
+):
+
+    if key_type.algorithm == ALGORITHM.RSA:
+        private_key = rsa.generate_private_key(
+            65537, key_type.bit_len, default_backend()
+        )
+    elif key_type == KEY_TYPE.ECCP256:
+        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
+    elif key_type == KEY_TYPE.ECCP384:
+        private_key = ec.generate_private_key(ec.SECP384R1(), default_backend())
+    session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+    session.put_key(slot, private_key, pin_policy)
+    reset_state(session)
+    return private_key.public_key()
+
+
+def verify_cert_signature(cert, public_key=None):
+    if not public_key:
+        public_key = cert.public_key
+    args = [cert.signature, cert.tbs_certificate_bytes, cert.signature_hash_algorithm]
+    if KEY_TYPE.from_public_key(public_key).algorithm == ALGORITHM.RSA:
+        args.insert(2, padding.PKCS1v15())
+    else:
+        args[2] = ec.ECDSA(args[2])
+    public_key.verify(*args)
+
+
+class TestCertificateSignatures:
+    @pytest.mark.parametrize("key_type", list(KEY_TYPE))
+    @pytest.mark.parametrize(
+        "hash_algorithm", (hashes.SHA256, hashes.SHA384, hashes.SHA512)
+    )
+    def test_generate_self_signed_certificate(
+        self, info, session, key_type, hash_algorithm
+    ):
+        if key_type == KEY_TYPE.ECCP384 and session.version < (4, 0, 0):
+            pytest.skip("ECCP384 requires YubiKey 4 or later")
+        if key_type == KEY_TYPE.RSA1024 and info.is_fips and info.version[0] == 4:
+            pytest.skip("RSA1024 not available on YubiKey FIPS")
+
+        slot = SLOT.SIGNATURE
+        public_key = import_key(session, slot, key_type)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.verify_pin(DEFAULT_PIN)
+        cert = generate_self_signed_certificate(
+            session, slot, public_key, "CN=alice", NOW, NOW, hash_algorithm
+        )
+
+        assert cert.public_key().public_numbers() == public_key.public_numbers()
+        verify_cert_signature(cert, public_key)
+
+
+class TestKeyManagement:
+    def test_delete_certificate_requires_authentication(self, session):
+        generate_key(session, SLOT.AUTHENTICATION)
+
+        with pytest.raises(ApduError):
+            session.delete_certificate(SLOT.AUTHENTICATION)
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.delete_certificate(SLOT.AUTHENTICATION)
+
+    def test_generate_csr_works(self, session):
+        public_key = generate_key(session, SLOT.AUTHENTICATION)
+
+        session.verify_pin(DEFAULT_PIN)
+        csr = generate_csr(session, SLOT.AUTHENTICATION, public_key, "CN=alice")
+
+        assert csr.public_key().public_numbers() == public_key.public_numbers()
+        assert (
+            csr.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[0].value
+            == "alice"
+        )
+
+    def test_generate_self_signed_certificate_requires_pin(self, session):
+        session.verify_pin(DEFAULT_PIN)
+        public_key = generate_key(session, SLOT.AUTHENTICATION)
+
+        with pytest.raises(ApduError):
+            generate_self_signed_certificate(
+                session, SLOT.AUTHENTICATION, public_key, "CN=alice", NOW, NOW
+            )
+
+        session.verify_pin(DEFAULT_PIN)
+        generate_self_signed_certificate(
+            session, SLOT.AUTHENTICATION, public_key, "CN=alice", NOW, NOW
+        )
+
+    @pytest.mark.parametrize("slot", (SLOT.SIGNATURE, SLOT.AUTHENTICATION))
+    def test_generate_self_signed_certificate(self, session, slot):
+        public_key = generate_key(session, slot)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.verify_pin(DEFAULT_PIN)
+        cert = generate_self_signed_certificate(
+            session, slot, public_key, "CN=alice", NOW, NOW
+        )
+
+        assert cert.public_key().public_numbers() == public_key.public_numbers()
+        assert (
+            cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)[0].value
+            == "alice"
+        )
+
+    def test_generate_key_requires_authentication(self, session):
+        with pytest.raises(ApduError):
+            session.generate_key(
+                SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, touch_policy=TOUCH_POLICY.DEFAULT
+            )
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.generate_key(SLOT.AUTHENTICATION, KEY_TYPE.ECCP256)
+
+    def test_put_certificate_requires_authentication(self, session):
+        cert = get_test_cert()
+        with pytest.raises(ApduError):
+            session.put_certificate(SLOT.AUTHENTICATION, cert)
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.put_certificate(SLOT.AUTHENTICATION, cert)
+
+    def _test_put_key_pairing(self, session, alg1, alg2):
+        # Set up a key in the slot and create a certificate for it
+        public_key = generate_key(session, SLOT.AUTHENTICATION, alg=alg1)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.verify_pin(DEFAULT_PIN)
+        cert = generate_self_signed_certificate(
+            session, SLOT.AUTHENTICATION, public_key, "CN=test", NOW, NOW
+        )
+        session.put_certificate(SLOT.AUTHENTICATION, cert)
+        assert check_key(session, SLOT.AUTHENTICATION, cert.public_key())
+
+        cert2 = session.get_certificate(SLOT.AUTHENTICATION)
+        assert cert == cert2
+
+        session.delete_certificate(SLOT.AUTHENTICATION)
+
+        # Overwrite the key with one of the same type
+        generate_key(session, SLOT.AUTHENTICATION, alg=alg1)
+        session.verify_pin(DEFAULT_PIN)
+        assert not check_key(session, SLOT.AUTHENTICATION, cert.public_key())
+
+        # Overwrite the key with one of a different type
+        generate_key(session, SLOT.AUTHENTICATION, alg=alg2)
+        session.verify_pin(DEFAULT_PIN)
+        assert not check_key(session, SLOT.AUTHENTICATION, cert.public_key())
+
+    @condition.check(not_roca)
+    @condition.yk4_fips(False)
+    def test_put_certificate_verifies_key_pairing_rsa1024(self, session):
+        self._test_put_key_pairing(session, KEY_TYPE.RSA1024, KEY_TYPE.ECCP256)
+
+    @condition.check(not_roca)
+    def test_put_certificate_verifies_key_pairing_rsa2048(self, session):
+        self._test_put_key_pairing(session, KEY_TYPE.RSA2048, KEY_TYPE.ECCP256)
+
+    @condition.check(not_roca)
+    def test_put_certificate_verifies_key_pairing_eccp256_a(self, session):
+        self._test_put_key_pairing(session, KEY_TYPE.ECCP256, KEY_TYPE.RSA2048)
+
+    @condition.min_version(4)
+    def test_put_certificate_verifies_key_pairing_eccp256_b(self, session):
+        self._test_put_key_pairing(session, KEY_TYPE.ECCP256, KEY_TYPE.ECCP384)
+
+    @condition.min_version(4)
+    def test_put_certificate_verifies_key_pairing_eccp384(self, session):
+        self._test_put_key_pairing(session, KEY_TYPE.ECCP384, KEY_TYPE.ECCP256)
+
+    def test_put_key_requires_authentication(self, session):
+        private_key = get_test_key()
+        with pytest.raises(ApduError):
+            session.put_key(SLOT.AUTHENTICATION, private_key)
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.put_key(SLOT.AUTHENTICATION, private_key)
+
+    def test_get_certificate_does_not_require_authentication(self, session):
+        cert = get_test_cert()
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.put_certificate(SLOT.AUTHENTICATION, cert)
+        reset_state(session)
+
+        assert session.get_certificate(SLOT.AUTHENTICATION)
+
+
+class TestManagementKeyReadOnly:
+    """
+    Tests after which the management key is always the default management
+    key. Placing compatible tests here reduces the amount of slow reset
+    calls needed.
+    """
+
+    def test_authenticate_twice_does_not_throw(self, session):
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+
+    def test_reset_resets_has_stored_key_flag(self, session):
+        pivman = get_pivman_data(session)
+        assert not pivman.has_stored_key
+
+        session.verify_pin(DEFAULT_PIN)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        pivman_set_mgm_key(
+            session,
+            NON_DEFAULT_MANAGEMENT_KEY,
+            MANAGEMENT_KEY_TYPE.TDES,
+            store_on_device=True,
+        )
+
+        pivman = get_pivman_data(session)
+        assert pivman.has_stored_key
+
+        reset_state(session)
+        session.reset()
+
+        pivman = get_pivman_data(session)
+        assert not pivman.has_stored_key
+
+    # Should this really fail?
+    def disabled_test_reset_while_verified_throws_nice_ValueError(self, session):
+        session.verify_pin(DEFAULT_PIN)
+        with pytest.raises(ValueError) as cm:
+            session.reset()
+        assert "Cannot read remaining tries from status word: 9000" in str(cm.exception)
+
+    def test_set_mgm_key_does_not_change_key_if_not_authenticated(self, session):
+        with pytest.raises(ApduError):
+            session.set_management_key(
+                MANAGEMENT_KEY_TYPE.TDES, NON_DEFAULT_MANAGEMENT_KEY
+            )
+        assert_mgm_key_is(session, DEFAULT_MANAGEMENT_KEY)
+
+    @condition.min_version(3, 5)
+    def test_set_stored_mgm_key_does_not_destroy_key_if_pin_not_verified(self, session):
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        with pytest.raises(ApduError):
+            pivman_set_mgm_key(
+                session,
+                NON_DEFAULT_MANAGEMENT_KEY,
+                MANAGEMENT_KEY_TYPE.TDES,
+                store_on_device=True,
+            )
+
+        assert_mgm_key_is(session, DEFAULT_MANAGEMENT_KEY)
+
+
+class TestManagementKeyReadWrite:
+    """
+    Tests after which the management key may not be the default management
+    key.
+    """
+
+    def test_set_mgm_key_changes_mgm_key(self, session):
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, NON_DEFAULT_MANAGEMENT_KEY)
+
+        assert_mgm_key_is_not(session, DEFAULT_MANAGEMENT_KEY)
+        assert_mgm_key_is(session, NON_DEFAULT_MANAGEMENT_KEY)
+
+    def test_set_stored_mgm_key_succeeds_if_pin_is_verified(self, session):
+        session.verify_pin(DEFAULT_PIN)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        pivman_set_mgm_key(
+            session,
+            NON_DEFAULT_MANAGEMENT_KEY,
+            MANAGEMENT_KEY_TYPE.TDES,
+            store_on_device=True,
+        )
+
+        assert_mgm_key_is_not(session, DEFAULT_MANAGEMENT_KEY)
+        assert_mgm_key_is(session, NON_DEFAULT_MANAGEMENT_KEY)
+
+        pivman_prot = get_pivman_protected_data(session)
+        assert pivman_prot.key == NON_DEFAULT_MANAGEMENT_KEY
+
+        pivman_prot = get_pivman_protected_data(session)
+        assert_mgm_key_is(session, pivman_prot.key)
+
+
+def sign(session, slot, key_type, message):
+    return session.sign(slot, key_type, message, hashes.SHA256(), padding.PKCS1v15())
+
+
+class TestOperations:
+    @condition.min_version(4)
+    def test_sign_with_pin_policy_always_requires_pin_every_time(self, session):
+        generate_key(session, pin_policy=PIN_POLICY.ALWAYS)
+
+        with pytest.raises(ApduError):
+            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+
+        session.verify_pin(DEFAULT_PIN)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+        with pytest.raises(ApduError):
+            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+
+        session.verify_pin(DEFAULT_PIN)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+    @condition.yk4_fips(False)
+    @condition.min_version(4)
+    def test_sign_with_pin_policy_never_does_not_require_pin(self, session):
+        generate_key(session, pin_policy=PIN_POLICY.NEVER)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+    @condition.yk4_fips(True)
+    def test_pin_policy_never_blocked_on_fips(self, session):
+        with pytest.raises(NotSupportedError):
+            generate_key(session, pin_policy=PIN_POLICY.NEVER)
+
+    @condition.min_version(4)
+    def test_sign_with_pin_policy_once_requires_pin_once_per_session(self, session):
+        generate_key(session, pin_policy=PIN_POLICY.ONCE)
+
+        with pytest.raises(ApduError):
+            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+
+        session.verify_pin(DEFAULT_PIN)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+        reset_state(session)
+
+        with pytest.raises(ApduError):
+            sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+
+        session.verify_pin(DEFAULT_PIN)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, b"foo")
+        assert sig
+
+    def test_signature_can_be_verified_by_public_key(self, session):
+        public_key = generate_key(session)
+
+        signed_data = bytes(random.randint(0, 255) for i in range(32))
+
+        session.verify_pin(DEFAULT_PIN)
+        sig = sign(session, SLOT.AUTHENTICATION, KEY_TYPE.ECCP256, signed_data)
+        assert sig
+
+        public_key.verify(sig, signed_data, ec.ECDSA(hashes.SHA256()))
+
+
+def block_pin(session):
+    while session.get_pin_attempts() > 0:
+        try:
+            session.verify_pin(NON_DEFAULT_PIN)
+        except Exception:
+            pass
+
+
+class TestUnblockPin:
+    def test_unblock_pin_requires_no_previous_authentication(self, session):
+        session.unblock_pin(DEFAULT_PUK, NON_DEFAULT_PIN)
+
+    def test_unblock_pin_with_wrong_puk_throws_InvalidPinError(self, session):
+        with pytest.raises(InvalidPinError):
+            session.unblock_pin(NON_DEFAULT_PUK, NON_DEFAULT_PIN)
+
+    def test_unblock_pin_resets_pin_and_retries(self, session):
+        session.reset()
+        reset_state(session)
+
+        block_pin(session)
+
+        with pytest.raises(InvalidPinError):
+            session.verify_pin(DEFAULT_PIN)
+
+        session.unblock_pin(DEFAULT_PUK, NON_DEFAULT_PIN)
+
+        assert session.get_pin_attempts() == 3
+        session.verify_pin(NON_DEFAULT_PIN)
+
+    def test_set_pin_retries_requires_pin_and_mgm_key(self, session):
+        # Fails with no authentication
+        with pytest.raises(ApduError):
+            session.set_pin_attempts(4, 4)
+
+        # Fails with only PIN
+        session.verify_pin(DEFAULT_PIN)
+        with pytest.raises(ApduError):
+            session.set_pin_attempts(4, 4)
+
+        reset_state(session)
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        # Fails with only management key (requirement added in 0.1.3)
+        if session.version >= (0, 1, 3):
+            with pytest.raises(ApduError):
+                session.set_pin_attempts(4, 4)
+
+        # Succeeds with both PIN and management key
+        session.verify_pin(DEFAULT_PIN)
+        session.set_pin_attempts(4, 4)
+
+    def test_set_pin_retries_sets_pin_and_puk_tries(self, session):
+        pin_tries = 9
+        puk_tries = 7
+
+        session.verify_pin(DEFAULT_PIN)
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.set_pin_attempts(pin_tries, puk_tries)
+
+        reset_state(session)
+
+        assert session.get_pin_attempts() == pin_tries
+        with pytest.raises(InvalidPinError) as ctx:
+            session.change_puk(NON_DEFAULT_PUK, DEFAULT_PUK)
+        assert ctx.value.attempts_remaining == puk_tries - 1
+
+
+class TestMetadata:
+    @pytest.fixture(autouse=True)
+    @condition.min_version(5, 3)
+    def preconditions(self):
+        pass
+
+    def test_pin_metadata(self, session):
+        data = session.get_pin_metadata()
+        assert data.default_value is True
+        assert data.total_attempts == 3
+        assert data.attempts_remaining == 3
+
+    def test_management_key_metadata(self, session):
+        data = session.get_management_key_metadata()
+        assert data.key_type == MANAGEMENT_KEY_TYPE.TDES
+        assert data.default_value is True
+        assert data.touch_policy is TOUCH_POLICY.NEVER
+
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.set_management_key(
+            MANAGEMENT_KEY_TYPE.AES192, NON_DEFAULT_MANAGEMENT_KEY
+        )
+        data = session.get_management_key_metadata()
+        assert data.key_type == MANAGEMENT_KEY_TYPE.AES192
+        assert data.default_value is False
+        assert data.touch_policy is TOUCH_POLICY.NEVER
+
+        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        data = session.get_management_key_metadata()
+        assert data.default_value is True
+
+        session.set_management_key(MANAGEMENT_KEY_TYPE.AES192, DEFAULT_MANAGEMENT_KEY)
+        data = session.get_management_key_metadata()
+        assert data.default_value is False
+
+    @pytest.mark.parametrize("key_type", list(KEY_TYPE))
+    def test_slot_metadata_generate(self, session, key_type):
+        slot = SLOT.SIGNATURE
+        key = generate_key(session, slot, key_type)
+        data = session.get_slot_metadata(slot)
+
+        assert data.key_type == key_type
+        assert data.pin_policy == PIN_POLICY.ALWAYS
+        assert data.touch_policy == TOUCH_POLICY.NEVER
+        assert data.generated is True
+        assert data.public_key.public_bytes(
+            encoding=serialization.Encoding.DER,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        ) == key.public_bytes(
+            encoding=serialization.Encoding.DER,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+
+    @pytest.mark.parametrize(
+        "key",
+        [
+            rsa.generate_private_key(65537, 1024, default_backend()),
+            rsa.generate_private_key(65537, 2048, default_backend()),
+            ec.generate_private_key(ec.SECP256R1(), default_backend()),
+            ec.generate_private_key(ec.SECP384R1(), default_backend()),
+        ],
+    )
+    @pytest.mark.parametrize(
+        "slot, pin_policy",
+        [
+            (SLOT.AUTHENTICATION, PIN_POLICY.ONCE),
+            (SLOT.SIGNATURE, PIN_POLICY.ALWAYS),
+            (SLOT.KEY_MANAGEMENT, PIN_POLICY.ONCE),
+            (SLOT.CARD_AUTH, PIN_POLICY.NEVER),
+        ],
+    )
+    def test_slot_metadata_put(self, session, key, slot, pin_policy):
+        session.authenticate(MANAGEMENT_KEY_TYPE.TDES, DEFAULT_MANAGEMENT_KEY)
+        session.put_key(slot, key)
+        data = session.get_slot_metadata(slot)
+
+        assert data.key_type == KEY_TYPE.from_public_key(key.public_key())
+        assert data.pin_policy == pin_policy
+        assert data.touch_policy == TOUCH_POLICY.NEVER
+        assert data.generated is False
+        assert data.public_key.public_bytes(
+            encoding=serialization.Encoding.DER,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        ) == key.public_key().public_bytes(
+            encoding=serialization.Encoding.DER,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
```

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_1024_key.pem` & `yubikey_manager-5.1.1/tests/files/rsa_1024_key.pem`

 * *Files 20% similar despite different names*

```diff
@@ -1,56 +1,57 @@
 00000000: 2d2d 2d2d 2d42 4547 494e 2052 5341 2050  -----BEGIN RSA P
-00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0a  RIVATE KEY-----.
-00000020: 4d49 4943 5777 4942 4141 4b42 6751 4447  MIICWwIBAAKBgQDG
-00000030: 4151 6138 6554 3554 3946 6a53 5032 5863  AQa8eT5T9FjSP2Xc
-00000040: 772f 756a 354c 5a72 7135 2f68 6470 4547  w/uj5LZrq5/hdpEG
-00000050: 4737 584f 3130 4966 5079 3077 6277 7150  G7XO10IfPy0wbwqP
-00000060: 0a6a 2b6f 6d61 4378 4a6c 4150 5875 7846  .j+omaCxJlAPXuxF
-00000070: 7930 6359 464e 516c 616e 6749 7530 4841  y0cYFNQlangIu0HA
-00000080: 4a2f 544d 415a 5850 4a4c 4253 5277 644b  J/TMAZXPJLBSRwdK
-00000090: 3758 2f61 5a6e 2f44 7332 7652 4e41 6370  7X/aZn/Ds2vRNAcp
-000000a0: 350a 6176 2b50 796d 3963 666e 6667 4d6f  5.av+Pym9cfnfgMo
-000000b0: 532b 3643 7662 554d 4164 754c 687a 726e  S+6CvbUMAduLhzrn
-000000c0: 6834 7451 7634 6c62 2f41 6b6c 696f 6d48  h4tQv4lb/AkliomH
-000000d0: 756f 637a 6462 6357 4876 4b77 4944 4151  uoczdbcWHvKwIDAQ
-000000e0: 4142 0a41 6f47 4158 7a78 7249 7767 6d42  AB.AoGAXzxrIwgmB
-000000f0: 4865 4971 5565 3546 4f42 6e44 734f 5a51  HeIqUe5FOBnDsOZQ
-00000100: 6c79 4151 412b 7058 596a 4366 3852 6c6c  lyAQA+pXYjCf8Rll
-00000110: 3258 7074 4677 5564 6b7a 4155 4d7a 5755  2XptFwUdkzAUMzWU
-00000120: 4757 540a 4735 5a73 7041 396c 3857 6337  GWT.G5ZspA9l8Wc7
-00000130: 496f 7a52 652f 6268 6a4d 7875 564b 3579  IozRe/bhjMxuVK5y
-00000140: 5a68 5044 4b62 6a71 5264 5749 4341 3935  ZhPDKbjqRdWICA95
-00000150: 4a64 3766 786c 4969 7248 4f56 4d51 5264  Jd7fxlIirHOVMQRd
-00000160: 7a49 3778 0a4e 4b71 4d4e 514e 3035 4d4c  zI7x.NKqMNQN05ML
-00000170: 4a66 7345 4855 5974 4f4c 685a 452b 7466  JfsEHUYtOLhZE+tf
-00000180: 684a 544a 6e6e 6d42 3754 4d77 6e4a 6763  hJTJnnmB7TMwnJgc
-00000190: 344f 3545 4351 5144 386f 4f4a 3435 7479  4O5ECQQD8oOJ45ty
-000001a0: 7234 367a 630a 4f41 7436 616f 3750 6566  r46zc.OAt6ao7Pef
-000001b0: 564c 6957 3551 752b 5078 666f 486d 5a6d  VLiW5Qu+PxfoHmZm
-000001c0: 4456 3255 5171 654d 3558 745a 6734 4f39  DV2UQqeM5XtZg4O9
-000001d0: 3756 4253 7567 4f73 332b 7175 4964 4143  7VBSugOs3+quIdAC
-000001e0: 364c 6f74 596c 0a2f 364e 2b45 3479 3341  6LotYl./6N+E4y3A
-000001f0: 6b45 4179 4b57 4432 4a4e 4372 4167 746a  kEAyKWD2JNCrAgtj
-00000200: 6b32 6266 4631 4859 7432 3474 7138 2b71  k2bfF1HYt24tq8+q
-00000210: 3778 3265 6b33 2f63 5568 7177 496e 6b72  7x2ek3/cUhqwInkr
-00000220: 5a71 4f46 6f6b 650a 7833 2b79 4242 3837  ZqOFoke.x3+yBB87
-00000230: 3954 7555 4f61 6476 4258 6e64 674d 4848  9TuUOadvBXndgMHH
-00000240: 634a 514b 5341 4a6c 4c51 4a41 5852 7547  cJQKSAJlLQJAXRuG
-00000250: 6e48 7970 7441 6854 6530 3645 6e48 654e  nHyptAhTe06EnHeN
-00000260: 6274 5a4b 4736 3770 0a49 3451 3850 4a4d  btZKG67p.I4Q8PJM
-00000270: 646d 5362 2b5a 5a4b 5031 7639 7a50 5578  dmSb+ZZKP1v9zPUx
-00000280: 4762 2b4e 512b 7a33 4f6d 4631 5438 7070  Gb+NQ+z3OmF1T8pp
-00000290: 5566 382f 4456 392b 4b41 624d 344e 4931  Uf8/DV9+KAbM4NI1
-000002a0: 4c2f 514a 4164 4742 730a 424b 5946 4f62  L/QJAdGBs.BKYFOb
-000002b0: 7255 6b59 4535 2b66 7777 6434 7561 6f33  rUkYE5+fwwd4uao3
-000002c0: 7370 6f6e 7142 545a 6348 336a 4465 6d69  sponqBTZcH3jDemi
-000002d0: 5a67 324d 4359 5155 4875 3945 2b41 6452  Zg2MCYQUHu9E+AdR
-000002e0: 7559 727a 694c 564a 566b 0a73 3478 6e69  uYrziLVJVk.s4xni
-000002f0: 564c 6231 7452 4730 6c56 7855 514a 4153  VLb1tRG0lVxUQJAS
-00000300: 666a 6447 5438 3148 444a 537a 5473 6569  fjdGT81HDJSzTsei
-00000310: 6772 4d2b 4a6e 424b 5050 727a 7065 4570  grM+JnBKPPrzpeEp
-00000320: 3052 6254 5035 324c 6d32 330a 5941 526a  0RbTP52Lm23.YARj
-00000330: 4c43 776d 504d 4d64 4177 595a 7376 7165  LCwmPMMdAwYZsvqe
-00000340: 5475 4845 4451 634f 4878 4c48 5775 794e  TuHEDQcOHxLHWuyN
-00000350: 2f7a 6750 3241 3d3d 0a2d 2d2d 2d2d 454e  /zgP2A==.-----EN
-00000360: 4420 5253 4120 5052 4956 4154 4520 4b45  D RSA PRIVATE KE
-00000370: 592d 2d2d 2d2d 0a                        Y-----.
+00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0d  RIVATE KEY-----.
+00000020: 0a4d 4949 4357 7749 4241 414b 4267 5144  .MIICWwIBAAKBgQD
+00000030: 4741 5161 3865 5435 5439 466a 5350 3258  GAQa8eT5T9FjSP2X
+00000040: 6377 2f75 6a35 4c5a 7271 352f 6864 7045  cw/uj5LZrq5/hdpE
+00000050: 4747 3758 4f31 3049 6650 7930 7762 7771  GG7XO10IfPy0wbwq
+00000060: 500d 0a6a 2b6f 6d61 4378 4a6c 4150 5875  P..j+omaCxJlAPXu
+00000070: 7846 7930 6359 464e 516c 616e 6749 7530  xFy0cYFNQlangIu0
+00000080: 4841 4a2f 544d 415a 5850 4a4c 4253 5277  HAJ/TMAZXPJLBSRw
+00000090: 644b 3758 2f61 5a6e 2f44 7332 7652 4e41  dK7X/aZn/Ds2vRNA
+000000a0: 6370 350d 0a61 762b 5079 6d39 6366 6e66  cp5..av+Pym9cfnf
+000000b0: 674d 6f53 2b36 4376 6255 4d41 6475 4c68  gMoS+6CvbUMAduLh
+000000c0: 7a72 6e68 3474 5176 346c 622f 416b 6c69  zrnh4tQv4lb/Akli
+000000d0: 6f6d 4875 6f63 7a64 6263 5748 764b 7749  omHuoczdbcWHvKwI
+000000e0: 4441 5141 420d 0a41 6f47 4158 7a78 7249  DAQAB..AoGAXzxrI
+000000f0: 7767 6d42 4865 4971 5565 3546 4f42 6e44  wgmBHeIqUe5FOBnD
+00000100: 734f 5a51 6c79 4151 412b 7058 596a 4366  sOZQlyAQA+pXYjCf
+00000110: 3852 6c6c 3258 7074 4677 5564 6b7a 4155  8Rll2XptFwUdkzAU
+00000120: 4d7a 5755 4757 540d 0a47 355a 7370 4139  MzWUGWT..G5ZspA9
+00000130: 6c38 5763 3749 6f7a 5265 2f62 686a 4d78  l8Wc7IozRe/bhjMx
+00000140: 7556 4b35 795a 6850 444b 626a 7152 6457  uVK5yZhPDKbjqRdW
+00000150: 4943 4139 354a 6437 6678 6c49 6972 484f  ICA95Jd7fxlIirHO
+00000160: 564d 5152 647a 4937 780d 0a4e 4b71 4d4e  VMQRdzI7x..NKqMN
+00000170: 514e 3035 4d4c 4a66 7345 4855 5974 4f4c  QN05MLJfsEHUYtOL
+00000180: 685a 452b 7466 684a 544a 6e6e 6d42 3754  hZE+tfhJTJnnmB7T
+00000190: 4d77 6e4a 6763 344f 3545 4351 5144 386f  MwnJgc4O5ECQQD8o
+000001a0: 4f4a 3435 7479 7234 367a 630d 0a4f 4174  OJ45tyr46zc..OAt
+000001b0: 3661 6f37 5065 6656 4c69 5735 5175 2b50  6ao7PefVLiW5Qu+P
+000001c0: 7866 6f48 6d5a 6d44 5632 5551 7165 4d35  xfoHmZmDV2UQqeM5
+000001d0: 5874 5a67 344f 3937 5642 5375 674f 7333  XtZg4O97VBSugOs3
+000001e0: 2b71 7549 6441 4336 4c6f 7459 6c0d 0a2f  +quIdAC6LotYl../
+000001f0: 364e 2b45 3479 3341 6b45 4179 4b57 4432  6N+E4y3AkEAyKWD2
+00000200: 4a4e 4372 4167 746a 6b32 6266 4631 4859  JNCrAgtjk2bfF1HY
+00000210: 7432 3474 7138 2b71 3778 3265 6b33 2f63  t24tq8+q7x2ek3/c
+00000220: 5568 7177 496e 6b72 5a71 4f46 6f6b 650d  UhqwInkrZqOFoke.
+00000230: 0a78 332b 7942 4238 3739 5475 554f 6164  .x3+yBB879TuUOad
+00000240: 7642 586e 6467 4d48 4863 4a51 4b53 414a  vBXndgMHHcJQKSAJ
+00000250: 6c4c 514a 4158 5275 476e 4879 7074 4168  lLQJAXRuGnHyptAh
+00000260: 5465 3036 456e 4865 4e62 745a 4b47 3637  Te06EnHeNbtZKG67
+00000270: 700d 0a49 3451 3850 4a4d 646d 5362 2b5a  p..I4Q8PJMdmSb+Z
+00000280: 5a4b 5031 7639 7a50 5578 4762 2b4e 512b  ZKP1v9zPUxGb+NQ+
+00000290: 7a33 4f6d 4631 5438 7070 5566 382f 4456  z3OmF1T8ppUf8/DV
+000002a0: 392b 4b41 624d 344e 4931 4c2f 514a 4164  9+KAbM4NI1L/QJAd
+000002b0: 4742 730d 0a42 4b59 464f 6272 556b 5945  GBs..BKYFObrUkYE
+000002c0: 352b 6677 7764 3475 616f 3373 706f 6e71  5+fwwd4uao3sponq
+000002d0: 4254 5a63 4833 6a44 656d 695a 6732 4d43  BTZcH3jDemiZg2MC
+000002e0: 5951 5548 7539 452b 4164 5275 5972 7a69  YQUHu9E+AdRuYrzi
+000002f0: 4c56 4a56 6b0d 0a73 3478 6e69 564c 6231  LVJVk..s4xniVLb1
+00000300: 7452 4730 6c56 7855 514a 4153 666a 6447  tRG0lVxUQJASfjdG
+00000310: 5438 3148 444a 537a 5473 6569 6772 4d2b  T81HDJSzTseigrM+
+00000320: 4a6e 424b 5050 727a 7065 4570 3052 6254  JnBKPPrzpeEp0RbT
+00000330: 5035 324c 6d32 330d 0a59 4152 6a4c 4377  P52Lm23..YARjLCw
+00000340: 6d50 4d4d 6441 7759 5a73 7671 6554 7548  mPMMdAwYZsvqeTuH
+00000350: 4544 5163 4f48 784c 4857 7579 4e2f 7a67  EDQcOHxLHWuyN/zg
+00000360: 5032 413d 3d0d 0a2d 2d2d 2d2d 454e 4420  P2A==..-----END 
+00000370: 5253 4120 5052 4956 4154 4520 4b45 592d  RSA PRIVATE KEY-
+00000380: 2d2d 2d2d 0d0a                           ----..
```

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_cert.der` & `yubikey_manager-5.1.1/tests/files/rsa_2048_cert.der`

 * *Files identical despite different names*

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_cert.pem` & `yubikey_manager-5.1.1/tests/files/rsa_2048_cert.pem`

 * *Files 13% similar despite different names*

```diff
@@ -1,66 +1,67 @@
 00000000: 2d2d 2d2d 2d42 4547 494e 2043 4552 5449  -----BEGIN CERTI
-00000010: 4649 4341 5445 2d2d 2d2d 2d0a 4d49 4943  FICATE-----.MIIC
-00000020: 326a 4343 416b 4d43 4167 3338 4d41 3047  2jCCAkMCAg38MA0G
-00000030: 4353 7147 5349 6233 4451 4542 4251 5541  CSqGSIb3DQEBBQUA
-00000040: 4d49 4762 4d51 7377 4351 5944 5651 5147  MIGbMQswCQYDVQQG
-00000050: 4577 4a4b 5544 454f 4d41 7747 0a41 3155  EwJKUDEOMAwG.A1U
-00000060: 4543 424d 4656 4739 7265 5738 7845 4441  ECBMFVG9reW8xEDA
-00000070: 4f42 674e 5642 4163 5442 304e 6f64 5738  OBgNVBAcTB0NodW8
-00000080: 7461 3355 7845 5441 5042 674e 5642 416f  ta3UxETAPBgNVBAo
-00000090: 5443 455a 7959 5735 724e 4552 450a 4d52  TCEZyYW5rNERE.MR
-000000a0: 6777 4667 5944 5651 514c 4577 3958 5a57  gwFgYDVQQLEw9XZW
-000000b0: 4a44 5a58 4a30 4946 4e31 6348 4276 636e  JDZXJ0IFN1cHBvcn
-000000c0: 5178 4744 4157 4267 4e56 4241 4d54 4430  QxGDAWBgNVBAMTD0
-000000d0: 5a79 5957 3572 4e45 5245 4946 646c 0a59  ZyYW5rNEREIFdl.Y
-000000e0: 6942 4451 5445 6a4d 4345 4743 5371 4753  iBDQTEjMCEGCSqGS
-000000f0: 4962 3344 5145 4a41 5259 5563 3356 7763  Ib3DQEJARYUc3Vwc
-00000100: 4739 7964 4542 6d63 6d46 7561 7a52 6b5a  G9ydEBmcmFuazRkZ
-00000110: 4335 6a62 3230 7748 6863 4e4d 5449 770a  C5jb20wHhcNMTIw.
-00000120: 4f44 4979 4d44 5579 4e7a 5178 5768 634e  ODIyMDUyNzQxWhcN
-00000130: 4d54 6377 4f44 4978 4d44 5579 4e7a 5178  MTcwODIxMDUyNzQx
-00000140: 576a 424b 4d51 7377 4351 5944 5651 5147  WjBKMQswCQYDVQQG
-00000150: 4577 4a4b 5544 454f 4d41 7747 4131 5545  EwJKUDEOMAwGA1UE
-00000160: 0a43 4177 4656 4739 7265 5738 7845 5441  .CAwFVG9reW8xETA
-00000170: 5042 674e 5642 416f 4d43 455a 7959 5735  PBgNVBAoMCEZyYW5
-00000180: 724e 4552 454d 5267 7746 6759 4456 5151  rNEREMRgwFgYDVQQ
-00000190: 4444 4139 3364 3363 755a 5868 6862 5842  DDA93d3cuZXhhbXB
-000001a0: 730a 5a53 356a 6232 3077 6767 4569 4d41  s.ZS5jb20wggEiMA
-000001b0: 3047 4353 7147 5349 6233 4451 4542 4151  0GCSqGSIb3DQEBAQ
-000001c0: 5541 4134 4942 4477 4177 6767 454b 416f  UAA4IBDwAwggEKAo
-000001d0: 4942 4151 4330 7a39 4665 4d79 6e73 4338  IBAQC0z9FeMynsC8
-000001e0: 2b75 0a64 7658 2b4c 6369 5a78 6e68 3575  +u.dvX+LciZxnh5u
-000001f0: 526a 3443 3953 3674 4e65 6541 6c49 4743  Rj4C9S6tNeeAlIGC
-00000200: 6651 596b 307a 5563 4e46 436f 436b 546b  fQYk0zUcNFCoCkTk
-00000210: 6e4e 5164 2f59 4569 6177 444c 4e62 7842  nNQd/YEiawDLNbxB
-00000220: 7175 740a 624d 445a 3161 6172 7973 3161  qut.bMDZ1aarys1a
-00000230: 306c 596d 5565 564c 4349 7176 7a42 6b50  0lYmUeVLCIqvzBkP
-00000240: 4a54 5351 7343 6f70 5151 3956 3857 7554  JTSQsCopQQ9V8WuT
-00000250: 3235 327a 7a4e 7a73 3638 6456 474e 6443  252zzNzs68dVGNdC
-00000260: 4a64 354a 0a4e 5251 796b 7077 6578 6d6e  Jd5J.NRQykpwexmn
-00000270: 6a50 5076 306d 766a 3769 3858 6747 3337  jPPv0mvj7i8XgG37
-00000280: 3954 7957 3650 2b57 5756 356f 6b65 556b  9TyW6P+WWV5okeUk
-00000290: 584a 3965 4a53 326f 7544 5964 5232 534d  XJ9eJS2ouDYdR2SM
-000002a0: 3942 6f56 570a 2b46 6778 4475 3642 6d58  9BoVW.+FgxDu6BmX
-000002b0: 686f 7a57 3545 6673 6e61 6a46 7037 484c  hozW5EfsnajFp7HL
-000002c0: 386b 5143 6c49 3051 4f63 3739 7975 4b6c  8kQClI0QOc79yuKl
-000002d0: 3334 3932 7248 3662 7a46 7346 6e32 6c66  3492rH6bzFsFn2lf
-000002e0: 7757 7939 6963 0a37 6350 3845 7043 5465  wWy9ic.7cP8EpCTe
-000002f0: 4670 3174 4661 442b 7678 4268 505a 6b65  Fp1tFaD+vxBhPZke
-00000300: 5451 3148 4b78 3668 5135 7a65 4849 4235  TQ1HKx6hQ5zeHIB5
-00000310: 7953 4a4a 5a37 6166 3257 3872 3465 5447  ySJJZ7af2W8r4eTG
-00000320: 597a 6264 5257 320a 3444 4448 4350 685a  YzbdRW2.4DDHCPhZ
-00000330: 4167 4d42 4141 4577 4451 594a 4b6f 5a49  AgMBAAEwDQYJKoZI
-00000340: 6876 634e 4151 4546 4251 4144 6759 4541  hvcNAQEFBQADgYEA
-00000350: 514d 762b 4246 7647 644d 567a 6b51 6151  QMv+BFvGdMVzkQaQ
-00000360: 332f 2b32 6e6f 567a 0a2f 7541 4b62 7a70  3/+2noVz./uAKbzp
-00000370: 454c 3878 5463 7859 7950 336c 6b4f 6568  EL8xTcxYyP3lkOeh
-00000380: 3446 6f78 6953 5771 7935 7047 4641 4c64  4FoxiSWqy5pGFALd
-00000390: 504f 4e6f 4475 5946 704c 686a 4a53 5a61  PONoDuYFpLhjJSZa
-000003a0: 4577 7576 6a49 2f54 720a 7247 684c 5631  EwuvjI/Tr.rGhLV1
-000003b0: 7052 4739 6672 7744 4673 6871 4432 5661  pRG9frwDFshqD2Va
-000003c0: 6a34 454e 4243 4268 3655 7065 426f 7035  j4ENBCBh6UpeBop5
-000003d0: 2b32 3835 7a51 3453 4937 7134 5539 6f53  +285zQ4SI7q4U9oS
-000003e0: 6562 5544 4a69 754f 7836 0a2b 745a 394b  ebUDJiuOx6.+tZ9K
-000003f0: 796e 6d72 624a 7054 5369 302b 424d 3d0a  ynmrbJpTSi0+BM=.
-00000400: 2d2d 2d2d 2d45 4e44 2043 4552 5449 4649  -----END CERTIFI
-00000410: 4341 5445 2d2d 2d2d 2d0a                 CATE-----.
+00000010: 4649 4341 5445 2d2d 2d2d 2d0d 0a4d 4949  FICATE-----..MII
+00000020: 4332 6a43 4341 6b4d 4341 6733 384d 4130  C2jCCAkMCAg38MA0
+00000030: 4743 5371 4753 4962 3344 5145 4242 5155  GCSqGSIb3DQEBBQU
+00000040: 414d 4947 624d 5173 7743 5159 4456 5151  AMIGbMQswCQYDVQQ
+00000050: 4745 774a 4b55 4445 4f4d 4177 470d 0a41  GEwJKUDEOMAwG..A
+00000060: 3155 4543 424d 4656 4739 7265 5738 7845  1UECBMFVG9reW8xE
+00000070: 4441 4f42 674e 5642 4163 5442 304e 6f64  DAOBgNVBAcTB0Nod
+00000080: 5738 7461 3355 7845 5441 5042 674e 5642  W8ta3UxETAPBgNVB
+00000090: 416f 5443 455a 7959 5735 724e 4552 450d  AoTCEZyYW5rNERE.
+000000a0: 0a4d 5267 7746 6759 4456 5151 4c45 7739  .MRgwFgYDVQQLEw9
+000000b0: 585a 574a 445a 584a 3049 464e 3163 4842  XZWJDZXJ0IFN1cHB
+000000c0: 7663 6e51 7847 4441 5742 674e 5642 414d  vcnQxGDAWBgNVBAM
+000000d0: 5444 305a 7959 5735 724e 4552 4549 4664  TD0ZyYW5rNEREIFd
+000000e0: 6c0d 0a59 6942 4451 5445 6a4d 4345 4743  l..YiBDQTEjMCEGC
+000000f0: 5371 4753 4962 3344 5145 4a41 5259 5563  SqGSIb3DQEJARYUc
+00000100: 3356 7763 4739 7964 4542 6d63 6d46 7561  3VwcG9ydEBmcmFua
+00000110: 7a52 6b5a 4335 6a62 3230 7748 6863 4e4d  zRkZC5jb20wHhcNM
+00000120: 5449 770d 0a4f 4449 794d 4455 794e 7a51  TIw..ODIyMDUyNzQ
+00000130: 7857 6863 4e4d 5463 774f 4449 784d 4455  xWhcNMTcwODIxMDU
+00000140: 794e 7a51 7857 6a42 4b4d 5173 7743 5159  yNzQxWjBKMQswCQY
+00000150: 4456 5151 4745 774a 4b55 4445 4f4d 4177  DVQQGEwJKUDEOMAw
+00000160: 4741 3155 450d 0a43 4177 4656 4739 7265  GA1UE..CAwFVG9re
+00000170: 5738 7845 5441 5042 674e 5642 416f 4d43  W8xETAPBgNVBAoMC
+00000180: 455a 7959 5735 724e 4552 454d 5267 7746  EZyYW5rNEREMRgwF
+00000190: 6759 4456 5151 4444 4139 3364 3363 755a  gYDVQQDDA93d3cuZ
+000001a0: 5868 6862 5842 730d 0a5a 5335 6a62 3230  XhhbXBs..ZS5jb20
+000001b0: 7767 6745 694d 4130 4743 5371 4753 4962  wggEiMA0GCSqGSIb
+000001c0: 3344 5145 4241 5155 4141 3449 4244 7741  3DQEBAQUAA4IBDwA
+000001d0: 7767 6745 4b41 6f49 4241 5143 307a 3946  wggEKAoIBAQC0z9F
+000001e0: 654d 796e 7343 382b 750d 0a64 7658 2b4c  eMynsC8+u..dvX+L
+000001f0: 6369 5a78 6e68 3575 526a 3443 3953 3674  ciZxnh5uRj4C9S6t
+00000200: 4e65 6541 6c49 4743 6651 596b 307a 5563  NeeAlIGCfQYk0zUc
+00000210: 4e46 436f 436b 546b 6e4e 5164 2f59 4569  NFCoCkTknNQd/YEi
+00000220: 6177 444c 4e62 7842 7175 740d 0a62 4d44  awDLNbxBqut..bMD
+00000230: 5a31 6161 7279 7331 6130 6c59 6d55 6556  Z1aarys1a0lYmUeV
+00000240: 4c43 4971 767a 426b 504a 5453 5173 436f  LCIqvzBkPJTSQsCo
+00000250: 7051 5139 5638 5775 5432 3532 7a7a 4e7a  pQQ9V8WuT252zzNz
+00000260: 7336 3864 5647 4e64 434a 6435 4a0d 0a4e  s68dVGNdCJd5J..N
+00000270: 5251 796b 7077 6578 6d6e 6a50 5076 306d  RQykpwexmnjPPv0m
+00000280: 766a 3769 3858 6747 3337 3954 7957 3650  vj7i8XgG379TyW6P
+00000290: 2b57 5756 356f 6b65 556b 584a 3965 4a53  +WWV5okeUkXJ9eJS
+000002a0: 326f 7544 5964 5232 534d 3942 6f56 570d  2ouDYdR2SM9BoVW.
+000002b0: 0a2b 4667 7844 7536 426d 5868 6f7a 5735  .+FgxDu6BmXhozW5
+000002c0: 4566 736e 616a 4670 3748 4c38 6b51 436c  EfsnajFp7HL8kQCl
+000002d0: 4930 514f 6337 3979 754b 6c33 3439 3272  I0QOc79yuKl3492r
+000002e0: 4836 627a 4673 466e 326c 6677 5779 3969  H6bzFsFn2lfwWy9i
+000002f0: 630d 0a37 6350 3845 7043 5465 4670 3174  c..7cP8EpCTeFp1t
+00000300: 4661 442b 7678 4268 505a 6b65 5451 3148  FaD+vxBhPZkeTQ1H
+00000310: 4b78 3668 5135 7a65 4849 4235 7953 4a4a  Kx6hQ5zeHIB5ySJJ
+00000320: 5a37 6166 3257 3872 3465 5447 597a 6264  Z7af2W8r4eTGYzbd
+00000330: 5257 320d 0a34 4444 4843 5068 5a41 674d  RW2..4DDHCPhZAgM
+00000340: 4241 4145 7744 5159 4a4b 6f5a 4968 7663  BAAEwDQYJKoZIhvc
+00000350: 4e41 5145 4642 5141 4467 5945 4151 4d76  NAQEFBQADgYEAQMv
+00000360: 2b42 4676 4764 4d56 7a6b 5161 5133 2f2b  +BFvGdMVzkQaQ3/+
+00000370: 326e 6f56 7a0d 0a2f 7541 4b62 7a70 454c  2noVz../uAKbzpEL
+00000380: 3878 5463 7859 7950 336c 6b4f 6568 3446  8xTcxYyP3lkOeh4F
+00000390: 6f78 6953 5771 7935 7047 4641 4c64 504f  oxiSWqy5pGFALdPO
+000003a0: 4e6f 4475 5946 704c 686a 4a53 5a61 4577  NoDuYFpLhjJSZaEw
+000003b0: 7576 6a49 2f54 720d 0a72 4768 4c56 3170  uvjI/Tr..rGhLV1p
+000003c0: 5247 3966 7277 4446 7368 7144 3256 616a  RG9frwDFshqD2Vaj
+000003d0: 3445 4e42 4342 6836 5570 6542 6f70 352b  4ENBCBh6UpeBop5+
+000003e0: 3238 357a 5134 5349 3771 3455 396f 5365  285zQ4SI7q4U9oSe
+000003f0: 6255 444a 6975 4f78 360d 0a2b 745a 394b  bUDJiuOx6..+tZ9K
+00000400: 796e 6d72 624a 7054 5369 302b 424d 3d0d  ynmrbJpTSi0+BM=.
+00000410: 0a2d 2d2d 2d2d 454e 4420 4345 5254 4946  .-----END CERTIF
+00000420: 4943 4154 452d 2d2d 2d2d 0d0a            ICATE-----..
```

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_cert_metadata.pem` & `yubikey_manager-5.1.1/tests/files/rsa_2048_cert_metadata.pem`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-Subject: Subject Name
-Another comment
------BEGIN CERTIFICATE-----
-MIIC2jCCAkMCAg38MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
-A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
-MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
-YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
-ODIyMDUyNzQxWhcNMTcwODIxMDUyNzQxWjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
-CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
-ZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC0z9FeMynsC8+u
-dvX+LciZxnh5uRj4C9S6tNeeAlIGCfQYk0zUcNFCoCkTknNQd/YEiawDLNbxBqut
-bMDZ1aarys1a0lYmUeVLCIqvzBkPJTSQsCopQQ9V8WuT252zzNzs68dVGNdCJd5J
-NRQykpwexmnjPPv0mvj7i8XgG379TyW6P+WWV5okeUkXJ9eJS2ouDYdR2SM9BoVW
-+FgxDu6BmXhozW5EfsnajFp7HL8kQClI0QOc79yuKl3492rH6bzFsFn2lfwWy9ic
-7cP8EpCTeFp1tFaD+vxBhPZkeTQ1HKx6hQ5zeHIB5ySJJZ7af2W8r4eTGYzbdRW2
-4DDHCPhZAgMBAAEwDQYJKoZIhvcNAQEFBQADgYEAQMv+BFvGdMVzkQaQ3/+2noVz
-/uAKbzpEL8xTcxYyP3lkOeh4FoxiSWqy5pGFALdPONoDuYFpLhjJSZaEwuvjI/Tr
-rGhLV1pRG9frwDFshqD2Vaj4ENBCBh6UpeBop5+285zQ4SI7q4U9oSebUDJiuOx6
-+tZ9KynmrbJpTSi0+BM=
------END CERTIFICATE-----
+Subject: Subject Name
+Another comment
+-----BEGIN CERTIFICATE-----
+MIIC2jCCAkMCAg38MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG
+A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE
+MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl
+YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw
+ODIyMDUyNzQxWhcNMTcwODIxMDUyNzQxWjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE
+CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs
+ZS5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC0z9FeMynsC8+u
+dvX+LciZxnh5uRj4C9S6tNeeAlIGCfQYk0zUcNFCoCkTknNQd/YEiawDLNbxBqut
+bMDZ1aarys1a0lYmUeVLCIqvzBkPJTSQsCopQQ9V8WuT252zzNzs68dVGNdCJd5J
+NRQykpwexmnjPPv0mvj7i8XgG379TyW6P+WWV5okeUkXJ9eJS2ouDYdR2SM9BoVW
++FgxDu6BmXhozW5EfsnajFp7HL8kQClI0QOc79yuKl3492rH6bzFsFn2lfwWy9ic
+7cP8EpCTeFp1tFaD+vxBhPZkeTQ1HKx6hQ5zeHIB5ySJJZ7af2W8r4eTGYzbdRW2
+4DDHCPhZAgMBAAEwDQYJKoZIhvcNAQEFBQADgYEAQMv+BFvGdMVzkQaQ3/+2noVz
+/uAKbzpEL8xTcxYyP3lkOeh4FoxiSWqy5pGFALdPONoDuYFpLhjJSZaEwuvjI/Tr
+rGhLV1pRG9frwDFshqD2Vaj4ENBCBh6UpeBop5+285zQ4SI7q4U9oSebUDJiuOx6
++tZ9KynmrbJpTSi0+BM=
+-----END CERTIFICATE-----
```

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_key.pem` & `yubikey_manager-5.1.1/tests/files/rsa_2048_key.pem`

 * *Files 16% similar despite different names*

```diff
@@ -1,105 +1,107 @@
 00000000: 2d2d 2d2d 2d42 4547 494e 2052 5341 2050  -----BEGIN RSA P
-00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0a  RIVATE KEY-----.
-00000020: 4d49 4945 7041 4942 4141 4b43 4151 4541  MIIEpAIBAAKCAQEA
-00000030: 356c 747a 5155 7247 556b 6c4d 7453 5846  5ltzQUrGUklMtSXF
-00000040: 4847 3762 6234 4263 5134 5550 4370 5630  HG7bb4BcQ4UPCpV0
-00000050: 3958 396f 5543 764f 742f 4971 5536 4742  9X9oUCvOt/IqU6GB
-00000060: 0a62 4748 6234 4b36 495a 6346 6933 4a64  .bGHb4K6IZcFi3Jd
-00000070: 2f33 4c4b 6b6e 4e6d 5633 7771 3136 4a6a  /3LKknNmV3wq16Jj
-00000080: 7663 3338 2f76 7450 6c73 492b 6877 3733  vc38/vtPlsI+hw73
-00000090: 3349 3464 3733 6665 7952 2f2b 4e48 742f  3I4d73feyR/+NHt/
-000000a0: 650a 644c 3970 6d53 416a 5379 7569 3648  e.dL9pmSAjSyui6H
-000000b0: 592f 4364 752b 4761 6364 386c 4465 6b41  Y/Cdu+Gacd8lDekA
-000000c0: 652f 486e 646e 395a 3445 3965 6974 546b  e/Hndn9Z4E9eitTk
-000000d0: 436a 5177 664a 756c 5a67 3141 7146 4e55  CjQwfJulZg1AqFNU
-000000e0: 7869 0a79 6549 784a 5054 4638 7854 4878  xi.yeIxJPTF8xTHx
-000000f0: 674c 6958 4575 4b2b 7838 676d 7531 6b70  gLiXEuK+x8gmu1kp
-00000100: 5431 615a 6f2b 2b4d 7146 7356 2b50 4875  T1aZo++MqFsV+PHu
-00000110: 6836 7753 724f 364b 314c 474a 414d 644f  h6wSrO6K1LGJAMdO
-00000120: 5957 630a 4972 4166 4936 7a38 6765 4b72  YWc.IrAfI6z8geKr
-00000130: 4537 5864 5864 7955 776f 664a 4e4e 3871  E7XdXdyUwofJNN8q
-00000140: 6474 7877 6c34 7a33 3341 6632 662f 3075  dtxwl4z33Af2f/0u
-00000150: 4c58 3977 4e4e 6173 6d68 3867 412f 4c53  LX9wNNasmh8gA/LS
-00000160: 5859 584a 0a56 4570 3876 4635 504e 6b46  XYXJ.VEp8vF5PNkF
-00000170: 3157 462f 3450 716f 7545 7976 4776 504a  1WF/4PqouEyvGvPJ
-00000180: 4263 6178 5737 7366 3668 5149 4441 5141  BcaxW7sf6hQIDAQA
-00000190: 4241 6f49 4241 4475 6431 5646 4469 646f  BAoIBADud1VFDido
-000001a0: 4838 4673 390a 5943 7341 6f62 6655 7234  H8Fs9.YCsAobfUr4
-000001b0: 776c 356f 4f6c 7448 5249 7566 5674 7350  wl5oOltHRIufVtsP
-000001c0: 3034 4a69 346f 7354 6363 6947 7734 6e30  04Ji4osTcciGw4n0
-000001d0: 492b 6231 694a 754f 536b 4d79 6749 7739  I+b1iJuOSkMygIw9
-000001e0: 6e4b 6974 4f63 0a71 5050 714c 6451 3051  nKitOc.qPPqLdQ0Q
-000001f0: 4e43 5743 355a 2b46 6e54 5366 6f4d 7574  NCWC5Z+FnTSfoMut
-00000200: 4b77 6666 6956 4d61 4f55 7347 4b63 7867  KwffiVMaOUsGKcxg
-00000210: 7844 5552 5541 4751 6b42 4a35 3450 3646  xDURUAGQkBJ54P6F
-00000220: 537a 2b4d 7574 780a 7063 7537 7557 4c2b  Sz+Mutx.pcu7uWL+
-00000230: 7432 6678 424e 456f 7431 6745 7276 6554  t2fxBNEot1gErveT
-00000240: 6e56 4769 7661 306c 582b 7854 514d 3863  nVGiva0lX+xTQM8c
-00000250: 2b47 6863 6535 4958 4872 6a46 4439 456d  +Ghce5IXHrjFD9Em
-00000260: 374d 752b 316d 6d73 0a4f 5978 6c69 6e77  7Mu+1mms.OYxlinw
-00000270: 6655 5176 6776 614a 4172 486d 4b4b 4f47  fUQvgvaJArHmKKOG
-00000280: 6d47 392f 6e77 4e49 7252 7576 5143 5748  mG9/nwNIrRuvQCWH
-00000290: 6656 536a 3066 6545 7562 4661 5a49 7848  fVSj0feEubFaZIxH
-000002a0: 5252 5533 6b32 314f 420a 3531 6b6e 7742  RRU3k21OB.51knwB
-000002b0: 5068 3676 4477 5132 6b73 7179 5776 5279  Ph6vDwQ2ksqyWvRy
-000002c0: 7368 7130 4573 574e 754c 5435 6c32 2b5a  shq0EsWNuLT5l2+Z
-000002d0: 6231 432b 4e58 7771 6838 2f53 6c78 7a48  b1C+NXwqh8/SlxzH
-000002e0: 5571 6933 4c62 4b34 4767 0a4d 5250 4568  Uqi3LbK4Gg.MRPEh
-000002f0: 4f30 4367 5945 4139 5350 4577 6532 4d43  O0CgYEA9SPEwe2MC
-00000300: 4f76 336f 6e70 4657 4a4f 7473 4275 6c79  Ov3onpFWJOtsBuly
-00000310: 724c 6564 2b4d 7a56 6244 7152 4332 3959  rLed+MzVbDqRC29Y
-00000320: 3350 6a48 4666 7462 366d 690a 3244 6830  3PjHFftb6mi.2Dh0
-00000330: 4c70 6b6a 6f46 6547 412b 4c32 394a 5a4a  LpkjoFeGA+L29JZJ
-00000340: 6e71 666b 6856 4c62 752b 357a 384c 4236  nqfkhVLbu+5z8LB6
-00000350: 5a2f 7a65 6d34 457a 7858 4d78 5132 6238  Z/zem4EzxXMxQ2b8
-00000360: 6839 4d6e 624a 5159 7144 4867 0a58 7131  h9MnbJQYqDHg.Xq1
-00000370: 5865 566d 7850 4a4d 4b4e 3637 4f38 7535  XeVmxPJMKN67O8u5
-00000380: 6b75 3139 6176 3576 5a48 4771 3051 3635  ku19av5vZHGq0Q65
-00000390: 6e6c 6e37 3755 694b 7745 4e44 3534 446f  nln77UiKwEND54Do
-000003a0: 4f42 7563 4367 5945 4138 4a41 470a 2b49  OBucCgYEA8JAG.+I
-000003b0: 4e4d 4d59 5041 414a 496a 6857 4156 3855  NMMYPAAJIjhWAV8U
-000003c0: 6269 5930 4952 6370 452b 6549 7062 3467  biY0IRcpE+eIpb4g
-000003d0: 6a57 6d50 6369 736b 7a78 4c4b 416a 6564  jWmPciskzxLKAjed
-000003e0: 7251 784a 7977 6562 7531 3272 3872 0a49  rQxJywebu12r8r.I
-000003f0: 4832 7265 6476 6654 5379 6544 5748 3164  H2redvfTSyeDWH1d
-00000400: 416a 326e 3731 5731 3466 6c5a 5468 6250  Aj2n71W14flZThbP
-00000410: 6d6b 536c 6235 674f 3252 3077 4568 4477  mkSlb5gO2R0wEhDw
-00000420: 3270 5564 5442 5474 6567 5038 382b 5a0a  2pUdTBTtegP88+Z.
-00000430: 724c 3557 4941 2b48 6c65 2f41 5537 7546  rL5WIA+Hle/AU7uF
-00000440: 514b 4f6e 3472 3670 6870 3437 3442 7430  QKOn4r6php474Bt0
-00000450: 3673 5a7a 7762 4d43 6759 4541 6b74 6a78  6sZzwbMCgYEAktjx
-00000460: 6465 5a79 4f36 6e33 4e79 7164 7666 6b42  deZyO6n3NyqdvfkB
-00000470: 0a55 2f7a 4c37 5567 4851 7251 6b76 5646  .U/zL7UgHQrQkvVF
-00000480: 306c 4a44 3934 6353 374b 5042 334f 4b76  0lJD94cS7KPB3OKv
-00000490: 6139 4547 6c50 3444 584f 6163 556a 6546  a9EGlP4DXOacUjeF
-000004a0: 355a 4831 6537 7037 4f6f 7874 4772 4361  5ZH1e7p7OoxtGrCa
-000004b0: 6b0a 3532 7367 6549 6966 5a58 495a 6245  k.52sgeIifZXIZbE
-000004c0: 2b63 4643 3975 5759 4d68 4738 622f 6d6b  +cFC9uWYMhG8b/mk
-000004d0: 6e2b 6956 6933 6a4f 6377 3641 4f42 5847  n+iVi3jOcw6AOBXG
-000004e0: 666f 6174 6871 4757 422b 7755 642f 344b  foathqGWB+wUd/4K
-000004f0: 6a2f 0a41 5968 4a58 3373 4433 476b 524a  j/.AYhJX3sD3GkRJ
-00000500: 5a47 3644 6874 5936 634d 4367 5945 4170  ZG6DhtY6cMCgYEAp
-00000510: 3752 4170 3838 6774 7751 6150 6b75 6935  7RAp88gtwQaPkui5
-00000520: 3842 7369 352f 5841 3074 7a7a 6d4c 6a49  8Bsi5/XA0tzzmLjI
-00000530: 6a57 530a 694b 6d51 7357 4c59 6c57 522b  jWS.iKmQsWLYlWR+
-00000540: 585a 586d 4a58 5565 5258 4c57 7449 6266  XZXmJXUeRXLWtIbf
-00000550: 3648 654e 4955 4636 3461 4565 737a 5a2f  6HeNIUF64aEeszZ/
-00000560: 6d4f 544a 7350 4c75 7537 334c 5a4d 5967  mOTJsPLuu73LZMYg
-00000570: 6263 6730 0a45 2f59 384e 7068 5a6a 6734  bcg0.E/Y8NphZjg4
-00000580: 694e 6b6f 7173 336a 5647 4431 776e 6b67  iNkoqs3jVGD1wnkg
-00000590: 426c 7638 4c4b 786f 6d41 4950 5443 6676  Blv8LKxomAIPTCfv
-000005a0: 7949 4732 4348 2b58 336a 474e 4f32 384a  yIG2CH+X3jGNO28J
-000005b0: 4543 3641 590a 6966 4e2f 6a33 4543 6759  EC6AY.ifN/j3ECgY
-000005c0: 426b 5757 6838 6751 4548 4945 466b 6365  BkWWh8gQEHIEFkce
-000005d0: 3447 766a 4449 3054 5169 5431 4841 4f30  4GvjDI0TQiT1HAO0
-000005e0: 314d 4e56 6c31 5369 3542 6a42 4c39 7250  1MNVl1Si5BjBL9rP
-000005f0: 4c6c 6241 504f 0a73 4d6b 6947 6a4b 4362  LlbAPO.sMkiGjKCb
-00000600: 416e 2f77 3778 686c 6e39 4963 7354 6d38  An/w7xhln9IcsTm8
-00000610: 4568 734b 7270 734e 6b41 6f6e 3273 4e4e  EhsKrpsNkAon2sNN
-00000620: 4767 3575 6f43 734d 774f 3943 7147 4976  Gg5uoCsMwO9CqGIv
-00000630: 5654 4273 5838 340a 6c53 7149 7a31 5665  VTBsX84.lSqIz1Ve
-00000640: 7835 7943 5a41 7953 4b67 5055 4677 3839  x5yCZAySKgPUFw89
-00000650: 4c6c 7675 2b57 4c63 7936 5a58 6639 5a44  Llvu+WLcy6ZXf9ZD
-00000660: 6948 366f 7152 2b72 646d 6436 4551 3d3d  iH6oqR+rdmd6EQ==
-00000670: 0a2d 2d2d 2d2d 454e 4420 5253 4120 5052  .-----END RSA PR
-00000680: 4956 4154 4520 4b45 592d 2d2d 2d2d 0a    IVATE KEY-----.
+00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0d  RIVATE KEY-----.
+00000020: 0a4d 4949 4570 4149 4241 414b 4341 5145  .MIIEpAIBAAKCAQE
+00000030: 4135 6c74 7a51 5572 4755 6b6c 4d74 5358  A5ltzQUrGUklMtSX
+00000040: 4648 4737 6262 3442 6351 3455 5043 7056  FHG7bb4BcQ4UPCpV
+00000050: 3039 5839 6f55 4376 4f74 2f49 7155 3647  09X9oUCvOt/IqU6G
+00000060: 420d 0a62 4748 6234 4b36 495a 6346 6933  B..bGHb4K6IZcFi3
+00000070: 4a64 2f33 4c4b 6b6e 4e6d 5633 7771 3136  Jd/3LKknNmV3wq16
+00000080: 4a6a 7663 3338 2f76 7450 6c73 492b 6877  Jjvc38/vtPlsI+hw
+00000090: 3733 3349 3464 3733 6665 7952 2f2b 4e48  733I4d73feyR/+NH
+000000a0: 742f 650d 0a64 4c39 706d 5341 6a53 7975  t/e..dL9pmSAjSyu
+000000b0: 6936 4859 2f43 6475 2b47 6163 6438 6c44  i6HY/Cdu+Gacd8lD
+000000c0: 656b 4165 2f48 6e64 6e39 5a34 4539 6569  ekAe/Hndn9Z4E9ei
+000000d0: 7454 6b43 6a51 7766 4a75 6c5a 6731 4171  tTkCjQwfJulZg1Aq
+000000e0: 464e 5578 690d 0a79 6549 784a 5054 4638  FNUxi..yeIxJPTF8
+000000f0: 7854 4878 674c 6958 4575 4b2b 7838 676d  xTHxgLiXEuK+x8gm
+00000100: 7531 6b70 5431 615a 6f2b 2b4d 7146 7356  u1kpT1aZo++MqFsV
+00000110: 2b50 4875 6836 7753 724f 364b 314c 474a  +PHuh6wSrO6K1LGJ
+00000120: 414d 644f 5957 630d 0a49 7241 6649 367a  AMdOYWc..IrAfI6z
+00000130: 3867 654b 7245 3758 6458 6479 5577 6f66  8geKrE7XdXdyUwof
+00000140: 4a4e 4e38 7164 7478 776c 347a 3333 4166  JNN8qdtxwl4z33Af
+00000150: 3266 2f30 754c 5839 774e 4e61 736d 6838  2f/0uLX9wNNasmh8
+00000160: 6741 2f4c 5358 5958 4a0d 0a56 4570 3876  gA/LSXYXJ..VEp8v
+00000170: 4635 504e 6b46 3157 462f 3450 716f 7545  F5PNkF1WF/4PqouE
+00000180: 7976 4776 504a 4263 6178 5737 7366 3668  yvGvPJBcaxW7sf6h
+00000190: 5149 4441 5141 4241 6f49 4241 4475 6431  QIDAQABAoIBADud1
+000001a0: 5646 4469 646f 4838 4673 390d 0a59 4373  VFDidoH8Fs9..YCs
+000001b0: 416f 6266 5572 3477 6c35 6f4f 6c74 4852  AobfUr4wl5oOltHR
+000001c0: 4975 6656 7473 5030 344a 6934 6f73 5463  IufVtsP04Ji4osTc
+000001d0: 6369 4777 346e 3049 2b62 3169 4a75 4f53  ciGw4n0I+b1iJuOS
+000001e0: 6b4d 7967 4977 396e 4b69 744f 630d 0a71  kMygIw9nKitOc..q
+000001f0: 5050 714c 6451 3051 4e43 5743 355a 2b46  PPqLdQ0QNCWC5Z+F
+00000200: 6e54 5366 6f4d 7574 4b77 6666 6956 4d61  nTSfoMutKwffiVMa
+00000210: 4f55 7347 4b63 7867 7844 5552 5541 4751  OUsGKcxgxDURUAGQ
+00000220: 6b42 4a35 3450 3646 537a 2b4d 7574 780d  kBJ54P6FSz+Mutx.
+00000230: 0a70 6375 3775 574c 2b74 3266 7842 4e45  .pcu7uWL+t2fxBNE
+00000240: 6f74 3167 4572 7665 546e 5647 6976 6130  ot1gErveTnVGiva0
+00000250: 6c58 2b78 5451 4d38 632b 4768 6365 3549  lX+xTQM8c+Ghce5I
+00000260: 5848 726a 4644 3945 6d37 4d75 2b31 6d6d  XHrjFD9Em7Mu+1mm
+00000270: 730d 0a4f 5978 6c69 6e77 6655 5176 6776  s..OYxlinwfUQvgv
+00000280: 614a 4172 486d 4b4b 4f47 6d47 392f 6e77  aJArHmKKOGmG9/nw
+00000290: 4e49 7252 7576 5143 5748 6656 536a 3066  NIrRuvQCWHfVSj0f
+000002a0: 6545 7562 4661 5a49 7848 5252 5533 6b32  eEubFaZIxHRRU3k2
+000002b0: 314f 420d 0a35 316b 6e77 4250 6836 7644  1OB..51knwBPh6vD
+000002c0: 7751 326b 7371 7957 7652 7973 6871 3045  wQ2ksqyWvRyshq0E
+000002d0: 7357 4e75 4c54 356c 322b 5a62 3143 2b4e  sWNuLT5l2+Zb1C+N
+000002e0: 5877 7168 382f 536c 787a 4855 7169 334c  Xwqh8/SlxzHUqi3L
+000002f0: 624b 3447 670d 0a4d 5250 4568 4f30 4367  bK4Gg..MRPEhO0Cg
+00000300: 5945 4139 5350 4577 6532 4d43 4f76 336f  YEA9SPEwe2MCOv3o
+00000310: 6e70 4657 4a4f 7473 4275 6c79 724c 6564  npFWJOtsBulyrLed
+00000320: 2b4d 7a56 6244 7152 4332 3959 3350 6a48  +MzVbDqRC29Y3PjH
+00000330: 4666 7462 366d 690d 0a32 4468 304c 706b  Fftb6mi..2Dh0Lpk
+00000340: 6a6f 4665 4741 2b4c 3239 4a5a 4a6e 7166  joFeGA+L29JZJnqf
+00000350: 6b68 564c 6275 2b35 7a38 4c42 365a 2f7a  khVLbu+5z8LB6Z/z
+00000360: 656d 3445 7a78 584d 7851 3262 3868 394d  em4EzxXMxQ2b8h9M
+00000370: 6e62 4a51 5971 4448 670d 0a58 7131 5865  nbJQYqDHg..Xq1Xe
+00000380: 566d 7850 4a4d 4b4e 3637 4f38 7535 6b75  VmxPJMKN67O8u5ku
+00000390: 3139 6176 3576 5a48 4771 3051 3635 6e6c  19av5vZHGq0Q65nl
+000003a0: 6e37 3755 694b 7745 4e44 3534 446f 4f42  n77UiKwEND54DoOB
+000003b0: 7563 4367 5945 4138 4a41 470d 0a2b 494e  ucCgYEA8JAG..+IN
+000003c0: 4d4d 5950 4141 4a49 6a68 5741 5638 5562  MMYPAAJIjhWAV8Ub
+000003d0: 6959 3049 5263 7045 2b65 4970 6234 676a  iY0IRcpE+eIpb4gj
+000003e0: 576d 5063 6973 6b7a 784c 4b41 6a65 6472  WmPciskzxLKAjedr
+000003f0: 5178 4a79 7765 6275 3132 7238 720d 0a49  QxJywebu12r8r..I
+00000400: 4832 7265 6476 6654 5379 6544 5748 3164  H2redvfTSyeDWH1d
+00000410: 416a 326e 3731 5731 3466 6c5a 5468 6250  Aj2n71W14flZThbP
+00000420: 6d6b 536c 6235 674f 3252 3077 4568 4477  mkSlb5gO2R0wEhDw
+00000430: 3270 5564 5442 5474 6567 5038 382b 5a0d  2pUdTBTtegP88+Z.
+00000440: 0a72 4c35 5749 412b 486c 652f 4155 3775  .rL5WIA+Hle/AU7u
+00000450: 4651 4b4f 6e34 7236 7068 7034 3734 4274  FQKOn4r6php474Bt
+00000460: 3036 735a 7a77 624d 4367 5945 416b 746a  06sZzwbMCgYEAktj
+00000470: 7864 655a 794f 366e 334e 7971 6476 666b  xdeZyO6n3Nyqdvfk
+00000480: 420d 0a55 2f7a 4c37 5567 4851 7251 6b76  B..U/zL7UgHQrQkv
+00000490: 5646 306c 4a44 3934 6353 374b 5042 334f  VF0lJD94cS7KPB3O
+000004a0: 4b76 6139 4547 6c50 3444 584f 6163 556a  Kva9EGlP4DXOacUj
+000004b0: 6546 355a 4831 6537 7037 4f6f 7874 4772  eF5ZH1e7p7OoxtGr
+000004c0: 4361 6b0d 0a35 3273 6765 4969 665a 5849  Cak..52sgeIifZXI
+000004d0: 5a62 452b 6346 4339 7557 594d 6847 3862  ZbE+cFC9uWYMhG8b
+000004e0: 2f6d 6b6e 2b69 5669 336a 4f63 7736 414f  /mkn+iVi3jOcw6AO
+000004f0: 4258 4766 6f61 7468 7147 5742 2b77 5564  BXGfoathqGWB+wUd
+00000500: 2f34 4b6a 2f0d 0a41 5968 4a58 3373 4433  /4Kj/..AYhJX3sD3
+00000510: 476b 524a 5a47 3644 6874 5936 634d 4367  GkRJZG6DhtY6cMCg
+00000520: 5945 4170 3752 4170 3838 6774 7751 6150  YEAp7RAp88gtwQaP
+00000530: 6b75 6935 3842 7369 352f 5841 3074 7a7a  kui58Bsi5/XA0tzz
+00000540: 6d4c 6a49 6a57 530d 0a69 4b6d 5173 574c  mLjIjWS..iKmQsWL
+00000550: 596c 5752 2b58 5a58 6d4a 5855 6552 584c  YlWR+XZXmJXUeRXL
+00000560: 5774 4962 6636 4865 4e49 5546 3634 6145  WtIbf6HeNIUF64aE
+00000570: 6573 7a5a 2f6d 4f54 4a73 504c 7575 3733  eszZ/mOTJsPLuu73
+00000580: 4c5a 4d59 6762 6367 300d 0a45 2f59 384e  LZMYgbcg0..E/Y8N
+00000590: 7068 5a6a 6734 694e 6b6f 7173 336a 5647  phZjg4iNkoqs3jVG
+000005a0: 4431 776e 6b67 426c 7638 4c4b 786f 6d41  D1wnkgBlv8LKxomA
+000005b0: 4950 5443 6676 7949 4732 4348 2b58 336a  IPTCfvyIG2CH+X3j
+000005c0: 474e 4f32 384a 4543 3641 590d 0a69 664e  GNO28JEC6AY..ifN
+000005d0: 2f6a 3345 4367 5942 6b57 5768 3867 5145  /j3ECgYBkWWh8gQE
+000005e0: 4849 4546 6b63 6534 4776 6a44 4930 5451  HIEFkce4GvjDI0TQ
+000005f0: 6954 3148 414f 3031 4d4e 566c 3153 6935  iT1HAO01MNVl1Si5
+00000600: 426a 424c 3972 504c 6c62 4150 4f0d 0a73  BjBL9rPLlbAPO..s
+00000610: 4d6b 6947 6a4b 4362 416e 2f77 3778 686c  MkiGjKCbAn/w7xhl
+00000620: 6e39 4963 7354 6d38 4568 734b 7270 734e  n9IcsTm8EhsKrpsN
+00000630: 6b41 6f6e 3273 4e4e 4767 3575 6f43 734d  kAon2sNNGg5uoCsM
+00000640: 774f 3943 7147 4976 5654 4273 5838 340d  wO9CqGIvVTBsX84.
+00000650: 0a6c 5371 497a 3156 6578 3579 435a 4179  .lSqIz1Vex5yCZAy
+00000660: 534b 6750 5546 7738 394c 6c76 752b 574c  SKgPUFw89Llvu+WL
+00000670: 6379 365a 5866 395a 4469 4836 6f71 522b  cy6ZXf9ZDiH6oqR+
+00000680: 7264 6d64 3645 513d 3d0d 0a2d 2d2d 2d2d  rdmd6EQ==..-----
+00000690: 454e 4420 5253 4120 5052 4956 4154 4520  END RSA PRIVATE 
+000006a0: 4b45 592d 2d2d 2d2d 0d0a                 KEY-----..
```

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_key_cert.pfx` & `yubikey_manager-5.1.1/tests/files/rsa_2048_key_cert.pfx`

 * *Files identical despite different names*

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_key_cert_encrypted.pfx` & `yubikey_manager-5.1.1/tests/files/rsa_2048_key_cert_encrypted.pfx`

 * *Files identical despite different names*

### Comparing `yubikey_manager-5.1.0/tests/files/rsa_2048_key_encrypted.pem` & `yubikey_manager-5.1.1/tests/files/rsa_2048_key_encrypted.pem`

 * *Files 13% similar despite different names*

```diff
@@ -1,110 +1,112 @@
 00000000: 2d2d 2d2d 2d42 4547 494e 2052 5341 2050  -----BEGIN RSA P
-00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0a  RIVATE KEY-----.
-00000020: 5072 6f63 2d54 7970 653a 2034 2c45 4e43  Proc-Type: 4,ENC
-00000030: 5259 5054 4544 0a44 454b 2d49 6e66 6f3a  RYPTED.DEK-Info:
-00000040: 2044 4553 2d45 4445 332d 4342 432c 3537   DES-EDE3-CBC,57
-00000050: 3944 3346 3445 3730 3343 3632 3837 0a0a  9D3F4E703C6287..
-00000060: 6c59 6242 757a 4275 7263 6457 6478 6d74  lYbBuzBurcdWdxmt
-00000070: 2b63 455a 4e59 734b 7449 706d 6b50 5574  +cEZNYsKtIpmkPUt
-00000080: 485a 2b2f 5775 5037 4353 6949 4e75 4978  HZ+/WuP7CSiINuIx
-00000090: 3366 785a 7969 7449 4b41 4d69 7775 594d  3fxZyitIKAMiwuYM
-000000a0: 0a34 3034 742b 2f69 5235 6a6d 7a4a 5750  .404t+/iR5jmzJWP
-000000b0: 4577 576b 6a2b 5858 4350 4e35 764a 4462  EwWkj+XXCPN5vJDb
-000000c0: 6634 6575 4c59 2b64 2b2b 3356 5362 5857  f4euLY+d++3VSbXW
-000000d0: 6173 3266 7875 7466 7a49 5052 5258 646f  as2fxutfzIPRRXdo
-000000e0: 510a 5776 6a6e 5234 7651 4449 5545 3376  Q.WvjnR4vQDIUE3v
-000000f0: 4859 6344 7953 316a 3267 776d 6279 6542  HYcDyS1j2gwmbyeB
-00000100: 615a 4246 6c4a 3851 796c 6f79 3157 3372  aZBFlJ8Qyloy1W3r
-00000110: 4c54 6e33 6e78 697a 664b 374b 716b 4753  LTn3nxizfK7KqkGS
-00000120: 614f 0a6c 6d31 6553 6654 7738 776a 324d  aO.lm1eSfTw8wj2M
-00000130: 366e 7279 5050 4244 4871 3950 5333 4963  6nryPPBDHq9PS3Ic
-00000140: 2b6d 4a44 4c30 6749 5850 7138 442b 5563  +mJDL0gIXPq8D+Uc
-00000150: 6e54 6256 4358 6c75 6775 4572 6e2b 3479  nTbVCXluguErn+4y
-00000160: 374c 4a0a 6630 5258 3273 4a38 4b61 5235  7LJ.f0RX2sJ8KaR5
-00000170: 436d 5270 6648 4c37 6b7a 5663 2b6f 5849  CmRpfHL7kzVc+oXI
-00000180: 3543 6f57 714f 465a 706a 4e6f 6a70 7644  5CoWqOFZpjNojpvD
-00000190: 7153 7268 3937 4470 4941 724f 6f59 726c  qSrh97DpIArOoYrl
-000001a0: 5836 6452 0a70 586c 5264 5868 6858 647a  X6dR.pXlRdXhhXdz
-000001b0: 5134 4370 474c 6341 7468 7941 6875 6153  Q4CpGLcAthyAhuaS
-000001c0: 7a53 4b46 332b 5831 532f 6f52 584d 3154  zSKF3+X1S/oRXM1T
-000001d0: 746b 4276 4147 7877 3662 3178 3130 684f  tkBvAGxw6b1x10hO
-000001e0: 752f 3743 6e0a 2f74 7a46 6370 7a31 4532  u/7Cn./tzFcpz1E2
-000001f0: 4c59 4c36 372b 6a47 4a39 4970 455a 6b54  LYL67+jGJ9IpEZkT
-00000200: 3265 3869 6e56 6542 4271 326e 6238 714e  2e8inVeBBq2nb8qN
-00000210: 3231 3458 4e56 7064 6961 3458 6d35 7256  214XNVpdia4Xm5rV
-00000220: 3071 564d 7042 0a45 3868 4c6d 6b6d 7a5a  0qVMpB.E8hLmkmzZ
-00000230: 794f 4a47 4b57 4a62 7767 6a41 6a43 7639  yOJGKWJbwgjAjCv9
-00000240: 4337 4534 7572 674b 7953 6a42 6a57 6442  C7E4urgKySjBjWdB
-00000250: 6d70 516e 7154 4a6f 6941 4536 3071 6a6c  mpQnqTJoiAE60qjl
-00000260: 7975 4336 5654 360a 424f 7235 7271 3171  yuC6VT6.BOr5rq1q
-00000270: 4970 7179 336c 4a5a 756c 414e 4142 504d  Ipqy3lJZulANABPM
-00000280: 4164 6a37 724c 5364 6c4b 686e 6370 3057  Adj7rLSdlKhncp0W
-00000290: 4c6c 426a 4d70 5168 7079 4630 5345 6969  LlBjMpQhpyF0SEii
-000002a0: 4555 4c44 7662 4970 0a6a 774d 4266 5038  EULDvbIp.jwMBfP8
-000002b0: 4b31 6773 414a 5273 4955 764e 7257 4336  K1gsAJRsIUvNrWC6
-000002c0: 5061 4430 706c 4e41 506e 312b 794d 7073  PaD0plNAPn1+yMps
-000002d0: 3063 4e64 644d 414c 4668 6464 5875 4c61  0cNddMALFhddXuLa
-000002e0: 7538 3651 7250 704f 540a 425a 6b53 347a  u86QrPpOT.BZkS4z
-000002f0: 7155 4b44 4f4f 4778 7173 3561 566a 7961  qUKDOOGxqs5aVjya
-00000300: 4b36 3669 6c66 3739 4761 3039 766a 7655  K66ilf79Ga09vjvU
-00000310: 3564 3241 3666 7973 5673 3577 3538 4c4a  5d2A6fysVs5w58LJ
-00000320: 627a 387a 612f 7a79 7435 0a71 7374 3954  bz8za/zyt5.qst9T
-00000330: 6738 6b55 5873 3461 5248 6541 4256 3776  g8kUXs4aRHeABV7v
-00000340: 322f 4638 4378 446f 5564 4659 4834 3947  2/F8CxDoUdFYH49G
-00000350: 6138 494a 516e 326e 4758 307a 7146 376c  a8IJQn2nGX0zqF7l
-00000360: 4f42 5676 354c 5a6c 5444 790a 2f32 6733  OBVv5LZlTDy./2g3
-00000370: 5137 7971 434f 6266 486f 664b 4942 7437  Q7yqCObfHofKIBt7
-00000380: 5532 3636 4972 4862 6732 536e 3570 7832  U266IrHbg2Sn5px2
-00000390: 7375 7941 6a4b 7867 6241 452b 4758 616d  suyAjKxgbAE+GXam
-000003a0: 694c 7266 7077 5a34 616f 3047 0a35 4241  iLrfpwZ4ao0G.5BA
-000003b0: 6b49 6336 354a 4537 3935 4a66 4558 7557  kIc65JE795JfEXuW
-000003c0: 6331 5a77 4337 7976 6646 3157 3265 3055  c1ZwC7yvfF1W2e0U
-000003d0: 546a 6a31 4848 5357 5a51 7a63 4f38 5736  Tjj1HHSWZQzcO8W6
-000003e0: 6e6c 4e47 534b 6c32 3162 3145 7a0a 7764  nlNGSKl21b1Ez.wd
-000003f0: 6a44 586e 4b78 6931 4f47 564e 3071 6a45  jDXnKxi1OGVN0qjE
-00000400: 564a 7842 3632 476f 4c61 7456 4d74 6c33  VJxB62GoLatVMtl3
-00000410: 6469 6976 4537 6764 6738 5452 445a 7447  diivE7gdg8TRDZtG
-00000420: 6245 4262 524e 472f 5777 6136 4c54 0a70  bEBbRNG/Wwa6LT.p
-00000430: 684b 4f33 4836 3662 6a79 514a 6d6c 644b  hKO3H66bjyQJmldK
-00000440: 3565 5952 5177 546f 4149 4b4a 336c 795a  5eYRQwToAIKJ3lyZ
-00000450: 482f 676e 4756 2f6a 724f 5a32 4675 4152  H/gnGV/jrOZ2FuAR
-00000460: 3643 5441 4f64 5554 6d46 4436 4877 770a  6CTAOdUTmFD6Hww.
-00000470: 2b65 526f 6d54 7661 7757 7271 584f 7574  +eRomTvawWrqXOut
-00000480: 384c 5339 7557 6978 7a45 414e 6e42 545a  8LS9uWixzEANnBTZ
-00000490: 3769 5233 624c 3675 7838 4175 7634 7574  7iR3bL6ux8Auv4ut
-000004a0: 4e62 614c 7441 6677 7041 4847 4872 4f44  NbaLtAfwpAHGHrOD
-000004b0: 0a55 4c57 367a 756d 7332 714e 6232 4a31  .ULW6zums2qNb2J1
-000004c0: 4b31 6633 364c 2f59 3747 4553 434f 6367  K1f36L/Y7GESCOcg
-000004d0: 655a 3449 3179 4861 4b41 6364 794a 6d6f  eZ4I1yHaKAcdyJmo
-000004e0: 4567 3474 5954 4d47 6d4d 554e 6c33 7731  Eg4tYTMGmMUNl3w1
-000004f0: 550a 3437 6d42 7051 7530 5367 3850 7446  U.47mBpQu0Sg8PtF
-00000500: 4374 3368 7037 3971 6152 4e4f 4d49 6e36  Ct3hp79qaRNOMIn6
-00000510: 4d45 6b6d 5465 4979 6f6f 746a 7437 4b78  MEkmTeIyootjt7Kx
-00000520: 7444 3542 4d59 7879 3044 7870 5442 6841  tD5BMYxy0DxpTBhA
-00000530: 756a 0a5a 3267 7855 5352 344f 7a6d 3176  uj.Z2gxUSR4Ozm1v
-00000540: 4862 634f 6938 375a 5732 6e50 4138 4c35  HbcOi87ZW2nPA8L5
-00000550: 4332 2f53 4430 3344 734a 5066 3442 626e  C2/SD03DsJPf4Bbn
-00000560: 564c 7550 3773 774c 6c4c 5044 7334 5261  VLuP7swLlLPDs4Ra
-00000570: 366e 4c0a 7172 6d36 6465 7653 5a6a 6575  6nL.qrm6devSZjeu
-00000580: 586a 312b 6a71 4c6f 7152 354c 3551 4241  Xj1+jqLoqR5L5QBA
-00000590: 7a46 4f77 3570 3559 666f 506b 5675 3454  zFOw5p5YfoPkVu4T
-000005a0: 724e 4d34 3450 7631 7464 6b66 5945 2f53  rNM44Pv1tdkfYE/S
-000005b0: 5832 745a 0a55 6b4c 504c 7766 6844 6132  X2tZ.UkLPLwfhDa2
-000005c0: 5133 7a71 7675 7a61 5441 5154 5a34 506a  Q3zqvuzaTAQTZ4Pj
-000005d0: 5154 6642 3463 2f65 5643 3463 2f34 3633  QTfB4c/eVC4c/463
-000005e0: 6154 7977 7269 3936 3357 7153 6731 6b4b  aTywri963WqSg1kK
-000005f0: 4553 414d 770a 4f37 5846 5376 5568 5544  ESAMw.O7XFSvUhUD
-00000600: 6c6a 5231 4347 414f 4159 5a57 5138 6351  ljR1CGAOAYZWQ8cQ
-00000610: 3941 316b 4869 6e6f 6f4a 4c48 4270 7a57  9A1kHinooJLHBpzW
-00000620: 656f 5641 6a61 6a4a 7267 7573 7631 6d72  eoVAjajJrgusv1mr
-00000630: 7951 7a63 6a73 0a54 564c 3735 6d76 654f  yQzcjs.TVL75mveO
-00000640: 4765 7448 7263 5063 5231 6155 5869 4644  GetHrcPcR1aUXiFD
-00000650: 6359 5a70 354f 596f 3233 4132 7a33 3477  cYZp5OYo23A2z34w
-00000660: 5961 674f 5253 7664 6730 5557 6774 446a  YagORSvdg0UWgtDj
-00000670: 2b39 4550 7752 6b0a 706c 4d5a 3737 636e  +9EPwRk.plMZ77cn
-00000680: 6b4c 6b64 3678 3763 5143 6f62 6a32 7948  kLkd6x7cQCobj2yH
-00000690: 5248 3066 6f4e 314c 316e 744b 4c78 4f30  RH0foN1L1ntKLxO0
-000006a0: 6a6f 6f38 3555 5155 7353 6f62 6139 6e43  joo85UQUsSoba9nC
-000006b0: 6f65 5332 4876 6c6a 0a2d 2d2d 2d2d 454e  oeS2Hvlj.-----EN
-000006c0: 4420 5253 4120 5052 4956 4154 4520 4b45  D RSA PRIVATE KE
-000006d0: 592d 2d2d 2d2d 0a                        Y-----.
+00000010: 5249 5641 5445 204b 4559 2d2d 2d2d 2d0d  RIVATE KEY-----.
+00000020: 0a50 726f 632d 5479 7065 3a20 342c 454e  .Proc-Type: 4,EN
+00000030: 4352 5950 5445 440d 0a44 454b 2d49 6e66  CRYPTED..DEK-Inf
+00000040: 6f3a 2044 4553 2d45 4445 332d 4342 432c  o: DES-EDE3-CBC,
+00000050: 3537 3944 3346 3445 3730 3343 3632 3837  579D3F4E703C6287
+00000060: 0d0a 0d0a 6c59 6242 757a 4275 7263 6457  ....lYbBuzBurcdW
+00000070: 6478 6d74 2b63 455a 4e59 734b 7449 706d  dxmt+cEZNYsKtIpm
+00000080: 6b50 5574 485a 2b2f 5775 5037 4353 6949  kPUtHZ+/WuP7CSiI
+00000090: 4e75 4978 3366 785a 7969 7449 4b41 4d69  NuIx3fxZyitIKAMi
+000000a0: 7775 594d 0d0a 3430 3474 2b2f 6952 356a  wuYM..404t+/iR5j
+000000b0: 6d7a 4a57 5045 7757 6b6a 2b58 5843 504e  mzJWPEwWkj+XXCPN
+000000c0: 3576 4a44 6266 3465 754c 592b 642b 2b33  5vJDbf4euLY+d++3
+000000d0: 5653 6258 5761 7332 6678 7574 667a 4950  VSbXWas2fxutfzIP
+000000e0: 5252 5864 6f51 0d0a 5776 6a6e 5234 7651  RRXdoQ..WvjnR4vQ
+000000f0: 4449 5545 3376 4859 6344 7953 316a 3267  DIUE3vHYcDyS1j2g
+00000100: 776d 6279 6542 615a 4246 6c4a 3851 796c  wmbyeBaZBFlJ8Qyl
+00000110: 6f79 3157 3372 4c54 6e33 6e78 697a 664b  oy1W3rLTn3nxizfK
+00000120: 374b 716b 4753 614f 0d0a 6c6d 3165 5366  7KqkGSaO..lm1eSf
+00000130: 5477 3877 6a32 4d36 6e72 7950 5042 4448  Tw8wj2M6nryPPBDH
+00000140: 7139 5053 3349 632b 6d4a 444c 3067 4958  q9PS3Ic+mJDL0gIX
+00000150: 5071 3844 2b55 636e 5462 5643 586c 7567  Pq8D+UcnTbVCXlug
+00000160: 7545 726e 2b34 7937 4c4a 0d0a 6630 5258  uErn+4y7LJ..f0RX
+00000170: 3273 4a38 4b61 5235 436d 5270 6648 4c37  2sJ8KaR5CmRpfHL7
+00000180: 6b7a 5663 2b6f 5849 3543 6f57 714f 465a  kzVc+oXI5CoWqOFZ
+00000190: 706a 4e6f 6a70 7644 7153 7268 3937 4470  pjNojpvDqSrh97Dp
+000001a0: 4941 724f 6f59 726c 5836 6452 0d0a 7058  IArOoYrlX6dR..pX
+000001b0: 6c52 6458 6868 5864 7a51 3443 7047 4c63  lRdXhhXdzQ4CpGLc
+000001c0: 4174 6879 4168 7561 537a 534b 4633 2b58  AthyAhuaSzSKF3+X
+000001d0: 3153 2f6f 5258 4d31 5474 6b42 7641 4778  1S/oRXM1TtkBvAGx
+000001e0: 7736 6231 7831 3068 4f75 2f37 436e 0d0a  w6b1x10hOu/7Cn..
+000001f0: 2f74 7a46 6370 7a31 4532 4c59 4c36 372b  /tzFcpz1E2LYL67+
+00000200: 6a47 4a39 4970 455a 6b54 3265 3869 6e56  jGJ9IpEZkT2e8inV
+00000210: 6542 4271 326e 6238 714e 3231 3458 4e56  eBBq2nb8qN214XNV
+00000220: 7064 6961 3458 6d35 7256 3071 564d 7042  pdia4Xm5rV0qVMpB
+00000230: 0d0a 4538 684c 6d6b 6d7a 5a79 4f4a 474b  ..E8hLmkmzZyOJGK
+00000240: 574a 6277 676a 416a 4376 3943 3745 3475  WJbwgjAjCv9C7E4u
+00000250: 7267 4b79 536a 426a 5764 426d 7051 6e71  rgKySjBjWdBmpQnq
+00000260: 544a 6f69 4145 3630 716a 6c79 7543 3656  TJoiAE60qjlyuC6V
+00000270: 5436 0d0a 424f 7235 7271 3171 4970 7179  T6..BOr5rq1qIpqy
+00000280: 336c 4a5a 756c 414e 4142 504d 4164 6a37  3lJZulANABPMAdj7
+00000290: 724c 5364 6c4b 686e 6370 3057 4c6c 426a  rLSdlKhncp0WLlBj
+000002a0: 4d70 5168 7079 4630 5345 6969 4555 4c44  MpQhpyF0SEiiEULD
+000002b0: 7662 4970 0d0a 6a77 4d42 6650 384b 3167  vbIp..jwMBfP8K1g
+000002c0: 7341 4a52 7349 5576 4e72 5743 3650 6144  sAJRsIUvNrWC6PaD
+000002d0: 3070 6c4e 4150 6e31 2b79 4d70 7330 634e  0plNAPn1+yMps0cN
+000002e0: 6464 4d41 4c46 6864 6458 754c 6175 3836  ddMALFhddXuLau86
+000002f0: 5172 5070 4f54 0d0a 425a 6b53 347a 7155  QrPpOT..BZkS4zqU
+00000300: 4b44 4f4f 4778 7173 3561 566a 7961 4b36  KDOOGxqs5aVjyaK6
+00000310: 3669 6c66 3739 4761 3039 766a 7655 3564  6ilf79Ga09vjvU5d
+00000320: 3241 3666 7973 5673 3577 3538 4c4a 627a  2A6fysVs5w58LJbz
+00000330: 387a 612f 7a79 7435 0d0a 7173 7439 5467  8za/zyt5..qst9Tg
+00000340: 386b 5558 7334 6152 4865 4142 5637 7632  8kUXs4aRHeABV7v2
+00000350: 2f46 3843 7844 6f55 6446 5948 3439 4761  /F8CxDoUdFYH49Ga
+00000360: 3849 4a51 6e32 6e47 5830 7a71 4637 6c4f  8IJQn2nGX0zqF7lO
+00000370: 4256 7635 4c5a 6c54 4479 0d0a 2f32 6733  BVv5LZlTDy../2g3
+00000380: 5137 7971 434f 6266 486f 664b 4942 7437  Q7yqCObfHofKIBt7
+00000390: 5532 3636 4972 4862 6732 536e 3570 7832  U266IrHbg2Sn5px2
+000003a0: 7375 7941 6a4b 7867 6241 452b 4758 616d  suyAjKxgbAE+GXam
+000003b0: 694c 7266 7077 5a34 616f 3047 0d0a 3542  iLrfpwZ4ao0G..5B
+000003c0: 416b 4963 3635 4a45 3739 354a 6645 5875  AkIc65JE795JfEXu
+000003d0: 5763 315a 7743 3779 7666 4631 5732 6530  Wc1ZwC7yvfF1W2e0
+000003e0: 5554 6a6a 3148 4853 575a 517a 634f 3857  UTjj1HHSWZQzcO8W
+000003f0: 366e 6c4e 4753 4b6c 3231 6231 457a 0d0a  6nlNGSKl21b1Ez..
+00000400: 7764 6a44 586e 4b78 6931 4f47 564e 3071  wdjDXnKxi1OGVN0q
+00000410: 6a45 564a 7842 3632 476f 4c61 7456 4d74  jEVJxB62GoLatVMt
+00000420: 6c33 6469 6976 4537 6764 6738 5452 445a  l3diivE7gdg8TRDZ
+00000430: 7447 6245 4262 524e 472f 5777 6136 4c54  tGbEBbRNG/Wwa6LT
+00000440: 0d0a 7068 4b4f 3348 3636 626a 7951 4a6d  ..phKO3H66bjyQJm
+00000450: 6c64 4b35 6559 5251 7754 6f41 494b 4a33  ldK5eYRQwToAIKJ3
+00000460: 6c79 5a48 2f67 6e47 562f 6a72 4f5a 3246  lyZH/gnGV/jrOZ2F
+00000470: 7541 5236 4354 414f 6455 546d 4644 3648  uAR6CTAOdUTmFD6H
+00000480: 7777 0d0a 2b65 526f 6d54 7661 7757 7271  ww..+eRomTvawWrq
+00000490: 584f 7574 384c 5339 7557 6978 7a45 414e  XOut8LS9uWixzEAN
+000004a0: 6e42 545a 3769 5233 624c 3675 7838 4175  nBTZ7iR3bL6ux8Au
+000004b0: 7634 7574 4e62 614c 7441 6677 7041 4847  v4utNbaLtAfwpAHG
+000004c0: 4872 4f44 0d0a 554c 5736 7a75 6d73 3271  HrOD..ULW6zums2q
+000004d0: 4e62 324a 314b 3166 3336 4c2f 5937 4745  Nb2J1K1f36L/Y7GE
+000004e0: 5343 4f63 6765 5a34 4931 7948 614b 4163  SCOcgeZ4I1yHaKAc
+000004f0: 6479 4a6d 6f45 6734 7459 544d 476d 4d55  dyJmoEg4tYTMGmMU
+00000500: 4e6c 3377 3155 0d0a 3437 6d42 7051 7530  Nl3w1U..47mBpQu0
+00000510: 5367 3850 7446 4374 3368 7037 3971 6152  Sg8PtFCt3hp79qaR
+00000520: 4e4f 4d49 6e36 4d45 6b6d 5465 4979 6f6f  NOMIn6MEkmTeIyoo
+00000530: 746a 7437 4b78 7444 3542 4d59 7879 3044  tjt7KxtD5BMYxy0D
+00000540: 7870 5442 6841 756a 0d0a 5a32 6778 5553  xpTBhAuj..Z2gxUS
+00000550: 5234 4f7a 6d31 7648 6263 4f69 3837 5a57  R4Ozm1vHbcOi87ZW
+00000560: 326e 5041 384c 3543 322f 5344 3033 4473  2nPA8L5C2/SD03Ds
+00000570: 4a50 6634 4262 6e56 4c75 5037 7377 4c6c  JPf4BbnVLuP7swLl
+00000580: 4c50 4473 3452 6136 6e4c 0d0a 7172 6d36  LPDs4Ra6nL..qrm6
+00000590: 6465 7653 5a6a 6575 586a 312b 6a71 4c6f  devSZjeuXj1+jqLo
+000005a0: 7152 354c 3551 4241 7a46 4f77 3570 3559  qR5L5QBAzFOw5p5Y
+000005b0: 666f 506b 5675 3454 724e 4d34 3450 7631  foPkVu4TrNM44Pv1
+000005c0: 7464 6b66 5945 2f53 5832 745a 0d0a 556b  tdkfYE/SX2tZ..Uk
+000005d0: 4c50 4c77 6668 4461 3251 337a 7176 757a  LPLwfhDa2Q3zqvuz
+000005e0: 6154 4151 545a 3450 6a51 5466 4234 632f  aTAQTZ4PjQTfB4c/
+000005f0: 6556 4334 632f 3436 3361 5479 7772 6939  eVC4c/463aTywri9
+00000600: 3633 5771 5367 316b 4b45 5341 4d77 0d0a  63WqSg1kKESAMw..
+00000610: 4f37 5846 5376 5568 5544 6c6a 5231 4347  O7XFSvUhUDljR1CG
+00000620: 414f 4159 5a57 5138 6351 3941 316b 4869  AOAYZWQ8cQ9A1kHi
+00000630: 6e6f 6f4a 4c48 4270 7a57 656f 5641 6a61  nooJLHBpzWeoVAja
+00000640: 6a4a 7267 7573 7631 6d72 7951 7a63 6a73  jJrgusv1mryQzcjs
+00000650: 0d0a 5456 4c37 356d 7665 4f47 6574 4872  ..TVL75mveOGetHr
+00000660: 6350 6352 3161 5558 6946 4463 595a 7035  cPcR1aUXiFDcYZp5
+00000670: 4f59 6f32 3341 327a 3334 7759 6167 4f52  OYo23A2z34wYagOR
+00000680: 5376 6467 3055 5767 7444 6a2b 3945 5077  Svdg0UWgtDj+9EPw
+00000690: 526b 0d0a 706c 4d5a 3737 636e 6b4c 6b64  Rk..plMZ77cnkLkd
+000006a0: 3678 3763 5143 6f62 6a32 7948 5248 3066  6x7cQCobj2yHRH0f
+000006b0: 6f4e 314c 316e 744b 4c78 4f30 6a6f 6f38  oN1L1ntKLxO0joo8
+000006c0: 3555 5155 7353 6f62 6139 6e43 6f65 5332  5UQUsSoba9nCoeS2
+000006d0: 4876 6c6a 0d0a 2d2d 2d2d 2d45 4e44 2052  Hvlj..-----END R
+000006e0: 5341 2050 5249 5641 5445 204b 4559 2d2d  SA PRIVATE KEY--
+000006f0: 2d2d 2d0d 0a                             ---..
```

### Comparing `yubikey_manager-5.1.0/tests/test_device.py` & `yubikey_manager-5.1.1/tests/test_device.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,156 +1,156 @@
-from yubikit.core import TRANSPORT, YUBIKEY
-from yubikit.management import (
-    CAPABILITY,
-    FORM_FACTOR,
-    DeviceInfo,
-    DeviceConfig,
-    Version,
-)
-from yubikit.support import get_name
-from typing import cast
-
-
-def info(form_factor):
-    return DeviceInfo(
-        config=cast(DeviceConfig, None),
-        serial=None,
-        version=Version(5, 3, 0),
-        form_factor=form_factor,
-        supported_capabilities={TRANSPORT.USB: 0xFF},  # type: ignore
-        is_locked=False,
-        is_fips=False,
-    )
-
-
-def info_nfc(form_factor):
-    with_nfc = info(form_factor)
-    with_nfc.supported_capabilities[TRANSPORT.NFC] = 0xFF
-    return with_nfc
-
-
-def test_yk5_formfactors():
-    kt = YUBIKEY.YK4
-    assert get_name(info(FORM_FACTOR.USB_A_KEYCHAIN), kt) == "YubiKey 5A"
-    assert get_name(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN), kt) == "YubiKey 5 NFC"
-    assert get_name(info(FORM_FACTOR.USB_A_NANO), kt) == "YubiKey 5 Nano"
-    assert get_name(info(FORM_FACTOR.USB_C_KEYCHAIN), kt) == "YubiKey 5C"
-    assert get_name(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN), kt) == "YubiKey 5C NFC"
-    assert get_name(info(FORM_FACTOR.USB_C_NANO), kt) == "YubiKey 5C Nano"
-    assert get_name(info(FORM_FACTOR.USB_C_LIGHTNING), kt) == "YubiKey 5Ci"
-    assert get_name(info(FORM_FACTOR.USB_A_BIO), kt) == "YubiKey Bio"
-    assert get_name(info(FORM_FACTOR.USB_C_BIO), kt) == "YubiKey C Bio"
-    assert get_name(info(FORM_FACTOR.UNKNOWN), kt) == "YubiKey 5"
-    assert get_name(info_nfc(FORM_FACTOR.UNKNOWN), kt) == "YubiKey 5 NFC"
-
-
-def fido(device_info):
-    device_info.supported_capabilities[TRANSPORT.USB] = (
-        CAPABILITY.U2F | CAPABILITY.FIDO2
-    )
-    if TRANSPORT.NFC in device_info.supported_capabilities:
-        device_info.supported_capabilities[TRANSPORT.NFC] = (
-            CAPABILITY.U2F | CAPABILITY.FIDO2
-        )
-    return device_info
-
-
-def test_yk5_fido():
-    kt = YUBIKEY.YK4
-    assert (
-        get_name(fido(info(FORM_FACTOR.USB_A_BIO)), kt) == "YubiKey Bio - FIDO Edition"
-    )
-    assert (
-        get_name(fido(info(FORM_FACTOR.USB_C_BIO)), kt)
-        == "YubiKey C Bio - FIDO Edition"
-    )
-
-
-def fips(device_info):
-    device_info.is_fips = True
-    return device_info
-
-
-def test_yk5_fips_formfactors():
-    kt = YUBIKEY.YK4
-    assert get_name(fips(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "YubiKey 5A FIPS"
-    assert (
-        get_name(fips(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "YubiKey 5 NFC FIPS"
-    )
-    assert get_name(fips(info(FORM_FACTOR.USB_A_NANO)), kt) == "YubiKey 5 Nano FIPS"
-    assert get_name(fips(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "YubiKey 5C FIPS"
-    assert (
-        get_name(fips(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
-        == "YubiKey 5C NFC FIPS"
-    )
-    assert get_name(fips(info(FORM_FACTOR.USB_C_NANO)), kt) == "YubiKey 5C Nano FIPS"
-    assert get_name(fips(info(FORM_FACTOR.USB_C_LIGHTNING)), kt) == "YubiKey 5Ci FIPS"
-    assert get_name(fips(info(FORM_FACTOR.USB_A_BIO)), kt) == "YubiKey Bio FIPS"
-    assert get_name(fips(info(FORM_FACTOR.USB_C_BIO)), kt) == "YubiKey C Bio FIPS"
-    assert get_name(fips(info(FORM_FACTOR.UNKNOWN)), kt) == "YubiKey 5 FIPS"
-    assert get_name(fips(info_nfc(FORM_FACTOR.UNKNOWN)), kt) == "YubiKey 5 NFC FIPS"
-
-
-def sky(device_info):
-    device_info.is_sky = True
-    return device_info
-
-
-def test_sky_formfactors():
-    kt = YUBIKEY.YK4
-    assert get_name(sky(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "Security Key A"
-    assert get_name(sky(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "Security Key NFC"
-    assert get_name(sky(info(FORM_FACTOR.USB_A_NANO)), kt) == "Security Key Nano"
-    assert get_name(sky(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "Security Key C"
-    assert (
-        get_name(sky(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "Security Key C NFC"
-    )
-    assert get_name(sky(info(FORM_FACTOR.USB_C_NANO)), kt) == "Security Key C Nano"
-    assert get_name(sky(info(FORM_FACTOR.USB_C_LIGHTNING)), kt) == "Security Key Ci"
-    assert get_name(sky(info(FORM_FACTOR.UNKNOWN)), kt) == "Security Key"
-    assert get_name(sky(info_nfc(FORM_FACTOR.UNKNOWN)), kt) == "Security Key NFC"
-
-
-def skyep(device_info):
-    device_info.is_sky = True
-    device_info.serial = 123456
-    return device_info
-
-
-def test_sky_enterprise_formfactors():
-    kt = YUBIKEY.YK4
-    assert (
-        get_name(skyep(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt)
-        == "Security Key A - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt)
-        == "Security Key NFC - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info(FORM_FACTOR.USB_A_NANO)), kt)
-        == "Security Key Nano - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
-        == "Security Key C - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
-        == "Security Key C NFC - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info(FORM_FACTOR.USB_C_NANO)), kt)
-        == "Security Key C Nano - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info(FORM_FACTOR.USB_C_LIGHTNING)), kt)
-        == "Security Key Ci - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info(FORM_FACTOR.UNKNOWN)), kt)
-        == "Security Key - Enterprise Edition"
-    )
-    assert (
-        get_name(skyep(info_nfc(FORM_FACTOR.UNKNOWN)), kt)
-        == "Security Key NFC - Enterprise Edition"
-    )
+from yubikit.core import TRANSPORT, YUBIKEY
+from yubikit.management import (
+    CAPABILITY,
+    FORM_FACTOR,
+    DeviceInfo,
+    DeviceConfig,
+    Version,
+)
+from yubikit.support import get_name
+from typing import cast
+
+
+def info(form_factor):
+    return DeviceInfo(
+        config=cast(DeviceConfig, None),
+        serial=None,
+        version=Version(5, 3, 0),
+        form_factor=form_factor,
+        supported_capabilities={TRANSPORT.USB: 0xFF},  # type: ignore
+        is_locked=False,
+        is_fips=False,
+    )
+
+
+def info_nfc(form_factor):
+    with_nfc = info(form_factor)
+    with_nfc.supported_capabilities[TRANSPORT.NFC] = 0xFF
+    return with_nfc
+
+
+def test_yk5_formfactors():
+    kt = YUBIKEY.YK4
+    assert get_name(info(FORM_FACTOR.USB_A_KEYCHAIN), kt) == "YubiKey 5A"
+    assert get_name(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN), kt) == "YubiKey 5 NFC"
+    assert get_name(info(FORM_FACTOR.USB_A_NANO), kt) == "YubiKey 5 Nano"
+    assert get_name(info(FORM_FACTOR.USB_C_KEYCHAIN), kt) == "YubiKey 5C"
+    assert get_name(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN), kt) == "YubiKey 5C NFC"
+    assert get_name(info(FORM_FACTOR.USB_C_NANO), kt) == "YubiKey 5C Nano"
+    assert get_name(info(FORM_FACTOR.USB_C_LIGHTNING), kt) == "YubiKey 5Ci"
+    assert get_name(info(FORM_FACTOR.USB_A_BIO), kt) == "YubiKey Bio"
+    assert get_name(info(FORM_FACTOR.USB_C_BIO), kt) == "YubiKey C Bio"
+    assert get_name(info(FORM_FACTOR.UNKNOWN), kt) == "YubiKey 5"
+    assert get_name(info_nfc(FORM_FACTOR.UNKNOWN), kt) == "YubiKey 5 NFC"
+
+
+def fido(device_info):
+    device_info.supported_capabilities[TRANSPORT.USB] = (
+        CAPABILITY.U2F | CAPABILITY.FIDO2
+    )
+    if TRANSPORT.NFC in device_info.supported_capabilities:
+        device_info.supported_capabilities[TRANSPORT.NFC] = (
+            CAPABILITY.U2F | CAPABILITY.FIDO2
+        )
+    return device_info
+
+
+def test_yk5_fido():
+    kt = YUBIKEY.YK4
+    assert (
+        get_name(fido(info(FORM_FACTOR.USB_A_BIO)), kt) == "YubiKey Bio - FIDO Edition"
+    )
+    assert (
+        get_name(fido(info(FORM_FACTOR.USB_C_BIO)), kt)
+        == "YubiKey C Bio - FIDO Edition"
+    )
+
+
+def fips(device_info):
+    device_info.is_fips = True
+    return device_info
+
+
+def test_yk5_fips_formfactors():
+    kt = YUBIKEY.YK4
+    assert get_name(fips(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "YubiKey 5A FIPS"
+    assert (
+        get_name(fips(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "YubiKey 5 NFC FIPS"
+    )
+    assert get_name(fips(info(FORM_FACTOR.USB_A_NANO)), kt) == "YubiKey 5 Nano FIPS"
+    assert get_name(fips(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "YubiKey 5C FIPS"
+    assert (
+        get_name(fips(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
+        == "YubiKey 5C NFC FIPS"
+    )
+    assert get_name(fips(info(FORM_FACTOR.USB_C_NANO)), kt) == "YubiKey 5C Nano FIPS"
+    assert get_name(fips(info(FORM_FACTOR.USB_C_LIGHTNING)), kt) == "YubiKey 5Ci FIPS"
+    assert get_name(fips(info(FORM_FACTOR.USB_A_BIO)), kt) == "YubiKey Bio FIPS"
+    assert get_name(fips(info(FORM_FACTOR.USB_C_BIO)), kt) == "YubiKey C Bio FIPS"
+    assert get_name(fips(info(FORM_FACTOR.UNKNOWN)), kt) == "YubiKey 5 FIPS"
+    assert get_name(fips(info_nfc(FORM_FACTOR.UNKNOWN)), kt) == "YubiKey 5 NFC FIPS"
+
+
+def sky(device_info):
+    device_info.is_sky = True
+    return device_info
+
+
+def test_sky_formfactors():
+    kt = YUBIKEY.YK4
+    assert get_name(sky(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "Security Key A"
+    assert get_name(sky(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt) == "Security Key NFC"
+    assert get_name(sky(info(FORM_FACTOR.USB_A_NANO)), kt) == "Security Key Nano"
+    assert get_name(sky(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "Security Key C"
+    assert (
+        get_name(sky(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt) == "Security Key C NFC"
+    )
+    assert get_name(sky(info(FORM_FACTOR.USB_C_NANO)), kt) == "Security Key C Nano"
+    assert get_name(sky(info(FORM_FACTOR.USB_C_LIGHTNING)), kt) == "Security Key Ci"
+    assert get_name(sky(info(FORM_FACTOR.UNKNOWN)), kt) == "Security Key"
+    assert get_name(sky(info_nfc(FORM_FACTOR.UNKNOWN)), kt) == "Security Key NFC"
+
+
+def skyep(device_info):
+    device_info.is_sky = True
+    device_info.serial = 123456
+    return device_info
+
+
+def test_sky_enterprise_formfactors():
+    kt = YUBIKEY.YK4
+    assert (
+        get_name(skyep(info(FORM_FACTOR.USB_A_KEYCHAIN)), kt)
+        == "Security Key A - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info_nfc(FORM_FACTOR.USB_A_KEYCHAIN)), kt)
+        == "Security Key NFC - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info(FORM_FACTOR.USB_A_NANO)), kt)
+        == "Security Key Nano - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
+        == "Security Key C - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info_nfc(FORM_FACTOR.USB_C_KEYCHAIN)), kt)
+        == "Security Key C NFC - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info(FORM_FACTOR.USB_C_NANO)), kt)
+        == "Security Key C Nano - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info(FORM_FACTOR.USB_C_LIGHTNING)), kt)
+        == "Security Key Ci - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info(FORM_FACTOR.UNKNOWN)), kt)
+        == "Security Key - Enterprise Edition"
+    )
+    assert (
+        get_name(skyep(info_nfc(FORM_FACTOR.UNKNOWN)), kt)
+        == "Security Key NFC - Enterprise Edition"
+    )
```

### Comparing `yubikey_manager-5.1.0/tests/test_piv.py` & `yubikey_manager-5.1.1/tests/test_piv.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-from ykman.piv import generate_random_management_key, parse_rfc4514_string
-
-from yubikit.core import NotSupportedError, Version
-from yubikit.piv import (
-    KEY_TYPE,
-    MANAGEMENT_KEY_TYPE,
-    PIN_POLICY,
-    TOUCH_POLICY,
-    check_key_support,
-)
-
-import pytest
-
-
-@pytest.mark.parametrize(
-    "value",
-    [
-        r"UID=jsmith,DC=example,DC=net",
-        r"OU=Sales+CN=J.  Smith,DC=example,DC=net",
-        r"CN=James \"Jim\" Smith\, III,DC=example,DC=net",
-        r"CN=Before\0dAfter,DC=example,DC=net",
-        r"1.3.6.1.4.1.1466.0=#04024869",
-        r"CN=Lu\C4\8Di\C4\87",
-        r"1.2.840.113549.1.9.1=user@example.com",
-    ],
-)
-def test_parse_rfc4514_string(value):
-    name = parse_rfc4514_string(value)
-    name2 = parse_rfc4514_string(name.rfc4514_string())
-    assert name == name2
-
-
-class TestPivFunctions:
-    def test_generate_random_management_key(self):
-        output1 = generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES)
-        output2 = generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES)
-        assert isinstance(output1, bytes)
-        assert isinstance(output2, bytes)
-        assert output1 != output2
-
-        assert 24 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES))
-
-        assert 16 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES128))
-        assert 24 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES192))
-        assert 32 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES256))
-
-    def test_supported_algorithms(self):
-        with pytest.raises(NotSupportedError):
-            check_key_support(
-                Version(3, 1, 1),
-                KEY_TYPE.ECCP384,
-                PIN_POLICY.DEFAULT,
-                TOUCH_POLICY.DEFAULT,
-            )
-
-        with pytest.raises(NotSupportedError):
-            check_key_support(
-                Version(4, 4, 1),
-                KEY_TYPE.RSA1024,
-                PIN_POLICY.DEFAULT,
-                TOUCH_POLICY.DEFAULT,
-            )
-
-        for key_type in (KEY_TYPE.RSA1024, KEY_TYPE.RSA2048):
-            with pytest.raises(NotSupportedError):
-                check_key_support(
-                    Version(4, 3, 4), key_type, PIN_POLICY.DEFAULT, TOUCH_POLICY.DEFAULT
-                )
-
-        for key_type in KEY_TYPE:
-            check_key_support(
-                Version(5, 1, 0), key_type, PIN_POLICY.DEFAULT, TOUCH_POLICY.DEFAULT
-            )
+from ykman.piv import generate_random_management_key, parse_rfc4514_string
+
+from yubikit.core import NotSupportedError, Version
+from yubikit.piv import (
+    KEY_TYPE,
+    MANAGEMENT_KEY_TYPE,
+    PIN_POLICY,
+    TOUCH_POLICY,
+    check_key_support,
+)
+
+import pytest
+
+
+@pytest.mark.parametrize(
+    "value",
+    [
+        r"UID=jsmith,DC=example,DC=net",
+        r"OU=Sales+CN=J.  Smith,DC=example,DC=net",
+        r"CN=James \"Jim\" Smith\, III,DC=example,DC=net",
+        r"CN=Before\0dAfter,DC=example,DC=net",
+        r"1.3.6.1.4.1.1466.0=#04024869",
+        r"CN=Lu\C4\8Di\C4\87",
+        r"1.2.840.113549.1.9.1=user@example.com",
+    ],
+)
+def test_parse_rfc4514_string(value):
+    name = parse_rfc4514_string(value)
+    name2 = parse_rfc4514_string(name.rfc4514_string())
+    assert name == name2
+
+
+class TestPivFunctions:
+    def test_generate_random_management_key(self):
+        output1 = generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES)
+        output2 = generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES)
+        assert isinstance(output1, bytes)
+        assert isinstance(output2, bytes)
+        assert output1 != output2
+
+        assert 24 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.TDES))
+
+        assert 16 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES128))
+        assert 24 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES192))
+        assert 32 == len(generate_random_management_key(MANAGEMENT_KEY_TYPE.AES256))
+
+    def test_supported_algorithms(self):
+        with pytest.raises(NotSupportedError):
+            check_key_support(
+                Version(3, 1, 1),
+                KEY_TYPE.ECCP384,
+                PIN_POLICY.DEFAULT,
+                TOUCH_POLICY.DEFAULT,
+            )
+
+        with pytest.raises(NotSupportedError):
+            check_key_support(
+                Version(4, 4, 1),
+                KEY_TYPE.RSA1024,
+                PIN_POLICY.DEFAULT,
+                TOUCH_POLICY.DEFAULT,
+            )
+
+        for key_type in (KEY_TYPE.RSA1024, KEY_TYPE.RSA2048):
+            with pytest.raises(NotSupportedError):
+                check_key_support(
+                    Version(4, 3, 4), key_type, PIN_POLICY.DEFAULT, TOUCH_POLICY.DEFAULT
+                )
+
+        for key_type in KEY_TYPE:
+            check_key_support(
+                Version(5, 1, 0), key_type, PIN_POLICY.DEFAULT, TOUCH_POLICY.DEFAULT
+            )
```

### Comparing `yubikey_manager-5.1.0/tests/test_scancodes.py` & `yubikey_manager-5.1.1/tests/test_scancodes.py`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,348 +1,348 @@
-#  vim: set fileencoding=utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from __future__ import unicode_literals
-
-import unittest
-from ykman.scancodes import encode, KEYBOARD_LAYOUT
-
-
-class TestScanMap(unittest.TestCase):
-    def test_us_layout(self):
-        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x07", encode("d", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x08", encode("e", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x09", encode("f", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0b", encode("h", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0c", encode("i", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0d", encode("j", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0e", encode("k", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x0f", encode("l", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x11", encode("n", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x12", encode("o", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x13", encode("p", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x15", encode("r", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x17", encode("t", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1c", encode("y", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1d", encode("z", KEYBOARD_LAYOUT.US))
-
-        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x87", encode("D", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x88", encode("E", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x89", encode("F", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8b", encode("H", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8c", encode("I", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8d", encode("J", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8e", encode("K", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x8f", encode("L", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x91", encode("N", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x92", encode("O", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x93", encode("P", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x95", encode("R", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x97", encode("T", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x9c", encode("Y", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x9d", encode("Z", KEYBOARD_LAYOUT.US))
-
-        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.US))
-
-        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.US))
-
-        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb4", encode('"', KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa0", encode("#", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa4", encode("&", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x34", encode("'", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa6", encode("(", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa7", encode(")", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa5", encode("*", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xae", encode("+", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x35", encode("`", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x2d", encode("-", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x37", encode(".", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x38", encode("/", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb3", encode(":", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x33", encode(";", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb6", encode("<", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x2e", encode("=", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb7", encode(">", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb8", encode("?", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x9f", encode("@", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x2f", encode("[", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x32", encode("\\", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\x30", encode("]", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xa3", encode("^", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xad", encode("_", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xaf", encode("{", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb0", encode("}", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb2", encode("|", KEYBOARD_LAYOUT.US))
-        self.assertEqual(b"\xb5", encode("~", KEYBOARD_LAYOUT.US))
-
-        self.assertEqual(b"\x04\x05\x06", encode("abc", KEYBOARD_LAYOUT.US))
-        with self.assertRaises(ValueError):
-            encode("")
-
-    def test_de_layout(self):
-        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x07", encode("d", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x08", encode("e", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x09", encode("f", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0b", encode("h", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0c", encode("i", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0d", encode("j", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0e", encode("k", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x0f", encode("l", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x11", encode("n", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x12", encode("o", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x13", encode("p", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x15", encode("r", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x17", encode("t", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1d", encode("y", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1c", encode("z", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x87", encode("D", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x88", encode("E", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x89", encode("F", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8b", encode("H", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8c", encode("I", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8d", encode("J", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8e", encode("K", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x8f", encode("L", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x91", encode("N", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x92", encode("O", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x93", encode("P", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x95", encode("R", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x97", encode("T", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x9d", encode("Y", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x9c", encode("Z", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\x32", encode("#", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x30", encode("+", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x38", encode("-", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x64", encode("<", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x35", encode("^", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x2c", encode(" ", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x2e", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x2d", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x34", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x33", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x2f", encode("", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\x9f", encode('"', KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa3", encode("&", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb2", encode("'", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa5", encode("(", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa6", encode(")", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb0", encode("*", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa4", encode("/", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb7", encode(":", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb6", encode(";", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa7", encode("=", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xe4", encode(">", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xad", encode("?", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb8", encode("_", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xad", encode("`", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xa0", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb4", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xb3", encode("", KEYBOARD_LAYOUT.DE))
-        self.assertEqual(b"\xaf", encode("", KEYBOARD_LAYOUT.DE))
-
-        self.assertEqual(b"\xb4\xb3\xaf", encode("", KEYBOARD_LAYOUT.DE))
-        with self.assertRaises(ValueError):
-            encode("@", KEYBOARD_LAYOUT.DE)
-
-    def test_norman_layout(self):
-        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x08", encode("d", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x07", encode("e", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x15", encode("f", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x33", encode("h", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0e", encode("i", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1c", encode("j", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x17", encode("k", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x12", encode("l", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0d", encode("n", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0f", encode("o", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x11", encode("p", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0c", encode("r", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x09", encode("t", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x0b", encode("y", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1d", encode("z", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x88", encode("D", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x87", encode("E", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x95", encode("F", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb3", encode("H", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8e", encode("I", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x9c", encode("J", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x97", encode("K", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x92", encode("L", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8d", encode("N", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8f", encode("O", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x91", encode("P", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8c", encode("R", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x89", encode("T", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x8b", encode("Y", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x9d", encode("Z", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\xa0", encode("#", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xae", encode("+", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"-", encode("-", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb6", encode("<", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa3", encode("^", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x2c", encode(" ", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb4", encode('"', KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa4", encode("&", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"4", encode("'", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa6", encode("(", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa7", encode(")", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xa5", encode("*", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"8", encode("/", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb3", encode(":", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\x13", encode(";", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b".", encode("=", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb7", encode(">", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xb8", encode("?", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"\xad", encode("_", KEYBOARD_LAYOUT.NORMAN))
-        self.assertEqual(b"5", encode("`", KEYBOARD_LAYOUT.NORMAN))
-
-        self.assertEqual(b"\x04\x05\x06", encode("abc", KEYBOARD_LAYOUT.NORMAN))
-        with self.assertRaises(ValueError):
-            encode("")
+#  vim: set fileencoding=utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from __future__ import unicode_literals
+
+import unittest
+from ykman.scancodes import encode, KEYBOARD_LAYOUT
+
+
+class TestScanMap(unittest.TestCase):
+    def test_us_layout(self):
+        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x07", encode("d", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x08", encode("e", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x09", encode("f", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0b", encode("h", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0c", encode("i", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0d", encode("j", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0e", encode("k", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x0f", encode("l", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x11", encode("n", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x12", encode("o", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x13", encode("p", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x15", encode("r", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x17", encode("t", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1c", encode("y", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1d", encode("z", KEYBOARD_LAYOUT.US))
+
+        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x87", encode("D", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x88", encode("E", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x89", encode("F", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8b", encode("H", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8c", encode("I", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8d", encode("J", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8e", encode("K", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x8f", encode("L", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x91", encode("N", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x92", encode("O", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x93", encode("P", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x95", encode("R", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x97", encode("T", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x9c", encode("Y", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x9d", encode("Z", KEYBOARD_LAYOUT.US))
+
+        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.US))
+
+        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.US))
+
+        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb4", encode('"', KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa0", encode("#", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa4", encode("&", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x34", encode("'", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa6", encode("(", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa7", encode(")", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa5", encode("*", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xae", encode("+", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x35", encode("`", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x2d", encode("-", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x37", encode(".", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x38", encode("/", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb3", encode(":", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x33", encode(";", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb6", encode("<", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x2e", encode("=", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb7", encode(">", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb8", encode("?", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x9f", encode("@", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x2f", encode("[", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x32", encode("\\", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\x30", encode("]", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xa3", encode("^", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xad", encode("_", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xaf", encode("{", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb0", encode("}", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb2", encode("|", KEYBOARD_LAYOUT.US))
+        self.assertEqual(b"\xb5", encode("~", KEYBOARD_LAYOUT.US))
+
+        self.assertEqual(b"\x04\x05\x06", encode("abc", KEYBOARD_LAYOUT.US))
+        with self.assertRaises(ValueError):
+            encode("")
+
+    def test_de_layout(self):
+        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x07", encode("d", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x08", encode("e", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x09", encode("f", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0b", encode("h", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0c", encode("i", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0d", encode("j", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0e", encode("k", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x0f", encode("l", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x11", encode("n", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x12", encode("o", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x13", encode("p", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x15", encode("r", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x17", encode("t", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1d", encode("y", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1c", encode("z", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x87", encode("D", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x88", encode("E", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x89", encode("F", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8b", encode("H", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8c", encode("I", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8d", encode("J", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8e", encode("K", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x8f", encode("L", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x91", encode("N", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x92", encode("O", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x93", encode("P", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x95", encode("R", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x97", encode("T", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x9d", encode("Y", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x9c", encode("Z", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\x32", encode("#", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x30", encode("+", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x38", encode("-", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x64", encode("<", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x35", encode("^", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x2c", encode(" ", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x2e", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x2d", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x34", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x33", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x2f", encode("", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\x9f", encode('"', KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa3", encode("&", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb2", encode("'", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa5", encode("(", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa6", encode(")", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb0", encode("*", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa4", encode("/", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb7", encode(":", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb6", encode(";", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa7", encode("=", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xe4", encode(">", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xad", encode("?", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb8", encode("_", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xad", encode("`", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xa0", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb4", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xb3", encode("", KEYBOARD_LAYOUT.DE))
+        self.assertEqual(b"\xaf", encode("", KEYBOARD_LAYOUT.DE))
+
+        self.assertEqual(b"\xb4\xb3\xaf", encode("", KEYBOARD_LAYOUT.DE))
+        with self.assertRaises(ValueError):
+            encode("@", KEYBOARD_LAYOUT.DE)
+
+    def test_norman_layout(self):
+        self.assertEqual(b"\x04", encode("a", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x05", encode("b", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x06", encode("c", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x08", encode("d", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x07", encode("e", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x15", encode("f", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0a", encode("g", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x33", encode("h", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0e", encode("i", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1c", encode("j", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x17", encode("k", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x12", encode("l", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x10", encode("m", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0d", encode("n", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0f", encode("o", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x11", encode("p", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x14", encode("q", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0c", encode("r", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x16", encode("s", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x09", encode("t", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x18", encode("u", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x19", encode("v", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1a", encode("w", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1b", encode("x", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x0b", encode("y", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1d", encode("z", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\x84", encode("A", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x85", encode("B", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x86", encode("C", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x88", encode("D", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x87", encode("E", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x95", encode("F", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8a", encode("G", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb3", encode("H", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8e", encode("I", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x9c", encode("J", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x97", encode("K", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x92", encode("L", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x90", encode("M", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8d", encode("N", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8f", encode("O", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x91", encode("P", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x94", encode("Q", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8c", encode("R", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x96", encode("S", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x89", encode("T", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x98", encode("U", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x99", encode("V", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x9a", encode("W", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x9b", encode("X", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x8b", encode("Y", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x9d", encode("Z", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\x27", encode("0", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1e", encode("1", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x1f", encode("2", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x20", encode("3", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x21", encode("4", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x22", encode("5", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x23", encode("6", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x24", encode("7", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x25", encode("8", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x26", encode("9", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\x2b", encode("\t", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x28", encode("\n", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\xa0", encode("#", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xae", encode("+", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x36", encode(",", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"-", encode("-", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb6", encode("<", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa3", encode("^", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x2c", encode(" ", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\x9e", encode("!", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb4", encode('"', KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa1", encode("$", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa2", encode("%", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa4", encode("&", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"4", encode("'", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa6", encode("(", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa7", encode(")", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xa5", encode("*", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"8", encode("/", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb3", encode(":", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\x13", encode(";", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b".", encode("=", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb7", encode(">", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xb8", encode("?", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"\xad", encode("_", KEYBOARD_LAYOUT.NORMAN))
+        self.assertEqual(b"5", encode("`", KEYBOARD_LAYOUT.NORMAN))
+
+        self.assertEqual(b"\x04\x05\x06", encode("abc", KEYBOARD_LAYOUT.NORMAN))
+        with self.assertRaises(ValueError):
+            encode("")
```

### Comparing `yubikey_manager-5.1.0/tests/test_util.py` & `yubikey_manager-5.1.1/tests/test_util.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,155 +1,155 @@
-#  vim: set fileencoding=utf-8 :
-
-from yubikit.core import Tlv, bytes2int
-from yubikit.core.otp import modhex_encode, modhex_decode
-from yubikit.management import FORM_FACTOR
-from ykman.util import is_pkcs12, is_pem, parse_private_key, parse_certificates
-from ykman.util import _parse_pkcs12
-from ykman.otp import format_oath_code, generate_static_pw, time_challenge
-from .util import open_file
-
-import unittest
-
-
-class TestUtilityFunctions(unittest.TestCase):
-    def test_bytes2int(self):
-        self.assertEqual(0x57, bytes2int(b"\x57"))
-        self.assertEqual(0x1234, bytes2int(b"\x12\x34"))
-        self.assertEqual(0xCAFED00D, bytes2int(b"\xca\xfe\xd0\x0d"))
-
-    def test_format_oath_code(self):
-        self.assertEqual("000000", format_oath_code(b"\0" * 20))
-        self.assertEqual("00000000", format_oath_code(b"\0" * 20, 8))
-        self.assertEqual("345678", format_oath_code(b"\x00\xbc\x61\x4e" + b"\0" * 16))
-        self.assertEqual(
-            "34567890", format_oath_code(b"\x49\x96\x02\xd2" + b"\0" * 16, 8)
-        )
-
-    def test_generate_static_pw(self):
-        for i in range(0, 38):
-            self.assertRegex(
-                generate_static_pw(i), "^[cbdefghijklnrtuvCBDEFGHIJKLNRTUV]{%d}$" % i
-            )
-
-    def test_modhex_decode(self):
-        self.assertEqual(b"", modhex_decode(""))
-        self.assertEqual(b"\x2d\x34\x4e\x83", modhex_decode("dteffuje"))
-        self.assertEqual(
-            b"\x69\xb6\x48\x1c\x8b\xab\xa2\xb6\x0e\x8f\x22\x17\x9b\x58\xcd\x56",
-            modhex_decode("hknhfjbrjnlnldnhcujvddbikngjrtgh"),
-        )
-
-    def test_modhex_encode(self):
-        self.assertEqual("", modhex_encode(b""))
-        self.assertEqual("dteffuje", modhex_encode(b"\x2d\x34\x4e\x83"))
-        self.assertEqual(
-            "hknhfjbrjnlnldnhcujvddbikngjrtgh",
-            modhex_encode(
-                b"\x69\xb6\x48\x1c\x8b\xab\xa2\xb6" b"\x0e\x8f\x22\x17\x9b\x58\xcd\x56"
-            ),
-        )
-
-    def test_parse_tlvs(self):
-        tlvs = Tlv.parse_list(b"\x00\x02\xd0\x0d\xa1\x00\xfe\x04\xfe\xed\xfa\xce")
-        self.assertEqual(3, len(tlvs))
-
-        self.assertEqual(0, tlvs[0].tag)
-        self.assertEqual(2, tlvs[0].length)
-        self.assertEqual(b"\xd0\x0d", tlvs[0].value)
-
-        self.assertEqual(0xA1, tlvs[1].tag)
-        self.assertEqual(0, tlvs[1].length)
-        self.assertEqual(b"", tlvs[1].value)
-
-        self.assertEqual(0xFE, tlvs[2].tag)
-        self.assertEqual(4, tlvs[2].length)
-        self.assertEqual(b"\xfe\xed\xfa\xce", tlvs[2].value)
-
-    def test_time_challenge(self):
-        self.assertEqual(b"\0" * 8, time_challenge(0))
-        self.assertEqual(b"\x00\x00\x00\x00\x00\x06G\x82", time_challenge(12345678))
-        self.assertEqual(
-            b"\x00\x00\x00\x00\x02\xf2\xeaC",
-            time_challenge(1484223461.2644958),  # type: ignore
-        )
-
-    def test_tlv(self):
-        self.assertEqual(Tlv(b"\xfe\6foobar"), Tlv(0xFE, b"foobar"))
-
-        tlv1 = Tlv(b"\0\5hello")
-        tlv2 = Tlv(0xFE, b"")
-        tlv3 = Tlv(0x12, b"hi" * 200)
-
-        self.assertEqual(b"\0\5hello", tlv1)
-        self.assertEqual(b"\xfe\0", tlv2)
-        self.assertEqual(b"\x12\x82\x01\x90" + b"hi" * 200, tlv3)
-
-        self.assertEqual(
-            b"\0\5hello\xfe\0\x12\x82\x01\x90" + b"hi" * 200, tlv1 + tlv2 + tlv3
-        )
-
-    def test_is_pkcs12(self):
-        with self.assertRaises(TypeError):
-            is_pkcs12(None)
-
-        with open_file("rsa_2048_key.pem") as rsa_2048_key_pem:
-            self.assertFalse(is_pkcs12(rsa_2048_key_pem.read()))
-
-        with open_file("rsa_2048_key_encrypted.pem") as f:
-            self.assertFalse(is_pkcs12(f.read()))
-
-        with open_file("rsa_2048_cert.pem") as rsa_2048_cert_pem:
-            self.assertFalse(is_pkcs12(rsa_2048_cert_pem.read()))
-
-        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
-            data = rsa_2048_key_cert_pfx.read()
-        self.assertTrue(is_pkcs12(data))
-        parse_private_key(data, None)
-        parse_certificates(data, None)
-
-        with open_file(
-            "rsa_2048_key_cert_encrypted.pfx"
-        ) as rsa_2048_key_cert_encrypted_pfx:
-            self.assertTrue(is_pkcs12(rsa_2048_key_cert_encrypted_pfx.read()))
-
-    def test_parse_pkcs12(self):
-        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
-            data = rsa_2048_key_cert_pfx.read()
-
-        key, certs = _parse_pkcs12(data, None)
-        self.assertEqual(1, len(certs))
-
-    def test_is_pem(self):
-        self.assertFalse(is_pem(b"just a byte string"))
-        self.assertFalse(is_pem(None))
-
-        with open_file("rsa_2048_key.pem") as rsa_2048_key_pem:
-            self.assertTrue(is_pem(rsa_2048_key_pem.read()))
-
-        with open_file("rsa_2048_key_encrypted.pem") as f:
-            self.assertTrue(is_pem(f.read()))
-
-        with open_file("rsa_2048_cert.pem") as rsa_2048_cert_pem:
-            self.assertTrue(is_pem(rsa_2048_cert_pem.read()))
-
-        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
-            self.assertFalse(is_pem(rsa_2048_key_cert_pfx.read()))
-
-        with open_file("rsa_2048_cert_metadata.pem") as f:
-            self.assertTrue(is_pem(f.read()))
-
-        with open_file(
-            "rsa_2048_key_cert_encrypted.pfx"
-        ) as rsa_2048_key_cert_encrypted_pfx:
-            self.assertFalse(is_pem(rsa_2048_key_cert_encrypted_pfx.read()))
-
-    def test_form_factor_from_code(self):
-        with self.assertRaises(ValueError):
-            FORM_FACTOR.from_code("im a string")  # type: ignore
-        self.assertEqual(FORM_FACTOR.UNKNOWN, FORM_FACTOR.from_code(0x00))
-        self.assertEqual(FORM_FACTOR.USB_A_KEYCHAIN, FORM_FACTOR.from_code(0x01))
-        self.assertEqual(FORM_FACTOR.USB_A_NANO, FORM_FACTOR.from_code(0x02))
-        self.assertEqual(FORM_FACTOR.USB_C_KEYCHAIN, FORM_FACTOR.from_code(0x03))
-        self.assertEqual(FORM_FACTOR.USB_C_NANO, FORM_FACTOR.from_code(0x04))
-        self.assertEqual(FORM_FACTOR.USB_C_LIGHTNING, FORM_FACTOR.from_code(0x05))
-        self.assertEqual(FORM_FACTOR.UNKNOWN, FORM_FACTOR.from_code(0x99))
+#  vim: set fileencoding=utf-8 :
+
+from yubikit.core import Tlv, bytes2int
+from yubikit.core.otp import modhex_encode, modhex_decode
+from yubikit.management import FORM_FACTOR
+from ykman.util import is_pkcs12, is_pem, parse_private_key, parse_certificates
+from ykman.util import _parse_pkcs12
+from ykman.otp import format_oath_code, generate_static_pw, time_challenge
+from .util import open_file
+
+import unittest
+
+
+class TestUtilityFunctions(unittest.TestCase):
+    def test_bytes2int(self):
+        self.assertEqual(0x57, bytes2int(b"\x57"))
+        self.assertEqual(0x1234, bytes2int(b"\x12\x34"))
+        self.assertEqual(0xCAFED00D, bytes2int(b"\xca\xfe\xd0\x0d"))
+
+    def test_format_oath_code(self):
+        self.assertEqual("000000", format_oath_code(b"\0" * 20))
+        self.assertEqual("00000000", format_oath_code(b"\0" * 20, 8))
+        self.assertEqual("345678", format_oath_code(b"\x00\xbc\x61\x4e" + b"\0" * 16))
+        self.assertEqual(
+            "34567890", format_oath_code(b"\x49\x96\x02\xd2" + b"\0" * 16, 8)
+        )
+
+    def test_generate_static_pw(self):
+        for i in range(0, 38):
+            self.assertRegex(
+                generate_static_pw(i), "^[cbdefghijklnrtuvCBDEFGHIJKLNRTUV]{%d}$" % i
+            )
+
+    def test_modhex_decode(self):
+        self.assertEqual(b"", modhex_decode(""))
+        self.assertEqual(b"\x2d\x34\x4e\x83", modhex_decode("dteffuje"))
+        self.assertEqual(
+            b"\x69\xb6\x48\x1c\x8b\xab\xa2\xb6\x0e\x8f\x22\x17\x9b\x58\xcd\x56",
+            modhex_decode("hknhfjbrjnlnldnhcujvddbikngjrtgh"),
+        )
+
+    def test_modhex_encode(self):
+        self.assertEqual("", modhex_encode(b""))
+        self.assertEqual("dteffuje", modhex_encode(b"\x2d\x34\x4e\x83"))
+        self.assertEqual(
+            "hknhfjbrjnlnldnhcujvddbikngjrtgh",
+            modhex_encode(
+                b"\x69\xb6\x48\x1c\x8b\xab\xa2\xb6" b"\x0e\x8f\x22\x17\x9b\x58\xcd\x56"
+            ),
+        )
+
+    def test_parse_tlvs(self):
+        tlvs = Tlv.parse_list(b"\x00\x02\xd0\x0d\xa1\x00\xfe\x04\xfe\xed\xfa\xce")
+        self.assertEqual(3, len(tlvs))
+
+        self.assertEqual(0, tlvs[0].tag)
+        self.assertEqual(2, tlvs[0].length)
+        self.assertEqual(b"\xd0\x0d", tlvs[0].value)
+
+        self.assertEqual(0xA1, tlvs[1].tag)
+        self.assertEqual(0, tlvs[1].length)
+        self.assertEqual(b"", tlvs[1].value)
+
+        self.assertEqual(0xFE, tlvs[2].tag)
+        self.assertEqual(4, tlvs[2].length)
+        self.assertEqual(b"\xfe\xed\xfa\xce", tlvs[2].value)
+
+    def test_time_challenge(self):
+        self.assertEqual(b"\0" * 8, time_challenge(0))
+        self.assertEqual(b"\x00\x00\x00\x00\x00\x06G\x82", time_challenge(12345678))
+        self.assertEqual(
+            b"\x00\x00\x00\x00\x02\xf2\xeaC",
+            time_challenge(1484223461.2644958),  # type: ignore
+        )
+
+    def test_tlv(self):
+        self.assertEqual(Tlv(b"\xfe\6foobar"), Tlv(0xFE, b"foobar"))
+
+        tlv1 = Tlv(b"\0\5hello")
+        tlv2 = Tlv(0xFE, b"")
+        tlv3 = Tlv(0x12, b"hi" * 200)
+
+        self.assertEqual(b"\0\5hello", tlv1)
+        self.assertEqual(b"\xfe\0", tlv2)
+        self.assertEqual(b"\x12\x82\x01\x90" + b"hi" * 200, tlv3)
+
+        self.assertEqual(
+            b"\0\5hello\xfe\0\x12\x82\x01\x90" + b"hi" * 200, tlv1 + tlv2 + tlv3
+        )
+
+    def test_is_pkcs12(self):
+        with self.assertRaises(TypeError):
+            is_pkcs12(None)
+
+        with open_file("rsa_2048_key.pem") as rsa_2048_key_pem:
+            self.assertFalse(is_pkcs12(rsa_2048_key_pem.read()))
+
+        with open_file("rsa_2048_key_encrypted.pem") as f:
+            self.assertFalse(is_pkcs12(f.read()))
+
+        with open_file("rsa_2048_cert.pem") as rsa_2048_cert_pem:
+            self.assertFalse(is_pkcs12(rsa_2048_cert_pem.read()))
+
+        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
+            data = rsa_2048_key_cert_pfx.read()
+        self.assertTrue(is_pkcs12(data))
+        parse_private_key(data, None)
+        parse_certificates(data, None)
+
+        with open_file(
+            "rsa_2048_key_cert_encrypted.pfx"
+        ) as rsa_2048_key_cert_encrypted_pfx:
+            self.assertTrue(is_pkcs12(rsa_2048_key_cert_encrypted_pfx.read()))
+
+    def test_parse_pkcs12(self):
+        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
+            data = rsa_2048_key_cert_pfx.read()
+
+        key, certs = _parse_pkcs12(data, None)
+        self.assertEqual(1, len(certs))
+
+    def test_is_pem(self):
+        self.assertFalse(is_pem(b"just a byte string"))
+        self.assertFalse(is_pem(None))
+
+        with open_file("rsa_2048_key.pem") as rsa_2048_key_pem:
+            self.assertTrue(is_pem(rsa_2048_key_pem.read()))
+
+        with open_file("rsa_2048_key_encrypted.pem") as f:
+            self.assertTrue(is_pem(f.read()))
+
+        with open_file("rsa_2048_cert.pem") as rsa_2048_cert_pem:
+            self.assertTrue(is_pem(rsa_2048_cert_pem.read()))
+
+        with open_file("rsa_2048_key_cert.pfx") as rsa_2048_key_cert_pfx:
+            self.assertFalse(is_pem(rsa_2048_key_cert_pfx.read()))
+
+        with open_file("rsa_2048_cert_metadata.pem") as f:
+            self.assertTrue(is_pem(f.read()))
+
+        with open_file(
+            "rsa_2048_key_cert_encrypted.pfx"
+        ) as rsa_2048_key_cert_encrypted_pfx:
+            self.assertFalse(is_pem(rsa_2048_key_cert_encrypted_pfx.read()))
+
+    def test_form_factor_from_code(self):
+        with self.assertRaises(ValueError):
+            FORM_FACTOR.from_code("im a string")  # type: ignore
+        self.assertEqual(FORM_FACTOR.UNKNOWN, FORM_FACTOR.from_code(0x00))
+        self.assertEqual(FORM_FACTOR.USB_A_KEYCHAIN, FORM_FACTOR.from_code(0x01))
+        self.assertEqual(FORM_FACTOR.USB_A_NANO, FORM_FACTOR.from_code(0x02))
+        self.assertEqual(FORM_FACTOR.USB_C_KEYCHAIN, FORM_FACTOR.from_code(0x03))
+        self.assertEqual(FORM_FACTOR.USB_C_NANO, FORM_FACTOR.from_code(0x04))
+        self.assertEqual(FORM_FACTOR.USB_C_LIGHTNING, FORM_FACTOR.from_code(0x05))
+        self.assertEqual(FORM_FACTOR.UNKNOWN, FORM_FACTOR.from_code(0x99))
```

### Comparing `yubikey_manager-5.1.0/tests/util.py` & `yubikey_manager-5.1.1/tests/util.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,41 +1,41 @@
-import datetime
-import logging
-import os
-
-from cryptography import x509
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.asymmetric import ec
-from cryptography.x509.oid import NameOID
-
-
-logger = logging.getLogger(__name__)
-
-PKG_DIR = os.path.dirname(os.path.abspath(__file__))
-
-
-def open_file(*relative_path):
-    return open(os.path.join(PKG_DIR, "files", *relative_path), "rb")
-
-
-def generate_self_signed_certificate(
-    common_name="Test", valid_from=None, valid_to=None
-):
-
-    valid_from = valid_from if valid_from else datetime.datetime.utcnow()
-    valid_to = valid_to if valid_to else valid_from + datetime.timedelta(days=1)
-
-    private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
-    public_key = private_key.public_key()
-
-    subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, common_name)])
-
-    return (
-        x509.CertificateBuilder()
-        .public_key(public_key)
-        .subject_name(subject)
-        .issuer_name(subject)  # Same as subject on self-signed certificate.
-        .serial_number(x509.random_serial_number())
-        .not_valid_before(valid_from)
-        .not_valid_after(valid_to)
-    ).sign(private_key, hashes.SHA256(), default_backend())
+import datetime
+import logging
+import os
+
+from cryptography import x509
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import ec
+from cryptography.x509.oid import NameOID
+
+
+logger = logging.getLogger(__name__)
+
+PKG_DIR = os.path.dirname(os.path.abspath(__file__))
+
+
+def open_file(*relative_path):
+    return open(os.path.join(PKG_DIR, "files", *relative_path), "rb")
+
+
+def generate_self_signed_certificate(
+    common_name="Test", valid_from=None, valid_to=None
+):
+
+    valid_from = valid_from if valid_from else datetime.datetime.utcnow()
+    valid_to = valid_to if valid_to else valid_from + datetime.timedelta(days=1)
+
+    private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
+    public_key = private_key.public_key()
+
+    subject = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, common_name)])
+
+    return (
+        x509.CertificateBuilder()
+        .public_key(public_key)
+        .subject_name(subject)
+        .issuer_name(subject)  # Same as subject on self-signed certificate.
+        .serial_number(x509.random_serial_number())
+        .not_valid_before(valid_from)
+        .not_valid_after(valid_to)
+    ).sign(private_key, hashes.SHA256(), default_backend())
```

### Comparing `yubikey_manager-5.1.0/ykman/__init__.py` & `yubikey_manager-5.1.1/yubikit/core/fido.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,28 +1,35 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-__version__ = "5.1.0"
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from . import Connection, USB_INTERFACE
+from fido2.ctap import CtapDevice
+
+
+# Make CtapDevice a Connection
+FidoConnection = CtapDevice
+FidoConnection.usb_interface = USB_INTERFACE.FIDO
+Connection.register(FidoConnection)
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/__init__.py` & `yubikey_manager-5.1.1/ykman/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,26 +1,28 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+__version__ = "5.1.1"
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/__main__.py` & `yubikey_manager-5.1.1/ykman/_cli/__main__.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,385 +1,385 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import ApplicationNotAvailableError
-from yubikit.core.otp import OtpConnection
-from yubikit.core.fido import FidoConnection
-from yubikit.core.smartcard import SmartCardConnection
-from yubikit.support import get_name, read_info
-from yubikit.logging import LOG_LEVEL
-
-from .. import __version__
-from ..pcsc import list_devices as list_ccid, list_readers
-from ..device import scan_devices, list_all_devices
-from ..util import get_windows_version
-from ..logging import init_logging
-from ..diagnostics import get_diagnostics, sys_info
-from .util import YkmanContextObject, click_group, EnumChoice, CliFail, pretty_print
-from .info import info
-from .otp import otp
-from .openpgp import openpgp
-from .oath import oath
-from .piv import piv
-from .fido import fido
-from .config import config
-from .aliases import apply_aliases
-from .apdu import apdu
-from .script import run_script
-
-import click
-import ctypes
-import time
-import sys
-
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-CLICK_CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], max_content_width=999)
-
-
-WIN_CTAP_RESTRICTED = (
-    sys.platform == "win32"
-    and not bool(ctypes.windll.shell32.IsUserAnAdmin())
-    and get_windows_version() >= (10, 0, 18362)
-)
-
-
-def _scan_changes(state, attempts=10):
-    for _ in range(attempts):
-        time.sleep(0.25)
-        devices, new_state = scan_devices()
-        if new_state != state:
-            return devices, new_state
-    raise TimeoutError("Timed out waiting for state change")
-
-
-def print_version(ctx, param, value):
-    if not value or ctx.resilient_parsing:
-        return
-    click.echo(f"YubiKey Manager (ykman) version: {__version__}")
-    ctx.exit()
-
-
-def print_diagnostics(ctx, param, value):
-    if not value or ctx.resilient_parsing:
-        return
-    click.echo("\n".join(pretty_print(get_diagnostics())))
-    ctx.exit()
-
-
-def require_reader(connection_types, reader):
-    if SmartCardConnection in connection_types or FidoConnection in connection_types:
-        readers = list_ccid(reader)
-        if len(readers) == 1:
-            dev = readers[0]
-            try:
-                with dev.open_connection(SmartCardConnection) as conn:
-                    info = read_info(conn, dev.pid)
-                return dev, info
-            except Exception:
-                raise CliFail("Failed to connect to YubiKey")
-        elif len(readers) > 1:
-            raise CliFail("Multiple external readers match name.")
-        else:
-            raise CliFail("No YubiKey found on external reader.")
-    else:
-        raise CliFail("Not a CCID command.")
-
-
-def require_device(connection_types, serial=None):
-    # Find all connected devices
-    devices, state = scan_devices()
-    n_devs = sum(devices.values())
-    if serial is None:
-        if n_devs == 0:  # The device might not yet be ready, wait a bit
-            try:
-                devices, state = _scan_changes(state)
-                n_devs = sum(devices.values())
-            except TimeoutError:
-                raise CliFail("No YubiKey detected!")
-        if n_devs > 1:
-            raise CliFail(
-                "Multiple YubiKeys detected. Use --device SERIAL to specify "
-                "which one to use."
-            )
-
-        # Only one connected device, check if any needed interfaces are available
-        pid = next(iter(devices.keys()))
-        supported = [c for c in connection_types if pid.supports_connection(c)]
-        if WIN_CTAP_RESTRICTED and supported == [FidoConnection]:
-            # FIDO-only command on Windows without Admin won't work.
-            raise CliFail("FIDO access on Windows requires running as Administrator.")
-        if not supported:
-            interfaces = [c.usb_interface for c in connection_types]
-            req = ", ".join(t.name or str(t) for t in interfaces)
-            raise CliFail(
-                f"Command requires one of the following USB interfaces "
-                f"to be enabled: '{req}'.\n\n"
-                "Use 'ykman config usb' to set the enabled USB interfaces."
-            )
-
-        devs = list_all_devices(supported)
-        if len(devs) != 1:
-            raise CliFail("Failed to connect to YubiKey.")
-        return devs[0]
-    else:
-        for _ in (0, 1):  # If no match initially, wait a bit for state change.
-            devs = list_all_devices(connection_types)
-            for dev, nfo in devs:
-                if nfo.serial == serial:
-                    return dev, nfo
-            devices, state = _scan_changes(state)
-
-        raise CliFail(
-            f"Failed connecting to a YubiKey with serial: {serial}.\n"
-            "Make sure the application has the required permissions.",
-        )
-
-
-@click_group(context_settings=CLICK_CONTEXT_SETTINGS)
-@click.option(
-    "-d",
-    "--device",
-    type=int,
-    metavar="SERIAL",
-    help="specify which YubiKey to interact with by serial number",
-)
-@click.option(
-    "-r",
-    "--reader",
-    help="specify a YubiKey by smart card reader name "
-    "(can't be used with --device or list)",
-    metavar="NAME",
-    default=None,
-)
-@click.option(
-    "-l",
-    "--log-level",
-    default=None,
-    type=EnumChoice(LOG_LEVEL, hidden=[LOG_LEVEL.NOTSET]),
-    help="enable logging at given verbosity level",
-)
-@click.option(
-    "--log-file",
-    default=None,
-    type=str,
-    metavar="FILE",
-    help="write log to FILE instead of printing to stderr (requires --log-level)",
-)
-@click.option(
-    "--diagnose",
-    is_flag=True,
-    callback=print_diagnostics,
-    expose_value=False,
-    is_eager=True,
-    help="show diagnostics information useful for troubleshooting",
-)
-@click.option(
-    "-v",
-    "--version",
-    is_flag=True,
-    callback=print_version,
-    expose_value=False,
-    is_eager=True,
-    help="show version information about the app",
-)
-@click.option(
-    "--full-help",
-    is_flag=True,
-    expose_value=False,
-    help="show --help output, including hidden commands",
-)
-@click.pass_context
-def cli(ctx, device, log_level, log_file, reader):
-    """
-    Configure your YubiKey via the command line.
-
-    Examples:
-
-    \b
-      List connected YubiKeys, only output serial number:
-      $ ykman list --serials
-
-    \b
-      Show information about YubiKey with serial number 0123456:
-      $ ykman --device 0123456 info
-    """
-    ctx.obj = YkmanContextObject()
-
-    if log_level:
-        init_logging(log_level, log_file=log_file)
-        logger.info("\n".join(pretty_print({"System info": sys_info()})))
-    elif log_file:
-        ctx.fail("--log-file requires specifying --log-level.")
-
-    if reader and device:
-        ctx.fail("--reader and --device options can't be combined.")
-
-    subcmd = next(c for c in COMMANDS if c.name == ctx.invoked_subcommand)
-    # Commands that don't directly act on a key
-    if subcmd in (list_keys,):
-        if device:
-            ctx.fail("--device can't be used with this command.")
-        if reader:
-            ctx.fail("--reader can't be used with this command.")
-        return
-
-    # Commands which need a YubiKey to act on
-    connections = getattr(
-        subcmd, "connections", [SmartCardConnection, FidoConnection, OtpConnection]
-    )
-    if connections:
-
-        def resolve():
-            if connections == [FidoConnection] and WIN_CTAP_RESTRICTED:
-                # FIDO-only command on Windows without Admin won't work.
-                raise CliFail(
-                    "FIDO access on Windows requires running as Administrator."
-                )
-
-            items = getattr(resolve, "items", None)
-            if not items:
-                if reader is not None:
-                    items = require_reader(connections, reader)
-                else:
-                    items = require_device(connections, device)
-                setattr(resolve, "items", items)
-            return items
-
-        ctx.obj.add_resolver("device", lambda: resolve()[0])
-        ctx.obj.add_resolver("pid", lambda: resolve()[0].pid)
-        ctx.obj.add_resolver("info", lambda: resolve()[1])
-
-
-@cli.command("list")
-@click.option(
-    "-s",
-    "--serials",
-    is_flag=True,
-    help="output only serial numbers, one per line "
-    "(devices without serial will be omitted)",
-)
-@click.option("-r", "--readers", is_flag=True, help="list available smart card readers")
-@click.pass_context
-def list_keys(ctx, serials, readers):
-    """
-    List connected YubiKeys.
-    """
-
-    if readers:
-        for reader in list_readers():
-            click.echo(reader.name)
-        ctx.exit()
-
-    # List all attached devices
-    pids = set()
-    for dev, dev_info in list_all_devices():
-        if serials:
-            if dev_info.serial:
-                click.echo(dev_info.serial)
-        else:
-            if dev.pid is None:  # Devices from list_all_devices should always have PID.
-                raise AssertionError("PID is None")
-            name = get_name(dev_info, dev.pid.yubikey_type)
-            version = dev_info.version or "unknown"
-            mode = dev.pid.name.split("_", 1)[1].replace("_", "+")
-            click.echo(
-                f"{name} ({version}) [{mode}]"
-                + (f" Serial: {dev_info.serial}" if dev_info.serial else "")
-            )
-        pids.add(dev.pid)
-
-    # Look for FIDO devices that we can't access
-    if not serials:
-        devs, _ = scan_devices()
-        for pid, count in devs.items():
-            if pid not in pids:
-                for _ in range(count):
-                    name = pid.yubikey_type.value
-                    mode = pid.name.split("_", 1)[1].replace("_", "+")
-                    click.echo(f"{name} [{mode}] <access denied>")
-
-
-COMMANDS = (list_keys, info, otp, openpgp, oath, piv, fido, config, apdu, run_script)
-
-
-for cmd in COMMANDS:
-    cli.add_command(cmd)
-
-
-class _DefaultFormatter(logging.Formatter):
-    def __init__(self, show_trace=False):
-        self.show_trace = show_trace
-
-    def format(self, record):
-        message = f"{record.levelname}: {record.getMessage()}"
-        if self.show_trace and record.exc_info:
-            message += self.formatException(record.exc_info)
-        return message
-
-
-def main():
-    # Set up default logging
-    handler = logging.StreamHandler()
-    handler.setLevel(logging.WARNING)
-    formatter = _DefaultFormatter()
-    handler.setFormatter(formatter)
-    logging.getLogger().addHandler(handler)
-
-    sys.argv = apply_aliases(sys.argv)
-    try:
-        # --full-help triggers --help, hidden commands will already have read it by now.
-        sys.argv[sys.argv.index("--full-help")] = "--help"
-    except ValueError:
-        pass  # No --full-help
-
-    try:
-        cli(obj={})
-    except Exception as e:
-        status = 1
-        if isinstance(e, CliFail):
-            status = e.status
-            msg = e.args[0]
-        elif isinstance(e, ApplicationNotAvailableError):
-            msg = (
-                "The functionality required for this command is not enabled or not "
-                "available on this YubiKey."
-            )
-        elif isinstance(e, ValueError):
-            msg = f"{e}"
-        else:
-            msg = "An unexpected error has occured"
-            formatter.show_trace = True
-        logger.exception(msg)
-        sys.exit(status)
-
-
-if __name__ == "__main__":
-    main()
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import ApplicationNotAvailableError
+from yubikit.core.otp import OtpConnection
+from yubikit.core.fido import FidoConnection
+from yubikit.core.smartcard import SmartCardConnection
+from yubikit.support import get_name, read_info
+from yubikit.logging import LOG_LEVEL
+
+from .. import __version__
+from ..pcsc import list_devices as list_ccid, list_readers
+from ..device import scan_devices, list_all_devices
+from ..util import get_windows_version
+from ..logging import init_logging
+from ..diagnostics import get_diagnostics, sys_info
+from .util import YkmanContextObject, click_group, EnumChoice, CliFail, pretty_print
+from .info import info
+from .otp import otp
+from .openpgp import openpgp
+from .oath import oath
+from .piv import piv
+from .fido import fido
+from .config import config
+from .aliases import apply_aliases
+from .apdu import apdu
+from .script import run_script
+
+import click
+import ctypes
+import time
+import sys
+
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+CLICK_CONTEXT_SETTINGS = dict(help_option_names=["-h", "--help"], max_content_width=999)
+
+
+WIN_CTAP_RESTRICTED = (
+    sys.platform == "win32"
+    and not bool(ctypes.windll.shell32.IsUserAnAdmin())
+    and get_windows_version() >= (10, 0, 18362)
+)
+
+
+def _scan_changes(state, attempts=10):
+    for _ in range(attempts):
+        time.sleep(0.25)
+        devices, new_state = scan_devices()
+        if new_state != state:
+            return devices, new_state
+    raise TimeoutError("Timed out waiting for state change")
+
+
+def print_version(ctx, param, value):
+    if not value or ctx.resilient_parsing:
+        return
+    click.echo(f"YubiKey Manager (ykman) version: {__version__}")
+    ctx.exit()
+
+
+def print_diagnostics(ctx, param, value):
+    if not value or ctx.resilient_parsing:
+        return
+    click.echo("\n".join(pretty_print(get_diagnostics())))
+    ctx.exit()
+
+
+def require_reader(connection_types, reader):
+    if SmartCardConnection in connection_types or FidoConnection in connection_types:
+        readers = list_ccid(reader)
+        if len(readers) == 1:
+            dev = readers[0]
+            try:
+                with dev.open_connection(SmartCardConnection) as conn:
+                    info = read_info(conn, dev.pid)
+                return dev, info
+            except Exception:
+                raise CliFail("Failed to connect to YubiKey")
+        elif len(readers) > 1:
+            raise CliFail("Multiple external readers match name.")
+        else:
+            raise CliFail("No YubiKey found on external reader.")
+    else:
+        raise CliFail("Not a CCID command.")
+
+
+def require_device(connection_types, serial=None):
+    # Find all connected devices
+    devices, state = scan_devices()
+    n_devs = sum(devices.values())
+    if serial is None:
+        if n_devs == 0:  # The device might not yet be ready, wait a bit
+            try:
+                devices, state = _scan_changes(state)
+                n_devs = sum(devices.values())
+            except TimeoutError:
+                raise CliFail("No YubiKey detected!")
+        if n_devs > 1:
+            raise CliFail(
+                "Multiple YubiKeys detected. Use --device SERIAL to specify "
+                "which one to use."
+            )
+
+        # Only one connected device, check if any needed interfaces are available
+        pid = next(iter(devices.keys()))
+        supported = [c for c in connection_types if pid.supports_connection(c)]
+        if WIN_CTAP_RESTRICTED and supported == [FidoConnection]:
+            # FIDO-only command on Windows without Admin won't work.
+            raise CliFail("FIDO access on Windows requires running as Administrator.")
+        if not supported:
+            interfaces = [c.usb_interface for c in connection_types]
+            req = ", ".join(t.name or str(t) for t in interfaces)
+            raise CliFail(
+                f"Command requires one of the following USB interfaces "
+                f"to be enabled: '{req}'.\n\n"
+                "Use 'ykman config usb' to set the enabled USB interfaces."
+            )
+
+        devs = list_all_devices(supported)
+        if len(devs) != 1:
+            raise CliFail("Failed to connect to YubiKey.")
+        return devs[0]
+    else:
+        for _ in (0, 1):  # If no match initially, wait a bit for state change.
+            devs = list_all_devices(connection_types)
+            for dev, nfo in devs:
+                if nfo.serial == serial:
+                    return dev, nfo
+            devices, state = _scan_changes(state)
+
+        raise CliFail(
+            f"Failed connecting to a YubiKey with serial: {serial}.\n"
+            "Make sure the application has the required permissions.",
+        )
+
+
+@click_group(context_settings=CLICK_CONTEXT_SETTINGS)
+@click.option(
+    "-d",
+    "--device",
+    type=int,
+    metavar="SERIAL",
+    help="specify which YubiKey to interact with by serial number",
+)
+@click.option(
+    "-r",
+    "--reader",
+    help="specify a YubiKey by smart card reader name "
+    "(can't be used with --device or list)",
+    metavar="NAME",
+    default=None,
+)
+@click.option(
+    "-l",
+    "--log-level",
+    default=None,
+    type=EnumChoice(LOG_LEVEL, hidden=[LOG_LEVEL.NOTSET]),
+    help="enable logging at given verbosity level",
+)
+@click.option(
+    "--log-file",
+    default=None,
+    type=str,
+    metavar="FILE",
+    help="write log to FILE instead of printing to stderr (requires --log-level)",
+)
+@click.option(
+    "--diagnose",
+    is_flag=True,
+    callback=print_diagnostics,
+    expose_value=False,
+    is_eager=True,
+    help="show diagnostics information useful for troubleshooting",
+)
+@click.option(
+    "-v",
+    "--version",
+    is_flag=True,
+    callback=print_version,
+    expose_value=False,
+    is_eager=True,
+    help="show version information about the app",
+)
+@click.option(
+    "--full-help",
+    is_flag=True,
+    expose_value=False,
+    help="show --help output, including hidden commands",
+)
+@click.pass_context
+def cli(ctx, device, log_level, log_file, reader):
+    """
+    Configure your YubiKey via the command line.
+
+    Examples:
+
+    \b
+      List connected YubiKeys, only output serial number:
+      $ ykman list --serials
+
+    \b
+      Show information about YubiKey with serial number 0123456:
+      $ ykman --device 0123456 info
+    """
+    ctx.obj = YkmanContextObject()
+
+    if log_level:
+        init_logging(log_level, log_file=log_file)
+        logger.info("\n".join(pretty_print({"System info": sys_info()})))
+    elif log_file:
+        ctx.fail("--log-file requires specifying --log-level.")
+
+    if reader and device:
+        ctx.fail("--reader and --device options can't be combined.")
+
+    subcmd = next(c for c in COMMANDS if c.name == ctx.invoked_subcommand)
+    # Commands that don't directly act on a key
+    if subcmd in (list_keys,):
+        if device:
+            ctx.fail("--device can't be used with this command.")
+        if reader:
+            ctx.fail("--reader can't be used with this command.")
+        return
+
+    # Commands which need a YubiKey to act on
+    connections = getattr(
+        subcmd, "connections", [SmartCardConnection, FidoConnection, OtpConnection]
+    )
+    if connections:
+
+        def resolve():
+            if connections == [FidoConnection] and WIN_CTAP_RESTRICTED:
+                # FIDO-only command on Windows without Admin won't work.
+                raise CliFail(
+                    "FIDO access on Windows requires running as Administrator."
+                )
+
+            items = getattr(resolve, "items", None)
+            if not items:
+                if reader is not None:
+                    items = require_reader(connections, reader)
+                else:
+                    items = require_device(connections, device)
+                setattr(resolve, "items", items)
+            return items
+
+        ctx.obj.add_resolver("device", lambda: resolve()[0])
+        ctx.obj.add_resolver("pid", lambda: resolve()[0].pid)
+        ctx.obj.add_resolver("info", lambda: resolve()[1])
+
+
+@cli.command("list")
+@click.option(
+    "-s",
+    "--serials",
+    is_flag=True,
+    help="output only serial numbers, one per line "
+    "(devices without serial will be omitted)",
+)
+@click.option("-r", "--readers", is_flag=True, help="list available smart card readers")
+@click.pass_context
+def list_keys(ctx, serials, readers):
+    """
+    List connected YubiKeys.
+    """
+
+    if readers:
+        for reader in list_readers():
+            click.echo(reader.name)
+        ctx.exit()
+
+    # List all attached devices
+    pids = set()
+    for dev, dev_info in list_all_devices():
+        if serials:
+            if dev_info.serial:
+                click.echo(dev_info.serial)
+        else:
+            if dev.pid is None:  # Devices from list_all_devices should always have PID.
+                raise AssertionError("PID is None")
+            name = get_name(dev_info, dev.pid.yubikey_type)
+            version = dev_info.version or "unknown"
+            mode = dev.pid.name.split("_", 1)[1].replace("_", "+")
+            click.echo(
+                f"{name} ({version}) [{mode}]"
+                + (f" Serial: {dev_info.serial}" if dev_info.serial else "")
+            )
+        pids.add(dev.pid)
+
+    # Look for FIDO devices that we can't access
+    if not serials:
+        devs, _ = scan_devices()
+        for pid, count in devs.items():
+            if pid not in pids:
+                for _ in range(count):
+                    name = pid.yubikey_type.value
+                    mode = pid.name.split("_", 1)[1].replace("_", "+")
+                    click.echo(f"{name} [{mode}] <access denied>")
+
+
+COMMANDS = (list_keys, info, otp, openpgp, oath, piv, fido, config, apdu, run_script)
+
+
+for cmd in COMMANDS:
+    cli.add_command(cmd)
+
+
+class _DefaultFormatter(logging.Formatter):
+    def __init__(self, show_trace=False):
+        self.show_trace = show_trace
+
+    def format(self, record):
+        message = f"{record.levelname}: {record.getMessage()}"
+        if self.show_trace and record.exc_info:
+            message += self.formatException(record.exc_info)
+        return message
+
+
+def main():
+    # Set up default logging
+    handler = logging.StreamHandler()
+    handler.setLevel(logging.WARNING)
+    formatter = _DefaultFormatter()
+    handler.setFormatter(formatter)
+    logging.getLogger().addHandler(handler)
+
+    sys.argv = apply_aliases(sys.argv)
+    try:
+        # --full-help triggers --help, hidden commands will already have read it by now.
+        sys.argv[sys.argv.index("--full-help")] = "--help"
+    except ValueError:
+        pass  # No --full-help
+
+    try:
+        cli(obj={})
+    except Exception as e:
+        status = 1
+        if isinstance(e, CliFail):
+            status = e.status
+            msg = e.args[0]
+        elif isinstance(e, ApplicationNotAvailableError):
+            msg = (
+                "The functionality required for this command is not enabled or not "
+                "available on this YubiKey."
+            )
+        elif isinstance(e, ValueError):
+            msg = f"{e}"
+        else:
+            msg = "An unexpected error has occured"
+            formatter.show_trace = True
+        logger.exception(msg)
+        sys.exit(status)
+
+
+if __name__ == "__main__":
+    main()
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/aliases.py` & `yubikey_manager-5.1.1/ykman/_cli/aliases.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,132 +1,132 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-import sys
-import logging
-
-"""
-Command line aliases to support commands which have moved.
-The old commands are no longer supported and will fail, but will show their replacement.
-"""
-
-
-logger = logging.getLogger(__name__)
-ignore = None
-
-
-def replace(*args):
-    def inner(argv, alias, match_at):
-        return argv[:match_at] + list(args) + argv[match_at + len(alias) :]
-
-    return inner
-
-
-def oath_access_remember(argv, alias, match_at):
-    args = ["oath", "access"]
-    for flag in ("-c", "--clear-all"):
-        if flag in argv:
-            argv.remove(flag)
-            args.extend(["forget", "--all"])
-            break
-    else:
-        for flag in ("-F", "--forget"):
-            if flag in argv:
-                argv.remove(flag)
-                args.append("forget")
-                break
-        else:
-            args.append("remember")
-    argv = argv[:match_at] + args + argv[match_at + len(alias) :]
-    return argv
-
-
-_aliases = (
-    (["config", "mode"], ignore),  # Avoid match on next line
-    (["mode"], replace("config", "mode")),
-    (["fido", "delete"], replace("fido", "credentials", "delete")),
-    (["fido", "list"], replace("fido", "credentials", "list")),
-    (["fido", "set-pin"], replace("fido", "access", "change-pin")),
-    (["fido", "unlock"], replace("fido", "access", "verify-pin")),
-    (["piv", "change-pin"], replace("piv", "access", "change-pin")),
-    (["piv", "change-puk"], replace("piv", "access", "change-puk")),
-    (
-        ["piv", "change-management-key"],
-        replace("piv", "access", "change-management-key"),
-    ),
-    (["piv", "set-pin-retries"], replace("piv", "access", "set-retries")),
-    (["piv", "unblock-pin"], replace("piv", "access", "unblock-pin")),
-    (["piv", "attest"], replace("piv", "keys", "attest")),
-    (["piv", "import-key"], replace("piv", "keys", "import")),
-    (["piv", "generate-key"], replace("piv", "keys", "generate")),
-    (["piv", "import-certificate"], replace("piv", "certificates", "import")),
-    (["piv", "export-certificate"], replace("piv", "certificates", "export")),
-    (["piv", "generate-certificate"], replace("piv", "certificates", "generate")),
-    (["piv", "delete-certificate"], replace("piv", "certificates", "delete")),
-    (["piv", "generate-csr"], replace("piv", "certificates", "request")),
-    (["piv", "read-object"], replace("piv", "objects", "export")),
-    (["piv", "write-object"], replace("piv", "objects", "import")),
-    (["piv", "set-chuid"], replace("piv", "objects", "generate", "chuid")),
-    (["piv", "set-ccc"], replace("piv", "objects", "generate", "ccc")),
-    (["openpgp", "set-pin-retries"], replace("openpgp", "access", "set-retries")),
-    (["openpgp", "import-certificate"], replace("openpgp", "certificates", "import")),
-    (["openpgp", "export-certificate"], replace("openpgp", "certificates", "export")),
-    (["openpgp", "delete-certificate"], replace("openpgp", "certificates", "delete")),
-    (["openpgp", "attest"], replace("openpgp", "keys", "attest")),
-    (
-        ["openpgp", "import-attestation-key"],
-        replace("openpgp", "keys", "import", "att"),
-    ),
-    (["openpgp", "set-touch"], replace("openpgp", "keys", "set-touch")),
-    (["oath", "add"], replace("oath", "accounts", "add")),
-    (["oath", "code"], replace("oath", "accounts", "code")),
-    (["oath", "delete"], replace("oath", "accounts", "delete")),
-    (["oath", "list"], replace("oath", "accounts", "list")),
-    (["oath", "uri"], replace("oath", "accounts", "uri")),
-    (["oath", "set-password"], replace("oath", "access", "change")),
-    (["oath", "remember-password"], oath_access_remember),
-)
-
-
-def _find_match(data, selection):
-    ln = len(selection)
-    for i in range(0, len(data) - ln + 1):
-        if data[i : i + ln] == selection:
-            return i
-
-
-def apply_aliases(argv):
-    for (alias, f) in _aliases:
-        i = _find_match(argv, alias)
-        if i is not None:
-            if f:
-                argv = f(argv, alias, i)
-                logger.exception(
-                    "This command has moved! Use ykman " + " ".join(argv[1:])
-                )
-                sys.exit(1)
-            break  # Only handle first match
-    return argv
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+import sys
+import logging
+
+"""
+Command line aliases to support commands which have moved.
+The old commands are no longer supported and will fail, but will show their replacement.
+"""
+
+
+logger = logging.getLogger(__name__)
+ignore = None
+
+
+def replace(*args):
+    def inner(argv, alias, match_at):
+        return argv[:match_at] + list(args) + argv[match_at + len(alias) :]
+
+    return inner
+
+
+def oath_access_remember(argv, alias, match_at):
+    args = ["oath", "access"]
+    for flag in ("-c", "--clear-all"):
+        if flag in argv:
+            argv.remove(flag)
+            args.extend(["forget", "--all"])
+            break
+    else:
+        for flag in ("-F", "--forget"):
+            if flag in argv:
+                argv.remove(flag)
+                args.append("forget")
+                break
+        else:
+            args.append("remember")
+    argv = argv[:match_at] + args + argv[match_at + len(alias) :]
+    return argv
+
+
+_aliases = (
+    (["config", "mode"], ignore),  # Avoid match on next line
+    (["mode"], replace("config", "mode")),
+    (["fido", "delete"], replace("fido", "credentials", "delete")),
+    (["fido", "list"], replace("fido", "credentials", "list")),
+    (["fido", "set-pin"], replace("fido", "access", "change-pin")),
+    (["fido", "unlock"], replace("fido", "access", "verify-pin")),
+    (["piv", "change-pin"], replace("piv", "access", "change-pin")),
+    (["piv", "change-puk"], replace("piv", "access", "change-puk")),
+    (
+        ["piv", "change-management-key"],
+        replace("piv", "access", "change-management-key"),
+    ),
+    (["piv", "set-pin-retries"], replace("piv", "access", "set-retries")),
+    (["piv", "unblock-pin"], replace("piv", "access", "unblock-pin")),
+    (["piv", "attest"], replace("piv", "keys", "attest")),
+    (["piv", "import-key"], replace("piv", "keys", "import")),
+    (["piv", "generate-key"], replace("piv", "keys", "generate")),
+    (["piv", "import-certificate"], replace("piv", "certificates", "import")),
+    (["piv", "export-certificate"], replace("piv", "certificates", "export")),
+    (["piv", "generate-certificate"], replace("piv", "certificates", "generate")),
+    (["piv", "delete-certificate"], replace("piv", "certificates", "delete")),
+    (["piv", "generate-csr"], replace("piv", "certificates", "request")),
+    (["piv", "read-object"], replace("piv", "objects", "export")),
+    (["piv", "write-object"], replace("piv", "objects", "import")),
+    (["piv", "set-chuid"], replace("piv", "objects", "generate", "chuid")),
+    (["piv", "set-ccc"], replace("piv", "objects", "generate", "ccc")),
+    (["openpgp", "set-pin-retries"], replace("openpgp", "access", "set-retries")),
+    (["openpgp", "import-certificate"], replace("openpgp", "certificates", "import")),
+    (["openpgp", "export-certificate"], replace("openpgp", "certificates", "export")),
+    (["openpgp", "delete-certificate"], replace("openpgp", "certificates", "delete")),
+    (["openpgp", "attest"], replace("openpgp", "keys", "attest")),
+    (
+        ["openpgp", "import-attestation-key"],
+        replace("openpgp", "keys", "import", "att"),
+    ),
+    (["openpgp", "set-touch"], replace("openpgp", "keys", "set-touch")),
+    (["oath", "add"], replace("oath", "accounts", "add")),
+    (["oath", "code"], replace("oath", "accounts", "code")),
+    (["oath", "delete"], replace("oath", "accounts", "delete")),
+    (["oath", "list"], replace("oath", "accounts", "list")),
+    (["oath", "uri"], replace("oath", "accounts", "uri")),
+    (["oath", "set-password"], replace("oath", "access", "change")),
+    (["oath", "remember-password"], oath_access_remember),
+)
+
+
+def _find_match(data, selection):
+    ln = len(selection)
+    for i in range(0, len(data) - ln + 1):
+        if data[i : i + ln] == selection:
+            return i
+
+
+def apply_aliases(argv):
+    for (alias, f) in _aliases:
+        i = _find_match(argv, alias)
+        if i is not None:
+            if f:
+                argv = f(argv, alias, i)
+                logger.exception(
+                    "This command has moved! Use ykman " + " ".join(argv[1:])
+                )
+                sys.exit(1)
+            break  # Only handle first match
+    return argv
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/apdu.py` & `yubikey_manager-5.1.1/ykman/_cli/apdu.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,182 +1,182 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from binascii import a2b_hex
-from yubikit.core.smartcard import (
-    SmartCardConnection,
-    SmartCardProtocol,
-    ApduError,
-    SW,
-    AID,
-)
-from .util import EnumChoice, CliFail, click_command
-from typing import Tuple, Optional
-
-import re
-import sys
-import click
-import struct
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-APDU_PATTERN = re.compile(
-    r"^"
-    r"(?P<cla>[0-9a-f]{2})?(?P<ins>[0-9a-f]{2})(?P<params>[0-9a-f]{4})?"
-    r"(?::(?P<body>(?:[0-9a-f]{2})+))?"
-    r"(?P<check>=(?P<sw>[0-9a-f]{4})?)?"
-    r"$",
-    re.IGNORECASE,
-)
-
-
-def _hex(data: bytes) -> str:
-    return " ".join(f"{d:02X}" for d in data)
-
-
-def _parse_apdu(data: str) -> Tuple[Tuple[int, int, int, int, bytes], Optional[int]]:
-    m = APDU_PATTERN.match(data)
-    if not m:
-        raise ValueError("Invalid APDU format: " + data)
-    cla = int(m.group("cla") or "00", 16)
-    ins = int(m.group("ins"), 16)
-    params = int(m.group("params") or "0000", 16)
-    body = a2b_hex(m.group("body") or "")
-    if m.group("check"):
-        sw: Optional[int] = int(m.group("sw") or "9000", 16)
-    else:
-        sw = None
-    p1, p2 = params >> 8, params & 0xFF
-    return (cla, ins, p1, p2, body), sw
-
-
-def _print_response(resp: bytes, sw: int, no_pretty: bool) -> None:
-    click.echo(f"RECV (SW={sw:04X})" + (":" if resp else ""))
-    if no_pretty:
-        click.echo(resp.hex().upper())
-    else:
-        for i in range(0, len(resp), 16):
-            chunk = resp[i : i + 16]
-            click.echo(
-                " ".join(f"{c:02X}" for c in chunk).ljust(50)
-                # Replace non-printable characters with a dot.
-                + "".join(chr(c) if 31 < c < 127 else chr(183) for c in chunk)
-            )
-
-
-@click_command(connections=[SmartCardConnection], hidden="--full-help" not in sys.argv)
-@click.pass_context
-@click.option(
-    "-x", "--no-pretty", is_flag=True, help="print only the hex output of a response"
-)
-@click.option(
-    "-a",
-    "--app",
-    type=EnumChoice(AID),
-    required=False,
-    help="select application",
-)
-@click.argument("apdu", nargs=-1)
-@click.option("-s", "--send-apdu", multiple=True, help="provide full APDUs")
-def apdu(ctx, no_pretty, app, apdu, send_apdu):
-    """
-    Execute arbitary APDUs.
-    Provide APDUs as a hex encoded, space-separated list using the following syntax:
-    [CLA]INS[P1P2][:DATA][=EXPECTED_SW]
-
-    If not provided CLA, P1 and P2 are all set to zero.
-    Setting EXPECTED_SW will cause the command to check the response SW an fail if it
-    differs. "=" can be used as shorthand for "=9000" (SW=OK).
-
-    Examples:
-
-    \b
-      Select the OATH application, send a LIST instruction (0xA1), and make sure we get
-      sw=9000 (these are equivalent):
-      $ ykman apdu a40400:a000000527210101=9000 a1=9000
-        or
-      $ ykman apdu -a oath a1=
-
-    \b
-      Factory reset the OATH application:
-      $ ykman apdu -a oath 04dead
-        or
-      $ ykman apdu a40400:a000000527210101 04dead
-        or (using full-apdu mode)
-      $ ykman apdu -s 00a4040008a000000527210101 -s 0004dead
-    """
-    if apdu and send_apdu:
-        ctx.fail("Cannot mix positional APDUs and -s/--send-apdu.")
-    elif not send_apdu:
-        apdus = [_parse_apdu(data) for data in apdu]
-        if not apdus and not app:
-            ctx.fail("No commands provided.")
-
-    dev = ctx.obj["device"]
-    with dev.open_connection(SmartCardConnection) as conn:
-        protocol = SmartCardProtocol(conn)
-        is_first = True
-
-        if app:
-            is_first = False
-            click.echo("SELECT AID: " + _hex(app))
-            resp = protocol.select(app)
-            _print_response(resp, SW.OK, no_pretty)
-
-        if send_apdu:  # Compatibility mode (full APDUs)
-            for apdu in send_apdu:
-                if not is_first:
-                    click.echo()
-                else:
-                    is_first = False
-                apdu = a2b_hex(apdu)
-                click.echo("SEND: " + _hex(apdu))
-                resp, sw = protocol.connection.send_and_receive(apdu)
-                _print_response(resp, sw, no_pretty)
-        else:  # Standard mode
-            for apdu, check in apdus:
-                if not is_first:
-                    click.echo()
-                else:
-                    is_first = False
-                header, body = apdu[:4], apdu[4]
-                req = _hex(struct.pack(">BBBB", *header))
-                if body:
-                    req += " -- " + _hex(body)
-                click.echo("SEND: " + req)
-                try:
-                    resp = protocol.send_apdu(*apdu)
-                    sw = SW.OK
-                except ApduError as e:
-                    resp = e.data
-                    sw = e.sw
-                _print_response(resp, sw, no_pretty)
-
-                if check is not None and sw != check:
-                    raise CliFail(f"Aborted due to error (expected SW={check:04X}).")
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from binascii import a2b_hex
+from yubikit.core.smartcard import (
+    SmartCardConnection,
+    SmartCardProtocol,
+    ApduError,
+    SW,
+    AID,
+)
+from .util import EnumChoice, CliFail, click_command
+from typing import Tuple, Optional
+
+import re
+import sys
+import click
+import struct
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+APDU_PATTERN = re.compile(
+    r"^"
+    r"(?P<cla>[0-9a-f]{2})?(?P<ins>[0-9a-f]{2})(?P<params>[0-9a-f]{4})?"
+    r"(?::(?P<body>(?:[0-9a-f]{2})+))?"
+    r"(?P<check>=(?P<sw>[0-9a-f]{4})?)?"
+    r"$",
+    re.IGNORECASE,
+)
+
+
+def _hex(data: bytes) -> str:
+    return " ".join(f"{d:02X}" for d in data)
+
+
+def _parse_apdu(data: str) -> Tuple[Tuple[int, int, int, int, bytes], Optional[int]]:
+    m = APDU_PATTERN.match(data)
+    if not m:
+        raise ValueError("Invalid APDU format: " + data)
+    cla = int(m.group("cla") or "00", 16)
+    ins = int(m.group("ins"), 16)
+    params = int(m.group("params") or "0000", 16)
+    body = a2b_hex(m.group("body") or "")
+    if m.group("check"):
+        sw: Optional[int] = int(m.group("sw") or "9000", 16)
+    else:
+        sw = None
+    p1, p2 = params >> 8, params & 0xFF
+    return (cla, ins, p1, p2, body), sw
+
+
+def _print_response(resp: bytes, sw: int, no_pretty: bool) -> None:
+    click.echo(f"RECV (SW={sw:04X})" + (":" if resp else ""))
+    if no_pretty:
+        click.echo(resp.hex().upper())
+    else:
+        for i in range(0, len(resp), 16):
+            chunk = resp[i : i + 16]
+            click.echo(
+                " ".join(f"{c:02X}" for c in chunk).ljust(50)
+                # Replace non-printable characters with a dot.
+                + "".join(chr(c) if 31 < c < 127 else chr(183) for c in chunk)
+            )
+
+
+@click_command(connections=[SmartCardConnection], hidden="--full-help" not in sys.argv)
+@click.pass_context
+@click.option(
+    "-x", "--no-pretty", is_flag=True, help="print only the hex output of a response"
+)
+@click.option(
+    "-a",
+    "--app",
+    type=EnumChoice(AID),
+    required=False,
+    help="select application",
+)
+@click.argument("apdu", nargs=-1)
+@click.option("-s", "--send-apdu", multiple=True, help="provide full APDUs")
+def apdu(ctx, no_pretty, app, apdu, send_apdu):
+    """
+    Execute arbitary APDUs.
+    Provide APDUs as a hex encoded, space-separated list using the following syntax:
+    [CLA]INS[P1P2][:DATA][=EXPECTED_SW]
+
+    If not provided CLA, P1 and P2 are all set to zero.
+    Setting EXPECTED_SW will cause the command to check the response SW an fail if it
+    differs. "=" can be used as shorthand for "=9000" (SW=OK).
+
+    Examples:
+
+    \b
+      Select the OATH application, send a LIST instruction (0xA1), and make sure we get
+      sw=9000 (these are equivalent):
+      $ ykman apdu a40400:a000000527210101=9000 a1=9000
+        or
+      $ ykman apdu -a oath a1=
+
+    \b
+      Factory reset the OATH application:
+      $ ykman apdu -a oath 04dead
+        or
+      $ ykman apdu a40400:a000000527210101 04dead
+        or (using full-apdu mode)
+      $ ykman apdu -s 00a4040008a000000527210101 -s 0004dead
+    """
+    if apdu and send_apdu:
+        ctx.fail("Cannot mix positional APDUs and -s/--send-apdu.")
+    elif not send_apdu:
+        apdus = [_parse_apdu(data) for data in apdu]
+        if not apdus and not app:
+            ctx.fail("No commands provided.")
+
+    dev = ctx.obj["device"]
+    with dev.open_connection(SmartCardConnection) as conn:
+        protocol = SmartCardProtocol(conn)
+        is_first = True
+
+        if app:
+            is_first = False
+            click.echo("SELECT AID: " + _hex(app))
+            resp = protocol.select(app)
+            _print_response(resp, SW.OK, no_pretty)
+
+        if send_apdu:  # Compatibility mode (full APDUs)
+            for apdu in send_apdu:
+                if not is_first:
+                    click.echo()
+                else:
+                    is_first = False
+                apdu = a2b_hex(apdu)
+                click.echo("SEND: " + _hex(apdu))
+                resp, sw = protocol.connection.send_and_receive(apdu)
+                _print_response(resp, sw, no_pretty)
+        else:  # Standard mode
+            for apdu, check in apdus:
+                if not is_first:
+                    click.echo()
+                else:
+                    is_first = False
+                header, body = apdu[:4], apdu[4]
+                req = _hex(struct.pack(">BBBB", *header))
+                if body:
+                    req += " -- " + _hex(body)
+                click.echo("SEND: " + req)
+                try:
+                    resp = protocol.send_apdu(*apdu)
+                    sw = SW.OK
+                except ApduError as e:
+                    resp = e.data
+                    sw = e.sw
+                _print_response(resp, sw, no_pretty)
+
+                if check is not None and sw != check:
+                    raise CliFail(f"Aborted due to error (expected SW={check:04X}).")
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/config.py` & `yubikey_manager-5.1.1/ykman/_cli/config.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,616 +1,619 @@
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import TRANSPORT, YUBIKEY
-from yubikit.core.otp import OtpConnection
-from yubikit.core.smartcard import SmartCardConnection
-from yubikit.core.fido import FidoConnection
-from yubikit.management import (
-    ManagementSession,
-    DeviceConfig,
-    CAPABILITY,
-    USB_INTERFACE,
-    DEVICE_FLAG,
-    Mode,
-)
-from .util import (
-    click_group,
-    click_postpone_execution,
-    click_force_option,
-    click_prompt,
-    EnumChoice,
-    CliFail,
-)
-import os
-import re
-import click
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-CLEAR_LOCK_CODE = b"\0" * 16
-
-
-def prompt_lock_code():
-    return click_prompt("Enter your lock code", hide_input=True)
-
-
-@click_group(connections=[SmartCardConnection, OtpConnection, FidoConnection])
-@click.pass_context
-@click_postpone_execution
-def config(ctx):
-    """
-    Enable or disable applications.
-
-    The applications may be enabled and disabled independently
-    over different transports (USB and NFC). The configuration may
-    also be protected by a lock code.
-
-    Examples:
-
-    \b
-      Disable PIV over NFC:
-      $ ykman config nfc --disable PIV
-
-    \b
-      Enable all applications over USB:
-      $ ykman config usb --enable-all
-
-    \b
-      Generate and set a random application lock code:
-      $ ykman config set-lock-code --generate
-    """
-    dev = ctx.obj["device"]
-    for conn_type in (SmartCardConnection, OtpConnection, FidoConnection):
-        if dev.supports_connection(conn_type):
-            try:
-                conn = dev.open_connection(conn_type)
-                ctx.call_on_close(conn.close)
-                ctx.obj["controller"] = ManagementSession(conn)
-                return
-            except Exception:
-                logger.warning(
-                    f"Failed connecting to the YubiKey over {conn_type}", exc_info=True
-                )
-    raise CliFail("Couldn't connect to the YubiKey.")
-
-
-def _require_config(ctx):
-    info = ctx.obj["info"]
-    if info.version < (5, 0, 0):
-        raise CliFail(
-            "Configuring applications is not supported on this YubiKey. "
-            "Use the `mode` command to configure USB interfaces."
-        )
-
-
-@config.command("set-lock-code")
-@click.pass_context
-@click_force_option
-@click.option("-l", "--lock-code", metavar="HEX", help="current lock code")
-@click.option(
-    "-n",
-    "--new-lock-code",
-    metavar="HEX",
-    help="new lock code (can't be used with --generate)",
-)
-@click.option("-c", "--clear", is_flag=True, help="clear the lock code")
-@click.option(
-    "-g",
-    "--generate",
-    is_flag=True,
-    help="generate a random lock code (can't be used with --new-lock-code)",
-)
-def set_lock_code(ctx, lock_code, new_lock_code, clear, generate, force):
-    """
-    Set or change the configuration lock code.
-
-    A lock code may be used to protect the application configuration.
-    The lock code must be a 32 characters (16 bytes) hex value.
-    """
-
-    _require_config(ctx)
-    info = ctx.obj["info"]
-    app = ctx.obj["controller"]
-
-    if sum(1 for arg in [new_lock_code, generate, clear] if arg) > 1:
-        raise CliFail(
-            "Invalid options: Only one of --new-lock-code, --generate, "
-            "and --clear may be used."
-        )
-
-    # Get the new lock code to set
-    if clear:
-        set_code = CLEAR_LOCK_CODE
-    elif generate:
-        set_code = os.urandom(16)
-        click.echo(f"Using a randomly generated lock code: {set_code.hex()}")
-        force or click.confirm(
-            "Lock configuration with this lock code?", abort=True, err=True
-        )
-    else:
-        if not new_lock_code:
-            new_lock_code = click_prompt(
-                "Enter your new lock code", hide_input=True, confirmation_prompt=True
-            )
-        set_code = _parse_lock_code(ctx, new_lock_code)
-
-    # Get the current lock code to use
-    if info.is_locked:
-        if not lock_code:
-            lock_code = click_prompt("Enter your current lock code", hide_input=True)
-        use_code = _parse_lock_code(ctx, lock_code)
-    else:
-        if lock_code:
-            raise CliFail(
-                "No lock code is currently set. Use --new-lock-code to set one."
-            )
-        use_code = None
-
-    # Set new lock code
-    try:
-        app.write_device_config(
-            None,
-            False,
-            use_code,
-            set_code,
-        )
-        logger.info("Lock code updated")
-    except Exception:
-        if info.is_locked:
-            raise CliFail("Failed to change the lock code. Wrong current code?")
-        raise CliFail("Failed to set the lock code.")
-
-
-def _configure_applications(
-    ctx,
-    config,
-    changes,
-    transport,
-    enable,
-    disable,
-    lock_code,
-    force,
-):
-    _require_config(ctx)
-
-    info = ctx.obj["info"]
-    supported = info.supported_capabilities.get(transport)
-    enabled = info.config.enabled_capabilities.get(transport)
-
-    if enable & disable:
-        ctx.fail("Invalid options.")
-
-    if not supported:
-        raise CliFail(f"{transport} not supported on this YubiKey.")
-
-    unsupported = ~supported & (enable | disable)
-    if unsupported:
-        raise CliFail(
-            f"{unsupported.display_name} not supported over {transport} on this "
-            "YubiKey."
-        )
-    new_enabled = (enabled | enable) & ~disable
-
-    if transport == TRANSPORT.USB:
-        if sum(CAPABILITY) & new_enabled == 0:
-            ctx.fail(f"Can not disable all applications over {transport}.")
-
-        reboot = enabled.usb_interfaces != new_enabled.usb_interfaces
-    else:
-        reboot = False
-
-    if enable:
-        changes.append(f"Enable {enable.display_name}")
-    if disable:
-        changes.append(f"Disable {disable.display_name}")
-    if reboot:
-        changes.append("The YubiKey will reboot")
-
-    is_locked = info.is_locked
-
-    if force and is_locked and not lock_code:
-        raise CliFail("Configuration is locked - please supply the --lock-code option.")
-    if lock_code and not is_locked:
-        raise CliFail(
-            "Configuration is not locked - please remove the --lock-code option."
-        )
-
-    click.echo(f"{transport} configuration changes:")
-    for change in changes:
-        click.echo(f"  {change}")
-    force or click.confirm("Proceed?", abort=True, err=True)
-
-    if is_locked and not lock_code:
-        lock_code = prompt_lock_code()
-
-    if lock_code:
-        lock_code = _parse_lock_code(ctx, lock_code)
-
-    config.enabled_capabilities = {transport: new_enabled}
-
-    app = ctx.obj["controller"]
-    try:
-        app.write_device_config(
-            config,
-            reboot,
-            lock_code,
-        )
-        logger.info(f"{transport} application configuration updated")
-    except Exception:
-        raise CliFail(f"Failed to configure {transport} applications.")
-
-
-@config.command()
-@click.pass_context
-@click_force_option
-@click.option(
-    "-e",
-    "--enable",
-    multiple=True,
-    type=EnumChoice(CAPABILITY),
-    help="enable applications",
-)
-@click.option(
-    "-d",
-    "--disable",
-    multiple=True,
-    type=EnumChoice(CAPABILITY),
-    help="disable applications",
-)
-@click.option(
-    "-l", "--list", "list_enabled", is_flag=True, help="list enabled applications"
-)
-@click.option("-a", "--enable-all", is_flag=True, help="enable all applications")
-@click.option(
-    "-L",
-    "--lock-code",
-    metavar="HEX",
-    help="current application configuration lock code",
-)
-@click.option(
-    "--touch-eject",
-    is_flag=True,
-    help="when set, the button toggles the state"
-    " of the smartcard between ejected and inserted (CCID only)",
-)
-@click.option("--no-touch-eject", is_flag=True, help="disable touch eject (CCID only)")
-@click.option(
-    "--autoeject-timeout",
-    required=False,
-    type=int,
-    default=None,
-    metavar="SECONDS",
-    help="when set, the smartcard will automatically eject"
-    " after the given time (implies --touch-eject)",
-)
-@click.option(
-    "--chalresp-timeout",
-    required=False,
-    type=int,
-    default=None,
-    metavar="SECONDS",
-    help="sets the timeout when waiting for touch for challenge-response in the OTP "
-    "application",
-)
-def usb(
-    ctx,
-    enable,
-    disable,
-    list_enabled,
-    enable_all,
-    touch_eject,
-    no_touch_eject,
-    autoeject_timeout,
-    chalresp_timeout,
-    lock_code,
-    force,
-):
-    """
-    Enable or disable applications over USB.
-    """
-    _require_config(ctx)
-
-    if not (
-        list_enabled
-        or enable_all
-        or enable
-        or disable
-        or touch_eject
-        or no_touch_eject
-        or autoeject_timeout
-        or chalresp_timeout
-    ):
-        ctx.fail("No configuration options chosen.")
-
-    if touch_eject and no_touch_eject:
-        ctx.fail("Invalid options.")
-
-    if list_enabled:
-        _list_apps(ctx, TRANSPORT.USB)
-
-    config = DeviceConfig({}, autoeject_timeout, chalresp_timeout, None)
-    changes = []
-    info = ctx.obj["info"]
-
-    if enable_all:
-        enable = info.supported_capabilities.get(TRANSPORT.USB)
-    else:
-        enable = CAPABILITY(sum(enable))
-    disable = CAPABILITY(sum(disable))
-
-    if touch_eject:
-        config.device_flags = info.config.device_flags | DEVICE_FLAG.EJECT
-        changes.append("Enable touch-eject")
-    if no_touch_eject:
-        config.device_flags = info.config.device_flags & ~DEVICE_FLAG.EJECT
-        changes.append("Disable touch-eject")
-    if autoeject_timeout:
-        changes.append(f"Set auto-eject timeout to {autoeject_timeout}")
-    if chalresp_timeout:
-        changes.append(f"Set challenge-response timeout to {chalresp_timeout}")
-
-    _configure_applications(
-        ctx,
-        config,
-        changes,
-        TRANSPORT.USB,
-        enable,
-        disable,
-        lock_code,
-        force,
-    )
-
-
-@config.command()
-@click.pass_context
-@click_force_option
-@click.option(
-    "-e",
-    "--enable",
-    multiple=True,
-    type=EnumChoice(CAPABILITY),
-    help="enable applications",
-)
-@click.option(
-    "-d",
-    "--disable",
-    multiple=True,
-    type=EnumChoice(CAPABILITY),
-    help="disable applications",
-)
-@click.option("-a", "--enable-all", is_flag=True, help="enable all applications")
-@click.option("-D", "--disable-all", is_flag=True, help="disable all applications")
-@click.option(
-    "-l", "--list", "list_enabled", is_flag=True, help="list enabled applications"
-)
-@click.option(
-    "-L",
-    "--lock-code",
-    metavar="HEX",
-    help="current application configuration lock code",
-)
-def nfc(ctx, enable, disable, enable_all, disable_all, list_enabled, lock_code, force):
-    """
-    Enable or disable applications over NFC.
-    """
-    _require_config(ctx)
-
-    if not (list_enabled or enable_all or enable or disable_all or disable):
-        ctx.fail("No configuration options chosen.")
-
-    if list_enabled:
-        _list_apps(ctx, TRANSPORT.NFC)
-
-    config = DeviceConfig({}, None, None, None)
-    info = ctx.obj["info"]
-
-    nfc_supported = info.supported_capabilities.get(TRANSPORT.NFC)
-    if enable_all:
-        enable = nfc_supported
-    else:
-        enable = CAPABILITY(sum(enable))
-    if disable_all:
-        disable = nfc_supported
-    else:
-        disable = CAPABILITY(sum(disable))
-
-    _configure_applications(
-        ctx,
-        config,
-        [],
-        TRANSPORT.NFC,
-        enable,
-        disable,
-        lock_code,
-        force,
-    )
-
-
-def _list_apps(ctx, transport):
-    enabled = ctx.obj["info"].config.enabled_capabilities.get(transport)
-    for app in CAPABILITY:
-        if app & enabled:
-            click.echo(app.display_name)
-    ctx.exit()
-
-
-def _ensure_not_invalid_options(ctx, enable, disable):
-    if enable & disable:
-        ctx.fail("Invalid options.")
-
-
-def _parse_lock_code(ctx, lock_code):
-    try:
-        lock_code = bytes.fromhex(lock_code)
-        if lock_code and len(lock_code) != 16:
-            ctx.fail("Lock code must be exactly 16 bytes (32 hexadecimal digits) long.")
-        return lock_code
-    except Exception:
-        ctx.fail("Lock code has the wrong format.")
-
-
-# MODE
-
-
-def _parse_interface_string(interface):
-    for iface in USB_INTERFACE:
-        if (iface.name or "").startswith(interface):
-            return iface
-    raise ValueError()
-
-
-def _parse_mode_string(ctx, param, mode):
-    try:
-        mode_int = int(mode)
-        return Mode.from_code(mode_int)
-    except IndexError:
-        ctx.fail(f"Invalid mode: {mode_int}")
-    except ValueError:
-        pass  # Not a numeric mode, parse string
-
-    try:
-        if mode[0] in ["+", "-"]:
-            info = ctx.obj["info"]
-            usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
-            interfaces = usb_enabled.usb_interfaces
-            for mod in re.findall(r"[+-][A-Z]+", mode.upper()):
-                interface = _parse_interface_string(mod[1:])
-                if mod.startswith("+"):
-                    interfaces |= interface
-                else:
-                    interfaces ^= interface
-        else:
-            interfaces = USB_INTERFACE(0)
-            for t in re.split(r"[+]+", mode.upper()):
-                if t:
-                    interfaces |= _parse_interface_string(t)
-    except ValueError:
-        ctx.fail(f"Invalid mode string: {mode}")
-
-    return Mode(interfaces)
-
-
-@config.command()
-@click.argument("mode", callback=_parse_mode_string)
-@click.option(
-    "--touch-eject",
-    is_flag=True,
-    help="when set, the button "
-    "toggles the state of the smartcard between ejected and inserted "
-    "(CCID only)",
-)
-@click.option(
-    "--autoeject-timeout",
-    required=False,
-    type=int,
-    default=0,
-    metavar="SECONDS",
-    help="when set, the smartcard will automatically eject after the given time "
-    "(implies --touch-eject, CCID only)",
-)
-@click.option(
-    "--chalresp-timeout",
-    required=False,
-    type=int,
-    default=0,
-    metavar="SECONDS",
-    help="sets the timeout when waiting for touch for challenge response",
-)
-@click_force_option
-@click.pass_context
-def mode(ctx, mode, touch_eject, autoeject_timeout, chalresp_timeout, force):
-    """
-    Manage connection modes (USB Interfaces).
-
-    This command is generaly used with YubiKeys prior to the 5 series.
-    Use "ykman config usb" for more granular control on YubiKey 5 and later.
-
-    Get the current connection mode of the YubiKey, or set it to MODE.
-
-    MODE can be a string, such as "OTP+FIDO+CCID", or a shortened form: "o+f+c".
-    It can also be a mode number.
-
-    Examples:
-
-    \b
-      Set the OTP and FIDO mode:
-      $ ykman config mode OTP+FIDO
-
-    \b
-      Set the CCID only mode and use touch to eject the smart card:
-      $ ykman config mode CCID --touch-eject
-    """
-    info = ctx.obj["info"]
-    mgmt = ctx.obj["controller"]
-    usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
-    my_mode = Mode(usb_enabled.usb_interfaces)
-    usb_supported = info.supported_capabilities[TRANSPORT.USB]
-    interfaces_supported = usb_supported.usb_interfaces
-    pid = ctx.obj["pid"]
-    if pid:
-        key_type = pid.yubikey_type
-    else:
-        key_type = None
-
-    if autoeject_timeout:  # autoeject implies touch eject
-        touch_eject = True
-    autoeject = autoeject_timeout if touch_eject else None
-
-    if mode.interfaces != USB_INTERFACE.CCID:
-        if touch_eject:
-            ctx.fail("--touch-eject can only be used when setting CCID-only mode")
-
-    if not force:
-        if mode == my_mode:
-            raise CliFail(f"Mode is already {mode}, nothing to do...", 0)
-        elif key_type in (YUBIKEY.YKS, YUBIKEY.YKP):
-            raise CliFail(
-                "Mode switching is not supported on this YubiKey!\n"
-                "Use --force to attempt to set it anyway."
-            )
-        elif mode.interfaces not in interfaces_supported:
-            raise CliFail(
-                f"Mode {mode} is not supported on this YubiKey!\n"
-                + "Use --force to attempt to set it anyway."
-            )
-        force or click.confirm(f"Set mode of YubiKey to {mode}?", abort=True, err=True)
-
-    try:
-        mgmt.set_mode(mode, chalresp_timeout, autoeject)
-        logger.info("USB mode updated")
-        click.echo(
-            "Mode set! You must remove and re-insert your YubiKey "
-            "for this change to take effect."
-        )
-    except Exception:
-        raise CliFail(
-            "Failed to switch mode on the YubiKey. Make sure your "
-            "YubiKey does not have an access code set."
-        )
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import TRANSPORT, YUBIKEY
+from yubikit.core.otp import OtpConnection
+from yubikit.core.smartcard import SmartCardConnection
+from yubikit.core.fido import FidoConnection
+from yubikit.management import (
+    ManagementSession,
+    DeviceConfig,
+    CAPABILITY,
+    USB_INTERFACE,
+    DEVICE_FLAG,
+    Mode,
+)
+from .util import (
+    click_group,
+    click_postpone_execution,
+    click_force_option,
+    click_prompt,
+    EnumChoice,
+    CliFail,
+)
+import os
+import re
+import click
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+CLEAR_LOCK_CODE = b"\0" * 16
+
+
+def prompt_lock_code():
+    return click_prompt("Enter your lock code", hide_input=True)
+
+
+@click_group(connections=[SmartCardConnection, OtpConnection, FidoConnection])
+@click.pass_context
+@click_postpone_execution
+def config(ctx):
+    """
+    Enable or disable applications.
+
+    The applications may be enabled and disabled independently
+    over different transports (USB and NFC). The configuration may
+    also be protected by a lock code.
+
+    Examples:
+
+    \b
+      Disable PIV over NFC:
+      $ ykman config nfc --disable PIV
+
+    \b
+      Enable all applications over USB:
+      $ ykman config usb --enable-all
+
+    \b
+      Generate and set a random application lock code:
+      $ ykman config set-lock-code --generate
+    """
+    dev = ctx.obj["device"]
+    for conn_type in (SmartCardConnection, OtpConnection, FidoConnection):
+        if dev.supports_connection(conn_type):
+            try:
+                conn = dev.open_connection(conn_type)
+                ctx.call_on_close(conn.close)
+                ctx.obj["controller"] = ManagementSession(conn)
+                return
+            except Exception:
+                logger.warning(
+                    f"Failed connecting to the YubiKey over {conn_type}", exc_info=True
+                )
+    raise CliFail("Couldn't connect to the YubiKey.")
+
+
+def _require_config(ctx):
+    info = ctx.obj["info"]
+    if info.version < (5, 0, 0):
+        raise CliFail(
+            "Configuring applications is not supported on this YubiKey. "
+            "Use the `mode` command to configure USB interfaces."
+        )
+
+
+@config.command("set-lock-code")
+@click.pass_context
+@click_force_option
+@click.option("-l", "--lock-code", metavar="HEX", help="current lock code")
+@click.option(
+    "-n",
+    "--new-lock-code",
+    metavar="HEX",
+    help="new lock code (can't be used with --generate)",
+)
+@click.option("-c", "--clear", is_flag=True, help="clear the lock code")
+@click.option(
+    "-g",
+    "--generate",
+    is_flag=True,
+    help="generate a random lock code (can't be used with --new-lock-code)",
+)
+def set_lock_code(ctx, lock_code, new_lock_code, clear, generate, force):
+    """
+    Set or change the configuration lock code.
+
+    A lock code may be used to protect the application configuration.
+    The lock code must be a 32 characters (16 bytes) hex value.
+    """
+
+    _require_config(ctx)
+    info = ctx.obj["info"]
+    app = ctx.obj["controller"]
+
+    if sum(1 for arg in [new_lock_code, generate, clear] if arg) > 1:
+        raise CliFail(
+            "Invalid options: Only one of --new-lock-code, --generate, "
+            "and --clear may be used."
+        )
+
+    # Get the new lock code to set
+    if clear:
+        set_code = CLEAR_LOCK_CODE
+    elif generate:
+        set_code = os.urandom(16)
+        click.echo(f"Using a randomly generated lock code: {set_code.hex()}")
+        force or click.confirm(
+            "Lock configuration with this lock code?", abort=True, err=True
+        )
+    else:
+        if not new_lock_code:
+            new_lock_code = click_prompt(
+                "Enter your new lock code", hide_input=True, confirmation_prompt=True
+            )
+        set_code = _parse_lock_code(ctx, new_lock_code)
+
+    # Get the current lock code to use
+    if info.is_locked:
+        if not lock_code:
+            lock_code = click_prompt("Enter your current lock code", hide_input=True)
+        use_code = _parse_lock_code(ctx, lock_code)
+    else:
+        if lock_code:
+            raise CliFail(
+                "No lock code is currently set. Use --new-lock-code to set one."
+            )
+        use_code = None
+
+    # Set new lock code
+    try:
+        app.write_device_config(
+            None,
+            False,
+            use_code,
+            set_code,
+        )
+        logger.info("Lock code updated")
+    except Exception:
+        if info.is_locked:
+            raise CliFail("Failed to change the lock code. Wrong current code?")
+        raise CliFail("Failed to set the lock code.")
+
+
+def _configure_applications(
+    ctx,
+    config,
+    changes,
+    transport,
+    enable,
+    disable,
+    lock_code,
+    force,
+):
+    _require_config(ctx)
+
+    info = ctx.obj["info"]
+    supported = info.supported_capabilities.get(transport)
+    enabled = info.config.enabled_capabilities.get(transport)
+
+    if not supported:
+        raise CliFail(f"{transport} not supported on this YubiKey.")
+
+    if enable & disable:
+        ctx.fail("Invalid options.")
+
+    unsupported = ~supported & (enable | disable)
+    if unsupported:
+        raise CliFail(
+            f"{unsupported.display_name} not supported over {transport} on this "
+            "YubiKey."
+        )
+    new_enabled = (enabled | enable) & ~disable
+
+    if transport == TRANSPORT.USB:
+        if sum(CAPABILITY) & new_enabled == 0:
+            ctx.fail(f"Can not disable all applications over {transport}.")
+
+        reboot = enabled.usb_interfaces != new_enabled.usb_interfaces
+    else:
+        reboot = False
+
+    if enable:
+        changes.append(f"Enable {enable.display_name}")
+    if disable:
+        changes.append(f"Disable {disable.display_name}")
+    if reboot:
+        changes.append("The YubiKey will reboot")
+
+    is_locked = info.is_locked
+
+    if force and is_locked and not lock_code:
+        raise CliFail("Configuration is locked - please supply the --lock-code option.")
+    if lock_code and not is_locked:
+        raise CliFail(
+            "Configuration is not locked - please remove the --lock-code option."
+        )
+
+    click.echo(f"{transport} configuration changes:")
+    for change in changes:
+        click.echo(f"  {change}")
+    force or click.confirm("Proceed?", abort=True, err=True)
+
+    if is_locked and not lock_code:
+        lock_code = prompt_lock_code()
+
+    if lock_code:
+        lock_code = _parse_lock_code(ctx, lock_code)
+
+    config.enabled_capabilities = {transport: new_enabled}
+
+    app = ctx.obj["controller"]
+    try:
+        app.write_device_config(
+            config,
+            reboot,
+            lock_code,
+        )
+        logger.info(f"{transport} application configuration updated")
+    except Exception:
+        raise CliFail(f"Failed to configure {transport} applications.")
+
+
+@config.command()
+@click.pass_context
+@click_force_option
+@click.option(
+    "-e",
+    "--enable",
+    multiple=True,
+    type=EnumChoice(CAPABILITY),
+    help="enable applications",
+)
+@click.option(
+    "-d",
+    "--disable",
+    multiple=True,
+    type=EnumChoice(CAPABILITY),
+    help="disable applications",
+)
+@click.option(
+    "-l", "--list", "list_enabled", is_flag=True, help="list enabled applications"
+)
+@click.option("-a", "--enable-all", is_flag=True, help="enable all applications")
+@click.option(
+    "-L",
+    "--lock-code",
+    metavar="HEX",
+    help="current application configuration lock code",
+)
+@click.option(
+    "--touch-eject",
+    is_flag=True,
+    help="when set, the button toggles the state"
+    " of the smartcard between ejected and inserted (CCID only)",
+)
+@click.option("--no-touch-eject", is_flag=True, help="disable touch eject (CCID only)")
+@click.option(
+    "--autoeject-timeout",
+    required=False,
+    type=int,
+    default=None,
+    metavar="SECONDS",
+    help="when set, the smartcard will automatically eject"
+    " after the given time (implies --touch-eject)",
+)
+@click.option(
+    "--chalresp-timeout",
+    required=False,
+    type=int,
+    default=None,
+    metavar="SECONDS",
+    help="sets the timeout when waiting for touch for challenge-response in the OTP "
+    "application",
+)
+def usb(
+    ctx,
+    enable,
+    disable,
+    list_enabled,
+    enable_all,
+    touch_eject,
+    no_touch_eject,
+    autoeject_timeout,
+    chalresp_timeout,
+    lock_code,
+    force,
+):
+    """
+    Enable or disable applications over USB.
+    """
+    _require_config(ctx)
+
+    if not (
+        list_enabled
+        or enable_all
+        or enable
+        or disable
+        or touch_eject
+        or no_touch_eject
+        or autoeject_timeout
+        or chalresp_timeout
+    ):
+        ctx.fail("No configuration options chosen.")
+
+    if touch_eject and no_touch_eject:
+        ctx.fail("Invalid options.")
+
+    if list_enabled:
+        _list_apps(ctx, TRANSPORT.USB)
+
+    config = DeviceConfig({}, autoeject_timeout, chalresp_timeout, None)
+    changes = []
+    info = ctx.obj["info"]
+
+    if enable_all:
+        enable = info.supported_capabilities.get(TRANSPORT.USB)
+    else:
+        enable = CAPABILITY(sum(enable))
+    disable = CAPABILITY(sum(disable))
+
+    if touch_eject:
+        config.device_flags = info.config.device_flags | DEVICE_FLAG.EJECT
+        changes.append("Enable touch-eject")
+    if no_touch_eject:
+        config.device_flags = info.config.device_flags & ~DEVICE_FLAG.EJECT
+        changes.append("Disable touch-eject")
+    if autoeject_timeout:
+        changes.append(f"Set auto-eject timeout to {autoeject_timeout}")
+    if chalresp_timeout:
+        changes.append(f"Set challenge-response timeout to {chalresp_timeout}")
+
+    _configure_applications(
+        ctx,
+        config,
+        changes,
+        TRANSPORT.USB,
+        enable,
+        disable,
+        lock_code,
+        force,
+    )
+
+
+@config.command()
+@click.pass_context
+@click_force_option
+@click.option(
+    "-e",
+    "--enable",
+    multiple=True,
+    type=EnumChoice(CAPABILITY),
+    help="enable applications",
+)
+@click.option(
+    "-d",
+    "--disable",
+    multiple=True,
+    type=EnumChoice(CAPABILITY),
+    help="disable applications",
+)
+@click.option("-a", "--enable-all", is_flag=True, help="enable all applications")
+@click.option("-D", "--disable-all", is_flag=True, help="disable all applications")
+@click.option(
+    "-l", "--list", "list_enabled", is_flag=True, help="list enabled applications"
+)
+@click.option(
+    "-L",
+    "--lock-code",
+    metavar="HEX",
+    help="current application configuration lock code",
+)
+def nfc(ctx, enable, disable, enable_all, disable_all, list_enabled, lock_code, force):
+    """
+    Enable or disable applications over NFC.
+    """
+    _require_config(ctx)
+
+    if not (list_enabled or enable_all or enable or disable_all or disable):
+        ctx.fail("No configuration options chosen.")
+
+    if list_enabled:
+        _list_apps(ctx, TRANSPORT.NFC)
+
+    config = DeviceConfig({}, None, None, None)
+    info = ctx.obj["info"]
+
+    nfc_supported = info.supported_capabilities.get(TRANSPORT.NFC)
+    if enable_all:
+        enable = nfc_supported
+    else:
+        enable = CAPABILITY(sum(enable))
+    if disable_all:
+        disable = nfc_supported
+    else:
+        disable = CAPABILITY(sum(disable))
+
+    _configure_applications(
+        ctx,
+        config,
+        [],
+        TRANSPORT.NFC,
+        enable,
+        disable,
+        lock_code,
+        force,
+    )
+
+
+def _list_apps(ctx, transport):
+    enabled = ctx.obj["info"].config.enabled_capabilities.get(transport)
+    if enabled is None:
+        raise CliFail(f"{transport} not supported on this YubiKey.")
+
+    for app in CAPABILITY:
+        if app & enabled:
+            click.echo(app.display_name)
+    ctx.exit()
+
+
+def _ensure_not_invalid_options(ctx, enable, disable):
+    if enable & disable:
+        ctx.fail("Invalid options.")
+
+
+def _parse_lock_code(ctx, lock_code):
+    try:
+        lock_code = bytes.fromhex(lock_code)
+        if lock_code and len(lock_code) != 16:
+            ctx.fail("Lock code must be exactly 16 bytes (32 hexadecimal digits) long.")
+        return lock_code
+    except Exception:
+        ctx.fail("Lock code has the wrong format.")
+
+
+# MODE
+
+
+def _parse_interface_string(interface):
+    for iface in USB_INTERFACE:
+        if (iface.name or "").startswith(interface):
+            return iface
+    raise ValueError()
+
+
+def _parse_mode_string(ctx, param, mode):
+    try:
+        mode_int = int(mode)
+        return Mode.from_code(mode_int)
+    except IndexError:
+        ctx.fail(f"Invalid mode: {mode_int}")
+    except ValueError:
+        pass  # Not a numeric mode, parse string
+
+    try:
+        if mode[0] in ["+", "-"]:
+            info = ctx.obj["info"]
+            usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
+            interfaces = usb_enabled.usb_interfaces
+            for mod in re.findall(r"[+-][A-Z]+", mode.upper()):
+                interface = _parse_interface_string(mod[1:])
+                if mod.startswith("+"):
+                    interfaces |= interface
+                else:
+                    interfaces ^= interface
+        else:
+            interfaces = USB_INTERFACE(0)
+            for t in re.split(r"[+]+", mode.upper()):
+                if t:
+                    interfaces |= _parse_interface_string(t)
+    except ValueError:
+        ctx.fail(f"Invalid mode string: {mode}")
+
+    return Mode(interfaces)
+
+
+@config.command()
+@click.argument("mode", callback=_parse_mode_string)
+@click.option(
+    "--touch-eject",
+    is_flag=True,
+    help="when set, the button "
+    "toggles the state of the smartcard between ejected and inserted "
+    "(CCID only)",
+)
+@click.option(
+    "--autoeject-timeout",
+    required=False,
+    type=int,
+    default=0,
+    metavar="SECONDS",
+    help="when set, the smartcard will automatically eject after the given time "
+    "(implies --touch-eject, CCID only)",
+)
+@click.option(
+    "--chalresp-timeout",
+    required=False,
+    type=int,
+    default=0,
+    metavar="SECONDS",
+    help="sets the timeout when waiting for touch for challenge response",
+)
+@click_force_option
+@click.pass_context
+def mode(ctx, mode, touch_eject, autoeject_timeout, chalresp_timeout, force):
+    """
+    Manage connection modes (USB Interfaces).
+
+    This command is generaly used with YubiKeys prior to the 5 series.
+    Use "ykman config usb" for more granular control on YubiKey 5 and later.
+
+    Get the current connection mode of the YubiKey, or set it to MODE.
+
+    MODE can be a string, such as "OTP+FIDO+CCID", or a shortened form: "o+f+c".
+    It can also be a mode number.
+
+    Examples:
+
+    \b
+      Set the OTP and FIDO mode:
+      $ ykman config mode OTP+FIDO
+
+    \b
+      Set the CCID only mode and use touch to eject the smart card:
+      $ ykman config mode CCID --touch-eject
+    """
+    info = ctx.obj["info"]
+    mgmt = ctx.obj["controller"]
+    usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
+    my_mode = Mode(usb_enabled.usb_interfaces)
+    usb_supported = info.supported_capabilities[TRANSPORT.USB]
+    interfaces_supported = usb_supported.usb_interfaces
+    pid = ctx.obj["pid"]
+    if pid:
+        key_type = pid.yubikey_type
+    else:
+        key_type = None
+
+    if autoeject_timeout:  # autoeject implies touch eject
+        touch_eject = True
+    autoeject = autoeject_timeout if touch_eject else None
+
+    if mode.interfaces != USB_INTERFACE.CCID:
+        if touch_eject:
+            ctx.fail("--touch-eject can only be used when setting CCID-only mode")
+
+    if not force:
+        if mode == my_mode:
+            raise CliFail(f"Mode is already {mode}, nothing to do...", 0)
+        elif key_type in (YUBIKEY.YKS, YUBIKEY.YKP):
+            raise CliFail(
+                "Mode switching is not supported on this YubiKey!\n"
+                "Use --force to attempt to set it anyway."
+            )
+        elif mode.interfaces not in interfaces_supported:
+            raise CliFail(
+                f"Mode {mode} is not supported on this YubiKey!\n"
+                + "Use --force to attempt to set it anyway."
+            )
+        force or click.confirm(f"Set mode of YubiKey to {mode}?", abort=True, err=True)
+
+    try:
+        mgmt.set_mode(mode, chalresp_timeout, autoeject)
+        logger.info("USB mode updated")
+        click.echo(
+            "Mode set! You must remove and re-insert your YubiKey "
+            "for this change to take effect."
+        )
+    except Exception:
+        raise CliFail(
+            "Failed to switch mode on the YubiKey. Make sure your "
+            "YubiKey does not have an access code set."
+        )
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/info.py` & `yubikey_manager-5.1.1/ykman/_cli/info.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,203 +1,203 @@
-# Copyright (c) 2016 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import TRANSPORT
-from yubikit.core.otp import OtpConnection
-from yubikit.core.fido import FidoConnection
-from yubikit.core.smartcard import SmartCardConnection
-from yubikit.management import CAPABILITY, USB_INTERFACE
-from yubikit.yubiotp import YubiOtpSession
-from yubikit.oath import OathSession
-from yubikit.support import get_name
-
-from .util import CliFail, is_yk4_fips, click_command
-from ..otp import is_in_fips_mode as otp_in_fips_mode
-from ..oath import is_in_fips_mode as oath_in_fips_mode
-from ..fido import is_in_fips_mode as ctap_in_fips_mode
-from typing import List
-
-import click
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-def print_app_status_table(supported_apps, enabled_apps):
-    usb_supported = supported_apps.get(TRANSPORT.USB, 0)
-    usb_enabled = enabled_apps.get(TRANSPORT.USB, 0)
-    nfc_supported = supported_apps.get(TRANSPORT.NFC, 0)
-    nfc_enabled = enabled_apps.get(TRANSPORT.NFC, 0)
-    rows = []
-    for app in CAPABILITY:
-        if app & usb_supported:
-            if app & usb_enabled:
-                usb_status = "Enabled"
-            else:
-                usb_status = "Disabled"
-        else:
-            usb_status = "Not available"
-        if nfc_supported:
-            if app & nfc_supported:
-                if app & nfc_enabled:
-                    nfc_status = "Enabled"
-                else:
-                    nfc_status = "Disabled"
-            else:
-                nfc_status = "Not available"
-            rows.append([app.display_name, usb_status, nfc_status])
-        else:
-            rows.append([app.display_name, usb_status])
-
-    column_l: List[int] = []
-    for row in rows:
-        for idx, c in enumerate(row):
-            if len(column_l) > idx:
-                if len(c) > column_l[idx]:
-                    column_l[idx] = len(c)
-            else:
-                column_l.append(len(c))
-
-    f_apps = "Applications".ljust(column_l[0])
-    if nfc_supported:
-        f_USB = "USB".ljust(column_l[1])
-        f_NFC = "NFC".ljust(column_l[2])
-    f_table = ""
-
-    for row in rows:
-        for idx, c in enumerate(row):
-            f_table += f"{c.ljust(column_l[idx])}\t"
-        f_table = f_table.strip() + "\n"
-
-    if nfc_supported:
-        click.echo(f"{f_apps}\t{f_USB}\t{f_NFC}")
-    else:
-        click.echo(f"{f_apps}")
-    click.echo(f_table, nl=False)
-
-
-def get_overall_fips_status(device, info):
-    statuses = {}
-
-    usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
-
-    statuses["OTP"] = False
-    if usb_enabled & CAPABILITY.OTP:
-        with device.open_connection(OtpConnection) as conn:
-            otp_app = YubiOtpSession(conn)
-            statuses["OTP"] = otp_in_fips_mode(otp_app)
-
-    statuses["OATH"] = False
-    if usb_enabled & CAPABILITY.OATH:
-        with device.open_connection(SmartCardConnection) as conn:
-            oath_app = OathSession(conn)
-            statuses["OATH"] = oath_in_fips_mode(oath_app)
-
-    statuses["FIDO U2F"] = False
-    if usb_enabled & CAPABILITY.U2F:
-        with device.open_connection(FidoConnection) as conn:
-            statuses["FIDO U2F"] = ctap_in_fips_mode(conn)
-
-    return statuses
-
-
-def _check_fips_status(device, info):
-    fips_status = get_overall_fips_status(device, info)
-    click.echo()
-
-    click.echo(f"FIPS Approved Mode: {'Yes' if all(fips_status.values()) else 'No'}")
-
-    status_keys = list(fips_status.keys())
-    status_keys.sort()
-    for status_key in status_keys:
-        click.echo(f"  {status_key}: {'Yes' if fips_status[status_key] else 'No'}")
-
-
-@click.option(
-    "-c",
-    "--check-fips",
-    help="check if YubiKey is in FIPS Approved mode (YubiKey 4 FIPS only)",
-    is_flag=True,
-)
-@click_command(connections=[SmartCardConnection, OtpConnection, FidoConnection])
-@click.pass_context
-def info(ctx, check_fips):
-    """
-    Show general information.
-
-    Displays information about the attached YubiKey such as serial number,
-    firmware version, capabilities, etc.
-    """
-    info = ctx.obj["info"]
-    pid = ctx.obj["pid"]
-    if pid is None:
-        interfaces = None
-        key_type = None
-    else:
-        interfaces = pid.usb_interfaces
-        key_type = pid.yubikey_type
-    device_name = get_name(info, key_type)
-
-    click.echo(f"Device type: {device_name}")
-    if info.serial:
-        click.echo(f"Serial number: {info.serial}")
-    if info.version:
-        f_version = ".".join(str(x) for x in info.version)
-        click.echo(f"Firmware version: {f_version}")
-    else:
-        click.echo(
-            "Firmware version: Uncertain, re-run with only one YubiKey connected"
-        )
-
-    if info.form_factor:
-        click.echo(f"Form factor: {info.form_factor!s}")
-    if interfaces:
-        f_interfaces = ", ".join(
-            t.name or str(t) for t in USB_INTERFACE if t in USB_INTERFACE(interfaces)
-        )
-        click.echo(f"Enabled USB interfaces: {f_interfaces}")
-    if TRANSPORT.NFC in info.supported_capabilities:
-        f_nfc = (
-            "enabled"
-            if info.config.enabled_capabilities.get(TRANSPORT.NFC)
-            else "disabled"
-        )
-        click.echo(f"NFC transport is {f_nfc}.")
-    if info.is_locked:
-        click.echo("Configured capabilities are protected by a lock code.")
-    click.echo()
-
-    print_app_status_table(
-        info.supported_capabilities, info.config.enabled_capabilities
-    )
-
-    if check_fips:
-        if is_yk4_fips(info):
-            device = ctx.obj["device"]
-            _check_fips_status(device, info)
-        else:
-            raise CliFail("Unable to check FIPS Approved mode - Not a YubiKey 4 FIPS")
+# Copyright (c) 2016 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import TRANSPORT
+from yubikit.core.otp import OtpConnection
+from yubikit.core.fido import FidoConnection
+from yubikit.core.smartcard import SmartCardConnection
+from yubikit.management import CAPABILITY, USB_INTERFACE
+from yubikit.yubiotp import YubiOtpSession
+from yubikit.oath import OathSession
+from yubikit.support import get_name
+
+from .util import CliFail, is_yk4_fips, click_command
+from ..otp import is_in_fips_mode as otp_in_fips_mode
+from ..oath import is_in_fips_mode as oath_in_fips_mode
+from ..fido import is_in_fips_mode as ctap_in_fips_mode
+from typing import List
+
+import click
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+def print_app_status_table(supported_apps, enabled_apps):
+    usb_supported = supported_apps.get(TRANSPORT.USB, 0)
+    usb_enabled = enabled_apps.get(TRANSPORT.USB, 0)
+    nfc_supported = supported_apps.get(TRANSPORT.NFC, 0)
+    nfc_enabled = enabled_apps.get(TRANSPORT.NFC, 0)
+    rows = []
+    for app in CAPABILITY:
+        if app & usb_supported:
+            if app & usb_enabled:
+                usb_status = "Enabled"
+            else:
+                usb_status = "Disabled"
+        else:
+            usb_status = "Not available"
+        if nfc_supported:
+            if app & nfc_supported:
+                if app & nfc_enabled:
+                    nfc_status = "Enabled"
+                else:
+                    nfc_status = "Disabled"
+            else:
+                nfc_status = "Not available"
+            rows.append([app.display_name, usb_status, nfc_status])
+        else:
+            rows.append([app.display_name, usb_status])
+
+    column_l: List[int] = []
+    for row in rows:
+        for idx, c in enumerate(row):
+            if len(column_l) > idx:
+                if len(c) > column_l[idx]:
+                    column_l[idx] = len(c)
+            else:
+                column_l.append(len(c))
+
+    f_apps = "Applications".ljust(column_l[0])
+    if nfc_supported:
+        f_USB = "USB".ljust(column_l[1])
+        f_NFC = "NFC".ljust(column_l[2])
+    f_table = ""
+
+    for row in rows:
+        for idx, c in enumerate(row):
+            f_table += f"{c.ljust(column_l[idx])}\t"
+        f_table = f_table.strip() + "\n"
+
+    if nfc_supported:
+        click.echo(f"{f_apps}\t{f_USB}\t{f_NFC}")
+    else:
+        click.echo(f"{f_apps}")
+    click.echo(f_table, nl=False)
+
+
+def get_overall_fips_status(device, info):
+    statuses = {}
+
+    usb_enabled = info.config.enabled_capabilities[TRANSPORT.USB]
+
+    statuses["OTP"] = False
+    if usb_enabled & CAPABILITY.OTP:
+        with device.open_connection(OtpConnection) as conn:
+            otp_app = YubiOtpSession(conn)
+            statuses["OTP"] = otp_in_fips_mode(otp_app)
+
+    statuses["OATH"] = False
+    if usb_enabled & CAPABILITY.OATH:
+        with device.open_connection(SmartCardConnection) as conn:
+            oath_app = OathSession(conn)
+            statuses["OATH"] = oath_in_fips_mode(oath_app)
+
+    statuses["FIDO U2F"] = False
+    if usb_enabled & CAPABILITY.U2F:
+        with device.open_connection(FidoConnection) as conn:
+            statuses["FIDO U2F"] = ctap_in_fips_mode(conn)
+
+    return statuses
+
+
+def _check_fips_status(device, info):
+    fips_status = get_overall_fips_status(device, info)
+    click.echo()
+
+    click.echo(f"FIPS Approved Mode: {'Yes' if all(fips_status.values()) else 'No'}")
+
+    status_keys = list(fips_status.keys())
+    status_keys.sort()
+    for status_key in status_keys:
+        click.echo(f"  {status_key}: {'Yes' if fips_status[status_key] else 'No'}")
+
+
+@click.option(
+    "-c",
+    "--check-fips",
+    help="check if YubiKey is in FIPS Approved mode (YubiKey 4 FIPS only)",
+    is_flag=True,
+)
+@click_command(connections=[SmartCardConnection, OtpConnection, FidoConnection])
+@click.pass_context
+def info(ctx, check_fips):
+    """
+    Show general information.
+
+    Displays information about the attached YubiKey such as serial number,
+    firmware version, capabilities, etc.
+    """
+    info = ctx.obj["info"]
+    pid = ctx.obj["pid"]
+    if pid is None:
+        interfaces = None
+        key_type = None
+    else:
+        interfaces = pid.usb_interfaces
+        key_type = pid.yubikey_type
+    device_name = get_name(info, key_type)
+
+    click.echo(f"Device type: {device_name}")
+    if info.serial:
+        click.echo(f"Serial number: {info.serial}")
+    if info.version:
+        f_version = ".".join(str(x) for x in info.version)
+        click.echo(f"Firmware version: {f_version}")
+    else:
+        click.echo(
+            "Firmware version: Uncertain, re-run with only one YubiKey connected"
+        )
+
+    if info.form_factor:
+        click.echo(f"Form factor: {info.form_factor!s}")
+    if interfaces:
+        f_interfaces = ", ".join(
+            t.name or str(t) for t in USB_INTERFACE if t in USB_INTERFACE(interfaces)
+        )
+        click.echo(f"Enabled USB interfaces: {f_interfaces}")
+    if TRANSPORT.NFC in info.supported_capabilities:
+        f_nfc = (
+            "enabled"
+            if info.config.enabled_capabilities.get(TRANSPORT.NFC)
+            else "disabled"
+        )
+        click.echo(f"NFC transport is {f_nfc}.")
+    if info.is_locked:
+        click.echo("Configured capabilities are protected by a lock code.")
+    click.echo()
+
+    print_app_status_table(
+        info.supported_capabilities, info.config.enabled_capabilities
+    )
+
+    if check_fips:
+        if is_yk4_fips(info):
+            device = ctx.obj["device"]
+            _check_fips_status(device, info)
+        else:
+            raise CliFail("Unable to check FIPS Approved mode - Not a YubiKey 4 FIPS")
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/oath.py` & `yubikey_manager-5.1.1/ykman/_cli/oath.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,773 +1,773 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-import click
-import logging
-from .util import (
-    CliFail,
-    click_force_option,
-    click_postpone_execution,
-    click_callback,
-    click_parse_b32_key,
-    click_prompt,
-    click_group,
-    prompt_for_touch,
-    prompt_timeout,
-    EnumChoice,
-    is_yk4_fips,
-)
-from yubikit.core.smartcard import ApduError, SW, SmartCardConnection
-from yubikit.oath import (
-    OathSession,
-    CredentialData,
-    OATH_TYPE,
-    HASH_ALGORITHM,
-    parse_b32_key,
-    _format_cred_id,
-)
-from ..oath import is_steam, calculate_steam, is_hidden
-from ..settings import AppData
-
-
-logger = logging.getLogger(__name__)
-
-
-@click_group(connections=[SmartCardConnection])
-@click.pass_context
-@click_postpone_execution
-def oath(ctx):
-    """
-    Manage the OATH application.
-
-    Examples:
-
-    \b
-      Generate codes for accounts starting with 'yubi':
-      $ ykman oath accounts code yubi
-
-    \b
-      Add an account with the secret key f5up4ub3dw and the name yubico,
-      which requires touch:
-      $ ykman oath accounts add yubico f5up4ub3dw --touch
-
-    \b
-      Set a password for the OATH application:
-      $ ykman oath access change-password
-    """
-
-    dev = ctx.obj["device"]
-    conn = dev.open_connection(SmartCardConnection)
-    ctx.call_on_close(conn.close)
-    ctx.obj["session"] = OathSession(conn)
-    ctx.obj["oath_keys"] = AppData("oath_keys")
-
-
-@oath.command()
-@click.pass_context
-def info(ctx):
-    """
-    Display general status of the OATH application.
-    """
-    session = ctx.obj["session"]
-    version = session.version
-    click.echo(f"OATH version: {version[0]}.{version[1]}.{version[2]}")
-    click.echo("Password protection: " + ("enabled" if session.locked else "disabled"))
-
-    keys = ctx.obj["oath_keys"]
-    if session.locked and session.device_id in keys:
-        click.echo("The password for this YubiKey is remembered by ykman.")
-
-    if is_yk4_fips(ctx.obj["info"]):
-        click.echo(f"FIPS Approved Mode: {'Yes' if session.locked else 'No'}")
-
-
-@oath.command()
-@click.pass_context
-@click_force_option
-def reset(ctx, force):
-    """
-    Reset all OATH data.
-
-    This action will delete all accounts and restore factory settings for
-    the OATH application on the YubiKey.
-    """
-
-    force or click.confirm(
-        "WARNING! This will delete all stored OATH accounts and restore factory "
-        "settings. Proceed?",
-        abort=True,
-        err=True,
-    )
-
-    session = ctx.obj["session"]
-    click.echo("Resetting OATH data...")
-    old_id = session.device_id
-    session.reset()
-
-    keys = ctx.obj["oath_keys"]
-    if old_id in keys:
-        del keys[old_id]
-        keys.write()
-        logger.info("Deleted remembered access key")
-
-    click.echo("Success! All OATH accounts have been deleted from the YubiKey.")
-
-
-click_password_option = click.option(
-    "-p", "--password", help="the password to unlock the YubiKey"
-)
-
-
-click_remember_option = click.option(
-    "-r",
-    "--remember",
-    is_flag=True,
-    help="remember the password on this machine",
-)
-
-
-def _validate(ctx, key, remember):
-    session = ctx.obj["session"]
-    keys = ctx.obj["oath_keys"]
-    session.validate(key)
-    if remember:
-        keys.put_secret(session.device_id, key.hex())
-        keys.write()
-        logger.info("Access key remembered")
-        click.echo("Password remembered.")
-
-
-def _init_session(ctx, password, remember, prompt="Enter the password"):
-    session = ctx.obj["session"]
-    keys = ctx.obj["oath_keys"]
-    device_id = session.device_id
-
-    if session.locked:
-        try:
-            # Use password, if given as argument
-            if password:
-                logger.debug("Access key required, using provided password")
-                key = session.derive_key(password)
-                _validate(ctx, key, remember)
-                return
-
-            # Use stored key, if available
-            if device_id in keys:
-                logger.debug("Access key required, using remembered key")
-                try:
-                    key = bytes.fromhex(keys.get_secret(device_id))
-                    _validate(ctx, key, False)
-                    return
-                except ApduError as e:
-                    # Delete wrong key and fall through to prompt
-                    if e.sw == SW.INCORRECT_PARAMETERS:
-                        logger.debug("Remembered key incorrect, deleting key")
-                        del keys[device_id]
-                        keys.write()
-                except Exception as e:
-                    # Other error, fall though to prompt
-                    logger.warning("Error authenticating", exc_info=e)
-
-            # Prompt for password
-            password = click_prompt(prompt, hide_input=True)
-            key = session.derive_key(password)
-            _validate(ctx, key, remember)
-        except ApduError:
-            raise CliFail("Authentication to the YubiKey failed. Wrong password?")
-
-    elif password:
-        raise CliFail("Password provided, but no password is set.")
-
-
-@oath.group()
-def access():
-    """Manage password protection for OATH."""
-
-
-@access.command()
-@click.pass_context
-@click_password_option
-@click.option(
-    "-c",
-    "--clear",
-    is_flag=True,
-    help="remove the current password",
-)
-@click.option("-n", "--new-password", help="provide a new password as an argument")
-@click_remember_option
-def change(ctx, password, clear, new_password, remember):
-    """
-    Change the password used to protect OATH accounts.
-
-    Allows you to set or change a password that will be required to access the OATH
-    accounts stored on the YubiKey.
-    """
-    if clear and new_password:
-        ctx.fail("--clear cannot be combined with --new-password.")
-
-    _init_session(ctx, password, False, prompt="Enter the current password")
-
-    session = ctx.obj["session"]
-    keys = ctx.obj["oath_keys"]
-    device_id = session.device_id
-
-    if clear:
-        session.unset_key()
-        if device_id in keys:
-            del keys[device_id]
-            keys.write()
-            logger.info("Deleted remembered access key")
-
-        click.echo("Password cleared from YubiKey.")
-    else:
-        if remember:
-            try:
-                keys.ensure_unlocked()
-            except ValueError:
-                raise CliFail(
-                    "Failed to remember password, the keyring is locked or unavailable."
-                )
-        if not new_password:
-            new_password = click_prompt(
-                "Enter the new password", hide_input=True, confirmation_prompt=True
-            )
-        key = session.derive_key(new_password)
-        if remember:
-            keys.put_secret(device_id, key.hex())
-            keys.write()
-            click.echo("Password remembered.")
-        elif device_id in keys:
-            del keys[device_id]
-            keys.write()
-        session.set_key(key)
-        click.echo("Password updated.")
-
-
-@access.command()
-@click.pass_context
-@click_password_option
-def remember(ctx, password):
-    """
-    Store the YubiKeys password on this computer to avoid having to enter it
-    on each use.
-    """
-    session = ctx.obj["session"]
-    device_id = session.device_id
-    keys = ctx.obj["oath_keys"]
-
-    if not session.locked:
-        if device_id in keys:
-            del keys[session.device_id]
-            keys.write()
-            logger.info("Deleted remembered access key")
-        click.echo("This YubiKey is not password protected.")
-    else:
-        try:
-            keys.ensure_unlocked()
-        except ValueError:
-            raise CliFail(
-                "Failed to remember password, the keyring is locked or unavailable."
-            )
-        if not password:
-            password = click_prompt("Enter the password", hide_input=True)
-        key = session.derive_key(password)
-        try:
-            _validate(ctx, key, True)
-        except Exception:
-            raise CliFail("Authentication to the YubiKey failed. Wrong password?")
-
-
-def _clear_all_passwords(ctx, param, value):
-    if not value or ctx.resilient_parsing:
-        return
-
-    keys = AppData("oath_keys")
-    if keys:
-        keys.clear()
-        keys.write()
-    click.echo("All passwords have been forgotten.")
-    ctx.exit()
-
-
-@access.command()
-@click.pass_context
-@click.option(
-    "-a",
-    "--all",
-    is_flag=True,
-    is_eager=True,
-    expose_value=False,
-    callback=_clear_all_passwords,
-    help="remove all stored passwords",
-)
-def forget(ctx):
-    """
-    Remove a stored password from this computer.
-    """
-    session = ctx.obj["session"]
-    device_id = session.device_id
-    keys = ctx.obj["oath_keys"]
-
-    if device_id in keys:
-        del keys[session.device_id]
-        keys.write()
-        logger.info("Deleted remembered access key")
-        click.echo("Password forgotten.")
-    else:
-        click.echo("No password stored for this YubiKey.")
-
-
-click_touch_option = click.option(
-    "-t", "--touch", is_flag=True, help="require touch on YubiKey to generate code"
-)
-
-
-click_show_hidden_option = click.option(
-    "-H", "--show-hidden", is_flag=True, help="include hidden accounts"
-)
-
-
-def _string_id(credential):
-    return credential.id.decode("utf-8")
-
-
-def _error_multiple_hits(ctx, hits):
-    click.echo(
-        "Error: Multiple matches, please make the query more specific.", err=True
-    )
-    click.echo("", err=True)
-    for cred in hits:
-        click.echo(_string_id(cred), err=True)
-    ctx.exit(1)
-
-
-def _search(creds, query, show_hidden):
-    hits = []
-    for c in creds:
-        cred_id = _string_id(c)
-        if not show_hidden and is_hidden(c):
-            continue
-        if cred_id == query:
-            return [c]
-        if query.lower() in cred_id.lower():
-            hits.append(c)
-    return hits
-
-
-@oath.group()
-def accounts():
-    """Manage and use OATH accounts."""
-
-
-@accounts.command()
-@click.argument("name")
-@click.argument("secret", callback=click_parse_b32_key, required=False)
-@click.option(
-    "-o",
-    "--oath-type",
-    type=EnumChoice(OATH_TYPE),
-    default=OATH_TYPE.TOTP.name,
-    help="time-based (TOTP) or counter-based (HOTP) account",
-    show_default=True,
-)
-@click.option(
-    "-d",
-    "--digits",
-    type=click.Choice(["6", "7", "8"]),
-    default="6",
-    help="number of digits in generated code",
-    show_default=True,
-)
-@click.option(
-    "-a",
-    "--algorithm",
-    type=EnumChoice(HASH_ALGORITHM),
-    default=HASH_ALGORITHM.SHA1.name,
-    show_default=True,
-    help="algorithm to use for code generation",
-)
-@click.option(
-    "-c",
-    "--counter",
-    type=click.INT,
-    default=0,
-    help="initial counter value for HOTP accounts",
-)
-@click.option("-i", "--issuer", help="issuer of the account (optional)")
-@click.option(
-    "-P",
-    "--period",
-    help="number of seconds a TOTP code is valid",
-    default=30,
-    show_default=True,
-)
-@click_touch_option
-@click_force_option
-@click_password_option
-@click_remember_option
-@click.pass_context
-def add(
-    ctx,
-    secret,
-    name,
-    issuer,
-    period,
-    oath_type,
-    digits,
-    touch,
-    algorithm,
-    counter,
-    force,
-    password,
-    remember,
-):
-    """
-    Add a new account.
-
-    This will add a new OATH account to the YubiKey.
-
-    \b
-    NAME    human readable name of the account, such as a username or e-mail address
-    SECRET  base32-encoded secret/key value provided by the server
-    """
-
-    digits = int(digits)
-
-    if not secret:
-        while True:
-            secret = click_prompt("Enter a secret key (base32)")
-            try:
-                secret = parse_b32_key(secret)
-                break
-            except Exception as e:
-                click.echo(e)
-
-    _init_session(ctx, password, remember)
-
-    _add_cred(
-        ctx,
-        CredentialData(
-            name, oath_type, algorithm, secret, digits, period, counter, issuer
-        ),
-        touch,
-        force,
-    )
-
-
-@click_callback()
-def click_parse_uri(ctx, param, val):
-    try:
-        return CredentialData.parse_uri(val)
-    except ValueError:
-        raise click.BadParameter("URI seems to have the wrong format.")
-
-
-@accounts.command()
-@click.argument("data", callback=click_parse_uri, required=False, metavar="URI")
-@click_touch_option
-@click_force_option
-@click_password_option
-@click_remember_option
-@click.pass_context
-def uri(ctx, data, touch, force, password, remember):
-    """
-    Add a new account from an otpauth:// URI.
-
-    Use a URI to add a new account to the YubiKey.
-    """
-
-    if not data:
-        while True:
-            uri = click_prompt("Enter an OATH URI (otpauth://)")
-            try:
-                data = CredentialData.parse_uri(uri)
-                break
-            except Exception as e:
-                click.echo(e)
-
-    # Steam is a special case where we allow the otpauth
-    # URI to contain a 'digits' value of '5'.
-    if data.digits == 5 and is_steam(data):
-        data.digits = 6
-
-    _init_session(ctx, password, remember)
-    _add_cred(ctx, data, touch, force)
-
-
-def _add_cred(ctx, data, touch, force):
-    session = ctx.obj["session"]
-    version = session.version
-
-    if not (0 < len(data.name) <= 64):
-        ctx.fail("Name must be between 1 and 64 bytes.")
-
-    if len(data.secret) < 2:
-        ctx.fail("Secret must be at least 2 bytes.")
-
-    if touch and version < (4, 2, 6):
-        raise CliFail("Require touch is not supported on this YubiKey.")
-
-    if data.counter and data.oath_type != OATH_TYPE.HOTP:
-        ctx.fail("Counter only supported for HOTP accounts.")
-
-    if data.hash_algorithm == HASH_ALGORITHM.SHA512 and (
-        version < (4, 3, 1) or is_yk4_fips(ctx.obj["info"])
-    ):
-        raise CliFail("Algorithm SHA512 not supported on this YubiKey.")
-
-    creds = session.list_credentials()
-    cred_id = data.get_id()
-    if not force and any(cred.id == cred_id for cred in creds):
-        click.confirm(
-            f"An account called {data.name} already exists on this YubiKey."
-            " Do you want to overwrite it?",
-            abort=True,
-            err=True,
-        )
-
-    firmware_overwrite_issue = (4, 0, 0) < version < (4, 3, 5)
-    cred_is_subset = any(
-        (cred.id.startswith(cred_id) and cred.id != cred_id) for cred in creds
-    )
-
-    #  YK4 has an issue with credential overwrite in firmware versions < 4.3.5
-    if firmware_overwrite_issue and cred_is_subset:
-        raise CliFail("Choose a name that is not a subset of an existing account.")
-
-    try:
-        session.put_credential(data, touch)
-    except ApduError as e:
-        if e.sw == SW.NO_SPACE:
-            raise CliFail("No space left on the YubiKey for OATH accounts.")
-        elif e.sw == SW.COMMAND_ABORTED:
-            # Some NEOs do not use the NO_SPACE error.
-            raise CliFail("The command failed. Is there enough space on the YubiKey?")
-        else:
-            raise
-
-
-@accounts.command()
-@click_show_hidden_option
-@click.pass_context
-@click.option("-o", "--oath-type", is_flag=True, help="display the OATH type")
-@click.option("-P", "--period", is_flag=True, help="display the period")
-@click_password_option
-@click_remember_option
-def list(ctx, show_hidden, oath_type, period, password, remember):
-    """
-    List all accounts.
-
-    List all accounts stored on the YubiKey.
-    """
-    _init_session(ctx, password, remember)
-    session = ctx.obj["session"]
-    creds = [
-        cred
-        for cred in session.list_credentials()
-        if show_hidden or not is_hidden(cred)
-    ]
-    creds.sort()
-    for cred in creds:
-        click.echo(_string_id(cred), nl=False)
-        if oath_type:
-            click.echo(f", {cred.oath_type.name}", nl=False)
-        if period:
-            click.echo(f", {cred.period}", nl=False)
-        click.echo()
-
-
-@accounts.command()
-@click_show_hidden_option
-@click.pass_context
-@click.argument("query", required=False, default="")
-@click.option(
-    "-s",
-    "--single",
-    is_flag=True,
-    help="ensure only a single match, and output only the code",
-)
-@click_password_option
-@click_remember_option
-def code(ctx, show_hidden, query, single, password, remember):
-    """
-    Generate codes.
-
-    Generate codes from OATH accounts stored on the YubiKey.
-    Provide a query string to match one or more specific accounts.
-    Accounts of type HOTP, or those that require touch, requre a single match to be
-    triggered.
-    """
-
-    _init_session(ctx, password, remember)
-
-    session = ctx.obj["session"]
-    entries = session.calculate_all()
-    creds = _search(entries.keys(), query, show_hidden)
-
-    if len(creds) == 1:
-        cred = creds[0]
-        code = entries[cred]
-        if cred.touch_required:
-            prompt_for_touch()
-        try:
-            if cred.oath_type == OATH_TYPE.HOTP:
-                with prompt_timeout():
-                    # HOTP might require touch, we don't know.
-                    # Assume yes after 500ms.
-                    code = session.calculate_code(cred)
-            elif code is None:
-                code = session.calculate_code(cred)
-        except ApduError as e:
-            if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
-                raise CliFail("Touch account timed out!")
-        entries[cred] = code
-
-    elif single and len(creds) > 1:
-        _error_multiple_hits(ctx, creds)
-
-    elif single and len(creds) == 0:
-        raise CliFail("No matching account found.")
-
-    if single and creds:
-        if is_steam(cred):
-            click.echo(calculate_steam(session, cred))
-        else:
-            click.echo(code.value)
-    else:
-        outputs = []
-        for cred in sorted(creds):
-            code = entries[cred]
-            if code:
-                if is_steam(cred):
-                    code = calculate_steam(session, cred)
-                else:
-                    code = code.value
-            elif cred.touch_required:
-                code = "[Requires Touch]"
-            elif cred.oath_type == OATH_TYPE.HOTP:
-                code = "[HOTP Account]"
-            else:
-                code = ""
-            outputs.append((_string_id(cred), code))
-
-        longest_name = max(len(n) for (n, c) in outputs) if outputs else 0
-        longest_code = max(len(c) for (n, c) in outputs) if outputs else 0
-        format_str = "{:<%d}  {:>%d}" % (longest_name, longest_code)
-
-        for name, result in outputs:
-            click.echo(format_str.format(name, result))
-
-
-@accounts.command()
-@click.pass_context
-@click.argument("query")
-@click.argument("name")
-@click.option("-f", "--force", is_flag=True, help="confirm rename without prompting")
-@click_password_option
-@click_remember_option
-def rename(ctx, query, name, force, password, remember):
-    """
-    Rename an account (requires YubiKey 5.3 or later).
-
-    \b
-    QUERY  a query to match a single account (as shown in "list")
-    NAME   the name of the account (use "<issuer>:<name>" to specify issuer)
-    """
-
-    _init_session(ctx, password, remember)
-    session = ctx.obj["session"]
-    creds = session.list_credentials()
-    hits = _search(creds, query, True)
-    if len(hits) == 0:
-        click.echo("No matches, nothing to be done.")
-    elif len(hits) == 1:
-        cred = hits[0]
-        if ":" in name:
-            issuer, name = name.split(":", 1)
-        else:
-            issuer = None
-
-        new_id = _format_cred_id(issuer, name, cred.oath_type, cred.period)
-        if any(cred.id == new_id for cred in creds):
-            raise CliFail(
-                f"Another account with ID {new_id.decode()} "
-                "already exists on this YubiKey."
-            )
-        if force or (
-            click.confirm(
-                f"Rename account: {_string_id(cred)} ?",
-                default=False,
-                err=True,
-            )
-        ):
-            session.rename_credential(cred.id, name, issuer)
-            click.echo(f"Renamed {_string_id(cred)} to {new_id.decode()}.")
-        else:
-            click.echo("Rename aborted by user.")
-
-    else:
-        _error_multiple_hits(ctx, hits)
-
-
-@accounts.command()
-@click.pass_context
-@click.argument("query")
-@click.option("-f", "--force", is_flag=True, help="confirm deletion without prompting")
-@click_password_option
-@click_remember_option
-def delete(ctx, query, force, password, remember):
-    """
-    Delete an account.
-
-    Delete an account from the YubiKey.
-
-    \b
-    QUERY  a query to match a single account (as shown in "list")
-    """
-
-    _init_session(ctx, password, remember)
-    session = ctx.obj["session"]
-    creds = session.list_credentials()
-    hits = _search(creds, query, True)
-    if len(hits) == 0:
-        click.echo("No matches, nothing to be done.")
-    elif len(hits) == 1:
-        cred = hits[0]
-        if force or (
-            click.confirm(
-                f"Delete account: {_string_id(cred)} ?",
-                default=False,
-                err=True,
-            )
-        ):
-            session.delete_credential(cred.id)
-            click.echo(f"Deleted {_string_id(cred)}.")
-        else:
-            click.echo("Deletion aborted by user.")
-
-    else:
-        _error_multiple_hits(ctx, hits)
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+import click
+import logging
+from .util import (
+    CliFail,
+    click_force_option,
+    click_postpone_execution,
+    click_callback,
+    click_parse_b32_key,
+    click_prompt,
+    click_group,
+    prompt_for_touch,
+    prompt_timeout,
+    EnumChoice,
+    is_yk4_fips,
+)
+from yubikit.core.smartcard import ApduError, SW, SmartCardConnection
+from yubikit.oath import (
+    OathSession,
+    CredentialData,
+    OATH_TYPE,
+    HASH_ALGORITHM,
+    parse_b32_key,
+    _format_cred_id,
+)
+from ..oath import is_steam, calculate_steam, is_hidden
+from ..settings import AppData
+
+
+logger = logging.getLogger(__name__)
+
+
+@click_group(connections=[SmartCardConnection])
+@click.pass_context
+@click_postpone_execution
+def oath(ctx):
+    """
+    Manage the OATH application.
+
+    Examples:
+
+    \b
+      Generate codes for accounts starting with 'yubi':
+      $ ykman oath accounts code yubi
+
+    \b
+      Add an account with the secret key f5up4ub3dw and the name yubico,
+      which requires touch:
+      $ ykman oath accounts add yubico f5up4ub3dw --touch
+
+    \b
+      Set a password for the OATH application:
+      $ ykman oath access change-password
+    """
+
+    dev = ctx.obj["device"]
+    conn = dev.open_connection(SmartCardConnection)
+    ctx.call_on_close(conn.close)
+    ctx.obj["session"] = OathSession(conn)
+    ctx.obj["oath_keys"] = AppData("oath_keys")
+
+
+@oath.command()
+@click.pass_context
+def info(ctx):
+    """
+    Display general status of the OATH application.
+    """
+    session = ctx.obj["session"]
+    version = session.version
+    click.echo(f"OATH version: {version[0]}.{version[1]}.{version[2]}")
+    click.echo("Password protection: " + ("enabled" if session.locked else "disabled"))
+
+    keys = ctx.obj["oath_keys"]
+    if session.locked and session.device_id in keys:
+        click.echo("The password for this YubiKey is remembered by ykman.")
+
+    if is_yk4_fips(ctx.obj["info"]):
+        click.echo(f"FIPS Approved Mode: {'Yes' if session.locked else 'No'}")
+
+
+@oath.command()
+@click.pass_context
+@click_force_option
+def reset(ctx, force):
+    """
+    Reset all OATH data.
+
+    This action will delete all accounts and restore factory settings for
+    the OATH application on the YubiKey.
+    """
+
+    force or click.confirm(
+        "WARNING! This will delete all stored OATH accounts and restore factory "
+        "settings. Proceed?",
+        abort=True,
+        err=True,
+    )
+
+    session = ctx.obj["session"]
+    click.echo("Resetting OATH data...")
+    old_id = session.device_id
+    session.reset()
+
+    keys = ctx.obj["oath_keys"]
+    if old_id in keys:
+        del keys[old_id]
+        keys.write()
+        logger.info("Deleted remembered access key")
+
+    click.echo("Success! All OATH accounts have been deleted from the YubiKey.")
+
+
+click_password_option = click.option(
+    "-p", "--password", help="the password to unlock the YubiKey"
+)
+
+
+click_remember_option = click.option(
+    "-r",
+    "--remember",
+    is_flag=True,
+    help="remember the password on this machine",
+)
+
+
+def _validate(ctx, key, remember):
+    session = ctx.obj["session"]
+    keys = ctx.obj["oath_keys"]
+    session.validate(key)
+    if remember:
+        keys.put_secret(session.device_id, key.hex())
+        keys.write()
+        logger.info("Access key remembered")
+        click.echo("Password remembered.")
+
+
+def _init_session(ctx, password, remember, prompt="Enter the password"):
+    session = ctx.obj["session"]
+    keys = ctx.obj["oath_keys"]
+    device_id = session.device_id
+
+    if session.locked:
+        try:
+            # Use password, if given as argument
+            if password:
+                logger.debug("Access key required, using provided password")
+                key = session.derive_key(password)
+                _validate(ctx, key, remember)
+                return
+
+            # Use stored key, if available
+            if device_id in keys:
+                logger.debug("Access key required, using remembered key")
+                try:
+                    key = bytes.fromhex(keys.get_secret(device_id))
+                    _validate(ctx, key, False)
+                    return
+                except ApduError as e:
+                    # Delete wrong key and fall through to prompt
+                    if e.sw == SW.INCORRECT_PARAMETERS:
+                        logger.debug("Remembered key incorrect, deleting key")
+                        del keys[device_id]
+                        keys.write()
+                except Exception as e:
+                    # Other error, fall though to prompt
+                    logger.warning("Error authenticating", exc_info=e)
+
+            # Prompt for password
+            password = click_prompt(prompt, hide_input=True)
+            key = session.derive_key(password)
+            _validate(ctx, key, remember)
+        except ApduError:
+            raise CliFail("Authentication to the YubiKey failed. Wrong password?")
+
+    elif password:
+        raise CliFail("Password provided, but no password is set.")
+
+
+@oath.group()
+def access():
+    """Manage password protection for OATH."""
+
+
+@access.command()
+@click.pass_context
+@click_password_option
+@click.option(
+    "-c",
+    "--clear",
+    is_flag=True,
+    help="remove the current password",
+)
+@click.option("-n", "--new-password", help="provide a new password as an argument")
+@click_remember_option
+def change(ctx, password, clear, new_password, remember):
+    """
+    Change the password used to protect OATH accounts.
+
+    Allows you to set or change a password that will be required to access the OATH
+    accounts stored on the YubiKey.
+    """
+    if clear and new_password:
+        ctx.fail("--clear cannot be combined with --new-password.")
+
+    _init_session(ctx, password, False, prompt="Enter the current password")
+
+    session = ctx.obj["session"]
+    keys = ctx.obj["oath_keys"]
+    device_id = session.device_id
+
+    if clear:
+        session.unset_key()
+        if device_id in keys:
+            del keys[device_id]
+            keys.write()
+            logger.info("Deleted remembered access key")
+
+        click.echo("Password cleared from YubiKey.")
+    else:
+        if remember:
+            try:
+                keys.ensure_unlocked()
+            except ValueError:
+                raise CliFail(
+                    "Failed to remember password, the keyring is locked or unavailable."
+                )
+        if not new_password:
+            new_password = click_prompt(
+                "Enter the new password", hide_input=True, confirmation_prompt=True
+            )
+        key = session.derive_key(new_password)
+        if remember:
+            keys.put_secret(device_id, key.hex())
+            keys.write()
+            click.echo("Password remembered.")
+        elif device_id in keys:
+            del keys[device_id]
+            keys.write()
+        session.set_key(key)
+        click.echo("Password updated.")
+
+
+@access.command()
+@click.pass_context
+@click_password_option
+def remember(ctx, password):
+    """
+    Store the YubiKeys password on this computer to avoid having to enter it
+    on each use.
+    """
+    session = ctx.obj["session"]
+    device_id = session.device_id
+    keys = ctx.obj["oath_keys"]
+
+    if not session.locked:
+        if device_id in keys:
+            del keys[session.device_id]
+            keys.write()
+            logger.info("Deleted remembered access key")
+        click.echo("This YubiKey is not password protected.")
+    else:
+        try:
+            keys.ensure_unlocked()
+        except ValueError:
+            raise CliFail(
+                "Failed to remember password, the keyring is locked or unavailable."
+            )
+        if not password:
+            password = click_prompt("Enter the password", hide_input=True)
+        key = session.derive_key(password)
+        try:
+            _validate(ctx, key, True)
+        except Exception:
+            raise CliFail("Authentication to the YubiKey failed. Wrong password?")
+
+
+def _clear_all_passwords(ctx, param, value):
+    if not value or ctx.resilient_parsing:
+        return
+
+    keys = AppData("oath_keys")
+    if keys:
+        keys.clear()
+        keys.write()
+    click.echo("All passwords have been forgotten.")
+    ctx.exit()
+
+
+@access.command()
+@click.pass_context
+@click.option(
+    "-a",
+    "--all",
+    is_flag=True,
+    is_eager=True,
+    expose_value=False,
+    callback=_clear_all_passwords,
+    help="remove all stored passwords",
+)
+def forget(ctx):
+    """
+    Remove a stored password from this computer.
+    """
+    session = ctx.obj["session"]
+    device_id = session.device_id
+    keys = ctx.obj["oath_keys"]
+
+    if device_id in keys:
+        del keys[session.device_id]
+        keys.write()
+        logger.info("Deleted remembered access key")
+        click.echo("Password forgotten.")
+    else:
+        click.echo("No password stored for this YubiKey.")
+
+
+click_touch_option = click.option(
+    "-t", "--touch", is_flag=True, help="require touch on YubiKey to generate code"
+)
+
+
+click_show_hidden_option = click.option(
+    "-H", "--show-hidden", is_flag=True, help="include hidden accounts"
+)
+
+
+def _string_id(credential):
+    return credential.id.decode("utf-8")
+
+
+def _error_multiple_hits(ctx, hits):
+    click.echo(
+        "Error: Multiple matches, please make the query more specific.", err=True
+    )
+    click.echo("", err=True)
+    for cred in hits:
+        click.echo(_string_id(cred), err=True)
+    ctx.exit(1)
+
+
+def _search(creds, query, show_hidden):
+    hits = []
+    for c in creds:
+        cred_id = _string_id(c)
+        if not show_hidden and is_hidden(c):
+            continue
+        if cred_id == query:
+            return [c]
+        if query.lower() in cred_id.lower():
+            hits.append(c)
+    return hits
+
+
+@oath.group()
+def accounts():
+    """Manage and use OATH accounts."""
+
+
+@accounts.command()
+@click.argument("name")
+@click.argument("secret", callback=click_parse_b32_key, required=False)
+@click.option(
+    "-o",
+    "--oath-type",
+    type=EnumChoice(OATH_TYPE),
+    default=OATH_TYPE.TOTP.name,
+    help="time-based (TOTP) or counter-based (HOTP) account",
+    show_default=True,
+)
+@click.option(
+    "-d",
+    "--digits",
+    type=click.Choice(["6", "7", "8"]),
+    default="6",
+    help="number of digits in generated code",
+    show_default=True,
+)
+@click.option(
+    "-a",
+    "--algorithm",
+    type=EnumChoice(HASH_ALGORITHM),
+    default=HASH_ALGORITHM.SHA1.name,
+    show_default=True,
+    help="algorithm to use for code generation",
+)
+@click.option(
+    "-c",
+    "--counter",
+    type=click.INT,
+    default=0,
+    help="initial counter value for HOTP accounts",
+)
+@click.option("-i", "--issuer", help="issuer of the account (optional)")
+@click.option(
+    "-P",
+    "--period",
+    help="number of seconds a TOTP code is valid",
+    default=30,
+    show_default=True,
+)
+@click_touch_option
+@click_force_option
+@click_password_option
+@click_remember_option
+@click.pass_context
+def add(
+    ctx,
+    secret,
+    name,
+    issuer,
+    period,
+    oath_type,
+    digits,
+    touch,
+    algorithm,
+    counter,
+    force,
+    password,
+    remember,
+):
+    """
+    Add a new account.
+
+    This will add a new OATH account to the YubiKey.
+
+    \b
+    NAME    human readable name of the account, such as a username or e-mail address
+    SECRET  base32-encoded secret/key value provided by the server
+    """
+
+    digits = int(digits)
+
+    if not secret:
+        while True:
+            secret = click_prompt("Enter a secret key (base32)")
+            try:
+                secret = parse_b32_key(secret)
+                break
+            except Exception as e:
+                click.echo(e)
+
+    _init_session(ctx, password, remember)
+
+    _add_cred(
+        ctx,
+        CredentialData(
+            name, oath_type, algorithm, secret, digits, period, counter, issuer
+        ),
+        touch,
+        force,
+    )
+
+
+@click_callback()
+def click_parse_uri(ctx, param, val):
+    try:
+        return CredentialData.parse_uri(val)
+    except ValueError:
+        raise click.BadParameter("URI seems to have the wrong format.")
+
+
+@accounts.command()
+@click.argument("data", callback=click_parse_uri, required=False, metavar="URI")
+@click_touch_option
+@click_force_option
+@click_password_option
+@click_remember_option
+@click.pass_context
+def uri(ctx, data, touch, force, password, remember):
+    """
+    Add a new account from an otpauth:// URI.
+
+    Use a URI to add a new account to the YubiKey.
+    """
+
+    if not data:
+        while True:
+            uri = click_prompt("Enter an OATH URI (otpauth://)")
+            try:
+                data = CredentialData.parse_uri(uri)
+                break
+            except Exception as e:
+                click.echo(e)
+
+    # Steam is a special case where we allow the otpauth
+    # URI to contain a 'digits' value of '5'.
+    if data.digits == 5 and is_steam(data):
+        data.digits = 6
+
+    _init_session(ctx, password, remember)
+    _add_cred(ctx, data, touch, force)
+
+
+def _add_cred(ctx, data, touch, force):
+    session = ctx.obj["session"]
+    version = session.version
+
+    if not (0 < len(data.name) <= 64):
+        ctx.fail("Name must be between 1 and 64 bytes.")
+
+    if len(data.secret) < 2:
+        ctx.fail("Secret must be at least 2 bytes.")
+
+    if touch and version < (4, 2, 6):
+        raise CliFail("Require touch is not supported on this YubiKey.")
+
+    if data.counter and data.oath_type != OATH_TYPE.HOTP:
+        ctx.fail("Counter only supported for HOTP accounts.")
+
+    if data.hash_algorithm == HASH_ALGORITHM.SHA512 and (
+        version < (4, 3, 1) or is_yk4_fips(ctx.obj["info"])
+    ):
+        raise CliFail("Algorithm SHA512 not supported on this YubiKey.")
+
+    creds = session.list_credentials()
+    cred_id = data.get_id()
+    if not force and any(cred.id == cred_id for cred in creds):
+        click.confirm(
+            f"An account called {data.name} already exists on this YubiKey."
+            " Do you want to overwrite it?",
+            abort=True,
+            err=True,
+        )
+
+    firmware_overwrite_issue = (4, 0, 0) < version < (4, 3, 5)
+    cred_is_subset = any(
+        (cred.id.startswith(cred_id) and cred.id != cred_id) for cred in creds
+    )
+
+    #  YK4 has an issue with credential overwrite in firmware versions < 4.3.5
+    if firmware_overwrite_issue and cred_is_subset:
+        raise CliFail("Choose a name that is not a subset of an existing account.")
+
+    try:
+        session.put_credential(data, touch)
+    except ApduError as e:
+        if e.sw == SW.NO_SPACE:
+            raise CliFail("No space left on the YubiKey for OATH accounts.")
+        elif e.sw == SW.COMMAND_ABORTED:
+            # Some NEOs do not use the NO_SPACE error.
+            raise CliFail("The command failed. Is there enough space on the YubiKey?")
+        else:
+            raise
+
+
+@accounts.command()
+@click_show_hidden_option
+@click.pass_context
+@click.option("-o", "--oath-type", is_flag=True, help="display the OATH type")
+@click.option("-P", "--period", is_flag=True, help="display the period")
+@click_password_option
+@click_remember_option
+def list(ctx, show_hidden, oath_type, period, password, remember):
+    """
+    List all accounts.
+
+    List all accounts stored on the YubiKey.
+    """
+    _init_session(ctx, password, remember)
+    session = ctx.obj["session"]
+    creds = [
+        cred
+        for cred in session.list_credentials()
+        if show_hidden or not is_hidden(cred)
+    ]
+    creds.sort()
+    for cred in creds:
+        click.echo(_string_id(cred), nl=False)
+        if oath_type:
+            click.echo(f", {cred.oath_type.name}", nl=False)
+        if period:
+            click.echo(f", {cred.period}", nl=False)
+        click.echo()
+
+
+@accounts.command()
+@click_show_hidden_option
+@click.pass_context
+@click.argument("query", required=False, default="")
+@click.option(
+    "-s",
+    "--single",
+    is_flag=True,
+    help="ensure only a single match, and output only the code",
+)
+@click_password_option
+@click_remember_option
+def code(ctx, show_hidden, query, single, password, remember):
+    """
+    Generate codes.
+
+    Generate codes from OATH accounts stored on the YubiKey.
+    Provide a query string to match one or more specific accounts.
+    Accounts of type HOTP, or those that require touch, requre a single match to be
+    triggered.
+    """
+
+    _init_session(ctx, password, remember)
+
+    session = ctx.obj["session"]
+    entries = session.calculate_all()
+    creds = _search(entries.keys(), query, show_hidden)
+
+    if len(creds) == 1:
+        cred = creds[0]
+        code = entries[cred]
+        if cred.touch_required:
+            prompt_for_touch()
+        try:
+            if cred.oath_type == OATH_TYPE.HOTP:
+                with prompt_timeout():
+                    # HOTP might require touch, we don't know.
+                    # Assume yes after 500ms.
+                    code = session.calculate_code(cred)
+            elif code is None:
+                code = session.calculate_code(cred)
+        except ApduError as e:
+            if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
+                raise CliFail("Touch account timed out!")
+        entries[cred] = code
+
+    elif single and len(creds) > 1:
+        _error_multiple_hits(ctx, creds)
+
+    elif single and len(creds) == 0:
+        raise CliFail("No matching account found.")
+
+    if single and creds:
+        if is_steam(cred):
+            click.echo(calculate_steam(session, cred))
+        else:
+            click.echo(code.value)
+    else:
+        outputs = []
+        for cred in sorted(creds):
+            code = entries[cred]
+            if code:
+                if is_steam(cred):
+                    code = calculate_steam(session, cred)
+                else:
+                    code = code.value
+            elif cred.touch_required:
+                code = "[Requires Touch]"
+            elif cred.oath_type == OATH_TYPE.HOTP:
+                code = "[HOTP Account]"
+            else:
+                code = ""
+            outputs.append((_string_id(cred), code))
+
+        longest_name = max(len(n) for (n, c) in outputs) if outputs else 0
+        longest_code = max(len(c) for (n, c) in outputs) if outputs else 0
+        format_str = "{:<%d}  {:>%d}" % (longest_name, longest_code)
+
+        for name, result in outputs:
+            click.echo(format_str.format(name, result))
+
+
+@accounts.command()
+@click.pass_context
+@click.argument("query")
+@click.argument("name")
+@click.option("-f", "--force", is_flag=True, help="confirm rename without prompting")
+@click_password_option
+@click_remember_option
+def rename(ctx, query, name, force, password, remember):
+    """
+    Rename an account (requires YubiKey 5.3 or later).
+
+    \b
+    QUERY  a query to match a single account (as shown in "list")
+    NAME   the name of the account (use "<issuer>:<name>" to specify issuer)
+    """
+
+    _init_session(ctx, password, remember)
+    session = ctx.obj["session"]
+    creds = session.list_credentials()
+    hits = _search(creds, query, True)
+    if len(hits) == 0:
+        click.echo("No matches, nothing to be done.")
+    elif len(hits) == 1:
+        cred = hits[0]
+        if ":" in name:
+            issuer, name = name.split(":", 1)
+        else:
+            issuer = None
+
+        new_id = _format_cred_id(issuer, name, cred.oath_type, cred.period)
+        if any(cred.id == new_id for cred in creds):
+            raise CliFail(
+                f"Another account with ID {new_id.decode()} "
+                "already exists on this YubiKey."
+            )
+        if force or (
+            click.confirm(
+                f"Rename account: {_string_id(cred)} ?",
+                default=False,
+                err=True,
+            )
+        ):
+            session.rename_credential(cred.id, name, issuer)
+            click.echo(f"Renamed {_string_id(cred)} to {new_id.decode()}.")
+        else:
+            click.echo("Rename aborted by user.")
+
+    else:
+        _error_multiple_hits(ctx, hits)
+
+
+@accounts.command()
+@click.pass_context
+@click.argument("query")
+@click.option("-f", "--force", is_flag=True, help="confirm deletion without prompting")
+@click_password_option
+@click_remember_option
+def delete(ctx, query, force, password, remember):
+    """
+    Delete an account.
+
+    Delete an account from the YubiKey.
+
+    \b
+    QUERY  a query to match a single account (as shown in "list")
+    """
+
+    _init_session(ctx, password, remember)
+    session = ctx.obj["session"]
+    creds = session.list_credentials()
+    hits = _search(creds, query, True)
+    if len(hits) == 0:
+        click.echo("No matches, nothing to be done.")
+    elif len(hits) == 1:
+        cred = hits[0]
+        if force or (
+            click.confirm(
+                f"Delete account: {_string_id(cred)} ?",
+                default=False,
+                err=True,
+            )
+        ):
+            session.delete_credential(cred.id)
+            click.echo(f"Deleted {_string_id(cred)}.")
+        else:
+            click.echo("Deletion aborted by user.")
+
+    else:
+        _error_multiple_hits(ctx, hits)
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/openpgp.py` & `yubikey_manager-5.1.1/ykman/_cli/openpgp.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,545 +1,545 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core.smartcard import ApduError, SW, SmartCardConnection
-from yubikit.openpgp import OpenPgpSession, UIF, PIN_POLICY, KEY_REF as _KEY_REF
-from ..util import parse_certificates, parse_private_key
-from ..openpgp import get_openpgp_info
-from .util import (
-    CliFail,
-    click_force_option,
-    click_format_option,
-    click_postpone_execution,
-    click_prompt,
-    click_group,
-    EnumChoice,
-    pretty_print,
-)
-from enum import IntEnum
-import logging
-import click
-
-logger = logging.getLogger(__name__)
-
-
-class KEY_REF(IntEnum):
-    SIG = 0x01
-    DEC = 0x02
-    AUT = 0x03
-    ATT = 0x81
-    ENC = 0x02  # Alias for backwards compatibility, will be removed in ykman 6
-
-    def __getattribute__(self, name: str):
-        return _KEY_REF(self).__getattribute__(name)
-
-
-def _fname(fobj):
-    return getattr(fobj, "name", fobj)
-
-
-@click_group(connections=[SmartCardConnection])
-@click.pass_context
-@click_postpone_execution
-def openpgp(ctx):
-    """
-    Manage the OpenPGP application.
-
-    Examples:
-
-    \b
-      Set the retries for PIN, Reset Code and Admin PIN to 10:
-      $ ykman openpgp access set-retries 10 10 10
-
-    \b
-      Require touch to use the authentication key:
-      $ ykman openpgp keys set-touch aut on
-    """
-    dev = ctx.obj["device"]
-    conn = dev.open_connection(SmartCardConnection)
-    ctx.call_on_close(conn.close)
-    ctx.obj["session"] = OpenPgpSession(conn)
-
-
-@openpgp.command()
-@click.pass_context
-def info(ctx):
-    """
-    Display general status of the OpenPGP application.
-    """
-    session = ctx.obj["session"]
-    click.echo("\n".join(pretty_print(get_openpgp_info(session))))
-
-
-@openpgp.command()
-@click_force_option
-@click.pass_context
-def reset(ctx, force):
-    """
-    Reset all OpenPGP data.
-
-    This action will wipe all OpenPGP data, and set all PINs to their default
-    values.
-    """
-    force or click.confirm(
-        "WARNING! This will delete all stored OpenPGP keys and data and restore "
-        "factory settings. Proceed?",
-        abort=True,
-        err=True,
-    )
-
-    click.echo("Resetting OpenPGP data, don't remove the YubiKey...")
-    ctx.obj["session"].reset()
-    logger.info("OpenPGP application data reset")
-    click.echo("Success! All data has been cleared and default PINs are set.")
-    echo_default_pins()
-
-
-def echo_default_pins():
-    click.echo("PIN:         123456")
-    click.echo("Reset code:  NOT SET")
-    click.echo("Admin PIN:   12345678")
-
-
-@openpgp.group("access")
-def access():
-    """Manage PIN, Reset Code, and Admin PIN."""
-
-
-@access.command("set-retries")
-@click.argument("user-pin-retries", type=click.IntRange(1, 99), metavar="PIN-RETRIES")
-@click.argument(
-    "reset-code-retries", type=click.IntRange(1, 99), metavar="RESET-CODE-RETRIES"
-)
-@click.argument(
-    "admin-pin-retries", type=click.IntRange(1, 99), metavar="ADMIN-PIN-RETRIES"
-)
-@click.option("-a", "--admin-pin", help="admin PIN for OpenPGP")
-@click_force_option
-@click.pass_context
-def set_pin_retries(
-    ctx, admin_pin, user_pin_retries, reset_code_retries, admin_pin_retries, force
-):
-    """
-    Set the number of retry attempts for the User PIN, Reset Code, and Admin PIN.
-    """
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    resets_pins = session.version < (4, 0, 0)
-    if resets_pins:
-        click.echo("WARNING: Setting PIN retries will reset the values for all 3 PINs!")
-    if force or click.confirm(
-        f"Set PIN retry counters to: {user_pin_retries} {reset_code_retries} "
-        f"{admin_pin_retries}?",
-        abort=True,
-        err=True,
-    ):
-        session.verify_admin(admin_pin)
-        session.set_pin_attempts(
-            user_pin_retries, reset_code_retries, admin_pin_retries
-        )
-        logger.info("Number of PIN/Reset Code/Admin PIN retries set")
-
-        if resets_pins:
-            click.echo("Default PINs are set.")
-            echo_default_pins()
-
-
-@access.command("change-pin")
-@click.option("-P", "--pin", help="current PIN code")
-@click.option("-n", "--new-pin", help="a new PIN")
-@click.pass_context
-def change_pin(ctx, pin, new_pin):
-    """
-    Change the User PIN.
-
-    The PIN has a minimum length of 6, and supports any type of
-    alphanumeric characters.
-    """
-
-    session = ctx.obj["session"]
-
-    if pin is None:
-        pin = click_prompt("Enter PIN", hide_input=True)
-
-    if new_pin is None:
-        new_pin = click_prompt(
-            "New PIN",
-            hide_input=True,
-            confirmation_prompt=True,
-        )
-
-    session.change_pin(pin, new_pin)
-
-
-@access.command("change-reset-code")
-@click.option("-a", "--admin-pin", help="Admin PIN")
-@click.option("-r", "--reset-code", help="a new Reset Code")
-@click.pass_context
-def change_reset_code(ctx, admin_pin, reset_code):
-    """
-    Change the Reset Code.
-
-    The Reset Code has a minimum length of 6, and supports any type of
-    alphanumeric characters.
-    """
-
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    if reset_code is None:
-        reset_code = click_prompt(
-            "New Reset Code",
-            hide_input=True,
-            confirmation_prompt=True,
-        )
-
-    session.verify_admin(admin_pin)
-    session.set_reset_code(reset_code)
-
-
-@access.command("change-admin-pin")
-@click.option("-a", "--admin-pin", help="current Admin PIN")
-@click.option("-n", "--new-admin-pin", help="new Admin PIN")
-@click.pass_context
-def change_admin(ctx, admin_pin, new_admin_pin):
-    """
-    Change the Admin PIN.
-
-    The Admin PIN has a minimum length of 8, and supports any type of
-    alphanumeric characters.
-    """
-
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    if new_admin_pin is None:
-        new_admin_pin = click_prompt(
-            "New Admin PIN",
-            hide_input=True,
-            confirmation_prompt=True,
-        )
-
-    session.change_admin(admin_pin, new_admin_pin)
-
-
-@access.command("unblock-pin")
-@click.option(
-    "-a", "--admin-pin", help='admin PIN (use "-" as a value to prompt for input)'
-)
-@click.option("-r", "--reset-code", help="Reset Code")
-@click.option("-n", "--new-pin", help="a new PIN")
-@click.pass_context
-def unblock_pin(ctx, admin_pin, reset_code, new_pin):
-    """
-    Unblock the PIN (using Reset Code or Admin PIN).
-
-    If the PIN is lost or blocked you can reset it to a new value using either the
-    Reset Code OR the Admin PIN.
-
-    The new PIN has a minimum length of 6, and supports any type of
-    alphanumeric characters.
-    """
-
-    session = ctx.obj["session"]
-
-    if reset_code is not None and admin_pin is not None:
-        raise CliFail(
-            "Invalid options: Only one of --reset-code and --admin-pin may be used."
-        )
-
-    if admin_pin == "-":
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    if reset_code is None and admin_pin is None:
-        reset_code = click_prompt("Enter Reset Code", hide_input=True)
-
-    if new_pin is None:
-        new_pin = click_prompt(
-            "New PIN",
-            hide_input=True,
-            confirmation_prompt=True,
-        )
-
-    if admin_pin:
-        session.verify_admin(admin_pin)
-    session.reset_pin(new_pin, reset_code)
-
-
-@access.command("set-signature-policy")
-@click.argument("policy", metavar="POLICY", type=EnumChoice(PIN_POLICY))
-@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
-@click.pass_context
-def set_signature_policy(ctx, policy, admin_pin):
-    """
-    Set the Signature PIN policy.
-
-    The Signature PIN policy is used to control whether the PIN is
-    always required when using the Signature key, or if it is required
-    only once per session.
-
-    \b
-    POLICY  signature PIN policy to set (always, once)
-    """
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    try:
-        session.verify_admin(admin_pin)
-        session.set_signature_pin_policy(policy)
-    except Exception:
-        raise CliFail("Failed to set new Signature PIN policy")
-
-
-@openpgp.group("keys")
-def keys():
-    """Manage private keys."""
-
-
-@keys.command("set-touch")
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
-@click.argument("policy", metavar="POLICY", type=EnumChoice(UIF))
-@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
-@click_force_option
-@click.pass_context
-def set_touch(ctx, key, policy, admin_pin, force):
-    """
-    Set the touch policy for OpenPGP keys.
-
-    The touch policy is used to require user interaction for all operations using the
-    private key on the YubiKey. The touch policy is set individually for each key slot.
-    To see the current touch policy, run the "openpgp info" subcommand.
-
-    Touch policies:
-
-    \b
-    Off (default)   no touch required
-    On              touch required
-    Fixed           touch required, can't be disabled without deleting the private key
-    Cached          touch required, cached for 15s after use
-    Cached-Fixed    touch required, cached for 15s after use, can't be disabled
-                    without deleting the private key
-
-    \b
-    KEY     key slot to set (sig, dec, aut or att)
-    POLICY  touch policy to set (on, off, fixed, cached or cached-fixed)
-    """
-    session = ctx.obj["session"]
-    policy_name = policy.name.lower().replace("_", "-")
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    prompt = f"Set touch policy of {key.name} key to {policy_name}?"
-    if policy.is_fixed:
-        prompt = (
-            "WARNING: This touch policy cannot be changed without deleting the "
-            + "corresponding key slot!\n"
-            + prompt
-        )
-
-    if force or click.confirm(prompt, abort=True, err=True):
-        try:
-            session.verify_admin(admin_pin)
-            session.set_uif(key, policy)
-            logger.info(f"Touch policy for slot {key.name} set")
-        except ApduError as e:
-            if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
-                raise CliFail("Touch policy not allowed.")
-            raise CliFail("Failed to set touch policy.")
-
-
-@keys.command("import")
-@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
-@click.pass_context
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
-@click.argument("private-key", type=click.File("rb"), metavar="PRIVATE-KEY")
-def import_key(ctx, key, private_key, admin_pin):
-    """
-    Import a private key (ONLY SUPPORTS ATTESTATION KEY).
-
-    Import a private key for OpenPGP attestation.
-
-    \b
-    PRIVATE-KEY  file containing the private key (use '-' to use stdin)
-    """
-    session = ctx.obj["session"]
-
-    if key != KEY_REF.ATT:
-        ctx.fail("Importing keys is only supported for the Attestation slot.")
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-    try:
-        private_key = parse_private_key(private_key.read(), password=None)
-    except Exception:
-        raise CliFail("Failed to parse private key.")
-    try:
-        session.verify_admin(admin_pin)
-        session.put_key(key, private_key)
-        logger.info(f"Private key imported for slot {key.name}")
-    except Exception:
-        raise CliFail("Failed to import attestation key.")
-
-
-@keys.command()
-@click.pass_context
-@click.option("-P", "--pin", help="PIN code")
-@click_format_option
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF, hidden=[KEY_REF.ATT]))
-@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
-def attest(ctx, key, certificate, pin, format):
-    """
-    Generate a attestation certificate for a key.
-
-    Attestation is used to show that an asymmetric key was generated on the
-    YubiKey and therefore doesn't exist outside the device.
-
-    \b
-    KEY          key slot to attest (sig, dec, aut)
-    CERTIFICATE  file to write attestation certificate to (use '-' to use stdout)
-    """
-
-    session = ctx.obj["session"]
-
-    if not pin:
-        pin = click_prompt("Enter PIN", hide_input=True)
-
-    try:
-        cert = session.get_certificate(key)
-    except ValueError:
-        cert = None
-
-    if not cert or click.confirm(
-        f"There is already data stored in the certificate slot for {key.value}, "
-        "do you want to overwrite it?"
-    ):
-        touch_policy = session.get_uif(KEY_REF.ATT)
-        if touch_policy in [UIF.ON, UIF.FIXED]:
-            click.echo("Touch the YubiKey sensor...")
-        try:
-            session.verify_pin(pin)
-            cert = session.attest_key(key)
-            certificate.write(cert.public_bytes(encoding=format))
-            logger.info(
-                f"Attestation certificate for slot {key.name} written to "
-                f"{_fname(certificate)}"
-            )
-        except Exception:
-            raise CliFail("Attestation failed")
-
-
-@openpgp.group("certificates")
-def certificates():
-    """
-    Manage certificates.
-    """
-
-
-@certificates.command("export")
-@click.pass_context
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
-@click_format_option
-@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
-def export_certificate(ctx, key, format, certificate):
-    """
-    Export an OpenPGP certificate.
-
-    \b
-    KEY          key slot to read from (sig, dec, aut, or att)
-    CERTIFICATE  file to write certificate to (use '-' to use stdout)
-    """
-    session = ctx.obj["session"]
-
-    try:
-        cert = session.get_certificate(key)
-    except ValueError:
-        raise CliFail(f"Failed to read certificate from slot {key.name}")
-    certificate.write(cert.public_bytes(encoding=format))
-    logger.info(f"Certificate for slot {key.name} exported to {_fname(certificate)}")
-
-
-@certificates.command("delete")
-@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
-@click.pass_context
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
-def delete_certificate(ctx, key, admin_pin):
-    """
-    Delete an OpenPGP certificate.
-
-    \b
-    KEY         Key slot to delete certificate from (sig, dec, aut, or att).
-    """
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-    try:
-        session.verify_admin(admin_pin)
-        session.delete_certificate(key)
-        logger.info(f"Certificate for slot {key.name} deleted")
-    except Exception:
-        raise CliFail("Failed to delete certificate.")
-
-
-@certificates.command("import")
-@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
-@click.pass_context
-@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
-@click.argument("cert", type=click.File("rb"), metavar="CERTIFICATE")
-def import_certificate(ctx, key, cert, admin_pin):
-    """
-    Import an OpenPGP certificate.
-
-    \b
-    KEY          key slot to import certificate to (sig, dec, aut, or att)
-    CERTIFICATE  file containing the certificate (use '-' to use stdin)
-    """
-    session = ctx.obj["session"]
-
-    if admin_pin is None:
-        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
-
-    try:
-        certs = parse_certificates(cert.read(), password=None)
-    except Exception:
-        raise CliFail("Failed to parse certificate.")
-    if len(certs) != 1:
-        raise CliFail("Can only import one certificate.")
-    try:
-        session.verify_admin(admin_pin)
-        session.put_certificate(key, certs[0])
-    except Exception:
-        raise CliFail("Failed to import certificate")
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core.smartcard import ApduError, SW, SmartCardConnection
+from yubikit.openpgp import OpenPgpSession, UIF, PIN_POLICY, KEY_REF as _KEY_REF
+from ..util import parse_certificates, parse_private_key
+from ..openpgp import get_openpgp_info
+from .util import (
+    CliFail,
+    click_force_option,
+    click_format_option,
+    click_postpone_execution,
+    click_prompt,
+    click_group,
+    EnumChoice,
+    pretty_print,
+)
+from enum import IntEnum
+import logging
+import click
+
+logger = logging.getLogger(__name__)
+
+
+class KEY_REF(IntEnum):
+    SIG = 0x01
+    DEC = 0x02
+    AUT = 0x03
+    ATT = 0x81
+    ENC = 0x02  # Alias for backwards compatibility, will be removed in ykman 6
+
+    def __getattribute__(self, name: str):
+        return _KEY_REF(self).__getattribute__(name)
+
+
+def _fname(fobj):
+    return getattr(fobj, "name", fobj)
+
+
+@click_group(connections=[SmartCardConnection])
+@click.pass_context
+@click_postpone_execution
+def openpgp(ctx):
+    """
+    Manage the OpenPGP application.
+
+    Examples:
+
+    \b
+      Set the retries for PIN, Reset Code and Admin PIN to 10:
+      $ ykman openpgp access set-retries 10 10 10
+
+    \b
+      Require touch to use the authentication key:
+      $ ykman openpgp keys set-touch aut on
+    """
+    dev = ctx.obj["device"]
+    conn = dev.open_connection(SmartCardConnection)
+    ctx.call_on_close(conn.close)
+    ctx.obj["session"] = OpenPgpSession(conn)
+
+
+@openpgp.command()
+@click.pass_context
+def info(ctx):
+    """
+    Display general status of the OpenPGP application.
+    """
+    session = ctx.obj["session"]
+    click.echo("\n".join(pretty_print(get_openpgp_info(session))))
+
+
+@openpgp.command()
+@click_force_option
+@click.pass_context
+def reset(ctx, force):
+    """
+    Reset all OpenPGP data.
+
+    This action will wipe all OpenPGP data, and set all PINs to their default
+    values.
+    """
+    force or click.confirm(
+        "WARNING! This will delete all stored OpenPGP keys and data and restore "
+        "factory settings. Proceed?",
+        abort=True,
+        err=True,
+    )
+
+    click.echo("Resetting OpenPGP data, don't remove the YubiKey...")
+    ctx.obj["session"].reset()
+    logger.info("OpenPGP application data reset")
+    click.echo("Success! All data has been cleared and default PINs are set.")
+    echo_default_pins()
+
+
+def echo_default_pins():
+    click.echo("PIN:         123456")
+    click.echo("Reset code:  NOT SET")
+    click.echo("Admin PIN:   12345678")
+
+
+@openpgp.group("access")
+def access():
+    """Manage PIN, Reset Code, and Admin PIN."""
+
+
+@access.command("set-retries")
+@click.argument("user-pin-retries", type=click.IntRange(1, 99), metavar="PIN-RETRIES")
+@click.argument(
+    "reset-code-retries", type=click.IntRange(1, 99), metavar="RESET-CODE-RETRIES"
+)
+@click.argument(
+    "admin-pin-retries", type=click.IntRange(1, 99), metavar="ADMIN-PIN-RETRIES"
+)
+@click.option("-a", "--admin-pin", help="admin PIN for OpenPGP")
+@click_force_option
+@click.pass_context
+def set_pin_retries(
+    ctx, admin_pin, user_pin_retries, reset_code_retries, admin_pin_retries, force
+):
+    """
+    Set the number of retry attempts for the User PIN, Reset Code, and Admin PIN.
+    """
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    resets_pins = session.version < (4, 0, 0)
+    if resets_pins:
+        click.echo("WARNING: Setting PIN retries will reset the values for all 3 PINs!")
+    if force or click.confirm(
+        f"Set PIN retry counters to: {user_pin_retries} {reset_code_retries} "
+        f"{admin_pin_retries}?",
+        abort=True,
+        err=True,
+    ):
+        session.verify_admin(admin_pin)
+        session.set_pin_attempts(
+            user_pin_retries, reset_code_retries, admin_pin_retries
+        )
+        logger.info("Number of PIN/Reset Code/Admin PIN retries set")
+
+        if resets_pins:
+            click.echo("Default PINs are set.")
+            echo_default_pins()
+
+
+@access.command("change-pin")
+@click.option("-P", "--pin", help="current PIN code")
+@click.option("-n", "--new-pin", help="a new PIN")
+@click.pass_context
+def change_pin(ctx, pin, new_pin):
+    """
+    Change the User PIN.
+
+    The PIN has a minimum length of 6, and supports any type of
+    alphanumeric characters.
+    """
+
+    session = ctx.obj["session"]
+
+    if pin is None:
+        pin = click_prompt("Enter PIN", hide_input=True)
+
+    if new_pin is None:
+        new_pin = click_prompt(
+            "New PIN",
+            hide_input=True,
+            confirmation_prompt=True,
+        )
+
+    session.change_pin(pin, new_pin)
+
+
+@access.command("change-reset-code")
+@click.option("-a", "--admin-pin", help="Admin PIN")
+@click.option("-r", "--reset-code", help="a new Reset Code")
+@click.pass_context
+def change_reset_code(ctx, admin_pin, reset_code):
+    """
+    Change the Reset Code.
+
+    The Reset Code has a minimum length of 6, and supports any type of
+    alphanumeric characters.
+    """
+
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    if reset_code is None:
+        reset_code = click_prompt(
+            "New Reset Code",
+            hide_input=True,
+            confirmation_prompt=True,
+        )
+
+    session.verify_admin(admin_pin)
+    session.set_reset_code(reset_code)
+
+
+@access.command("change-admin-pin")
+@click.option("-a", "--admin-pin", help="current Admin PIN")
+@click.option("-n", "--new-admin-pin", help="new Admin PIN")
+@click.pass_context
+def change_admin(ctx, admin_pin, new_admin_pin):
+    """
+    Change the Admin PIN.
+
+    The Admin PIN has a minimum length of 8, and supports any type of
+    alphanumeric characters.
+    """
+
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    if new_admin_pin is None:
+        new_admin_pin = click_prompt(
+            "New Admin PIN",
+            hide_input=True,
+            confirmation_prompt=True,
+        )
+
+    session.change_admin(admin_pin, new_admin_pin)
+
+
+@access.command("unblock-pin")
+@click.option(
+    "-a", "--admin-pin", help='admin PIN (use "-" as a value to prompt for input)'
+)
+@click.option("-r", "--reset-code", help="Reset Code")
+@click.option("-n", "--new-pin", help="a new PIN")
+@click.pass_context
+def unblock_pin(ctx, admin_pin, reset_code, new_pin):
+    """
+    Unblock the PIN (using Reset Code or Admin PIN).
+
+    If the PIN is lost or blocked you can reset it to a new value using either the
+    Reset Code OR the Admin PIN.
+
+    The new PIN has a minimum length of 6, and supports any type of
+    alphanumeric characters.
+    """
+
+    session = ctx.obj["session"]
+
+    if reset_code is not None and admin_pin is not None:
+        raise CliFail(
+            "Invalid options: Only one of --reset-code and --admin-pin may be used."
+        )
+
+    if admin_pin == "-":
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    if reset_code is None and admin_pin is None:
+        reset_code = click_prompt("Enter Reset Code", hide_input=True)
+
+    if new_pin is None:
+        new_pin = click_prompt(
+            "New PIN",
+            hide_input=True,
+            confirmation_prompt=True,
+        )
+
+    if admin_pin:
+        session.verify_admin(admin_pin)
+    session.reset_pin(new_pin, reset_code)
+
+
+@access.command("set-signature-policy")
+@click.argument("policy", metavar="POLICY", type=EnumChoice(PIN_POLICY))
+@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
+@click.pass_context
+def set_signature_policy(ctx, policy, admin_pin):
+    """
+    Set the Signature PIN policy.
+
+    The Signature PIN policy is used to control whether the PIN is
+    always required when using the Signature key, or if it is required
+    only once per session.
+
+    \b
+    POLICY  signature PIN policy to set (always, once)
+    """
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    try:
+        session.verify_admin(admin_pin)
+        session.set_signature_pin_policy(policy)
+    except Exception:
+        raise CliFail("Failed to set new Signature PIN policy")
+
+
+@openpgp.group("keys")
+def keys():
+    """Manage private keys."""
+
+
+@keys.command("set-touch")
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
+@click.argument("policy", metavar="POLICY", type=EnumChoice(UIF))
+@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
+@click_force_option
+@click.pass_context
+def set_touch(ctx, key, policy, admin_pin, force):
+    """
+    Set the touch policy for OpenPGP keys.
+
+    The touch policy is used to require user interaction for all operations using the
+    private key on the YubiKey. The touch policy is set individually for each key slot.
+    To see the current touch policy, run the "openpgp info" subcommand.
+
+    Touch policies:
+
+    \b
+    Off (default)   no touch required
+    On              touch required
+    Fixed           touch required, can't be disabled without deleting the private key
+    Cached          touch required, cached for 15s after use
+    Cached-Fixed    touch required, cached for 15s after use, can't be disabled
+                    without deleting the private key
+
+    \b
+    KEY     key slot to set (sig, dec, aut or att)
+    POLICY  touch policy to set (on, off, fixed, cached or cached-fixed)
+    """
+    session = ctx.obj["session"]
+    policy_name = policy.name.lower().replace("_", "-")
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    prompt = f"Set touch policy of {key.name} key to {policy_name}?"
+    if policy.is_fixed:
+        prompt = (
+            "WARNING: This touch policy cannot be changed without deleting the "
+            + "corresponding key slot!\n"
+            + prompt
+        )
+
+    if force or click.confirm(prompt, abort=True, err=True):
+        try:
+            session.verify_admin(admin_pin)
+            session.set_uif(key, policy)
+            logger.info(f"Touch policy for slot {key.name} set")
+        except ApduError as e:
+            if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
+                raise CliFail("Touch policy not allowed.")
+            raise CliFail("Failed to set touch policy.")
+
+
+@keys.command("import")
+@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
+@click.pass_context
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
+@click.argument("private-key", type=click.File("rb"), metavar="PRIVATE-KEY")
+def import_key(ctx, key, private_key, admin_pin):
+    """
+    Import a private key (ONLY SUPPORTS ATTESTATION KEY).
+
+    Import a private key for OpenPGP attestation.
+
+    \b
+    PRIVATE-KEY  file containing the private key (use '-' to use stdin)
+    """
+    session = ctx.obj["session"]
+
+    if key != KEY_REF.ATT:
+        ctx.fail("Importing keys is only supported for the Attestation slot.")
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+    try:
+        private_key = parse_private_key(private_key.read(), password=None)
+    except Exception:
+        raise CliFail("Failed to parse private key.")
+    try:
+        session.verify_admin(admin_pin)
+        session.put_key(key, private_key)
+        logger.info(f"Private key imported for slot {key.name}")
+    except Exception:
+        raise CliFail("Failed to import attestation key.")
+
+
+@keys.command()
+@click.pass_context
+@click.option("-P", "--pin", help="PIN code")
+@click_format_option
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF, hidden=[KEY_REF.ATT]))
+@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
+def attest(ctx, key, certificate, pin, format):
+    """
+    Generate a attestation certificate for a key.
+
+    Attestation is used to show that an asymmetric key was generated on the
+    YubiKey and therefore doesn't exist outside the device.
+
+    \b
+    KEY          key slot to attest (sig, dec, aut)
+    CERTIFICATE  file to write attestation certificate to (use '-' to use stdout)
+    """
+
+    session = ctx.obj["session"]
+
+    if not pin:
+        pin = click_prompt("Enter PIN", hide_input=True)
+
+    try:
+        cert = session.get_certificate(key)
+    except ValueError:
+        cert = None
+
+    if not cert or click.confirm(
+        f"There is already data stored in the certificate slot for {key.value}, "
+        "do you want to overwrite it?"
+    ):
+        touch_policy = session.get_uif(KEY_REF.ATT)
+        if touch_policy in [UIF.ON, UIF.FIXED]:
+            click.echo("Touch the YubiKey sensor...")
+        try:
+            session.verify_pin(pin)
+            cert = session.attest_key(key)
+            certificate.write(cert.public_bytes(encoding=format))
+            logger.info(
+                f"Attestation certificate for slot {key.name} written to "
+                f"{_fname(certificate)}"
+            )
+        except Exception:
+            raise CliFail("Attestation failed")
+
+
+@openpgp.group("certificates")
+def certificates():
+    """
+    Manage certificates.
+    """
+
+
+@certificates.command("export")
+@click.pass_context
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
+@click_format_option
+@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
+def export_certificate(ctx, key, format, certificate):
+    """
+    Export an OpenPGP certificate.
+
+    \b
+    KEY          key slot to read from (sig, dec, aut, or att)
+    CERTIFICATE  file to write certificate to (use '-' to use stdout)
+    """
+    session = ctx.obj["session"]
+
+    try:
+        cert = session.get_certificate(key)
+    except ValueError:
+        raise CliFail(f"Failed to read certificate from slot {key.name}")
+    certificate.write(cert.public_bytes(encoding=format))
+    logger.info(f"Certificate for slot {key.name} exported to {_fname(certificate)}")
+
+
+@certificates.command("delete")
+@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
+@click.pass_context
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
+def delete_certificate(ctx, key, admin_pin):
+    """
+    Delete an OpenPGP certificate.
+
+    \b
+    KEY         Key slot to delete certificate from (sig, dec, aut, or att).
+    """
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+    try:
+        session.verify_admin(admin_pin)
+        session.delete_certificate(key)
+        logger.info(f"Certificate for slot {key.name} deleted")
+    except Exception:
+        raise CliFail("Failed to delete certificate.")
+
+
+@certificates.command("import")
+@click.option("-a", "--admin-pin", help="Admin PIN for OpenPGP")
+@click.pass_context
+@click.argument("key", metavar="KEY", type=EnumChoice(KEY_REF))
+@click.argument("cert", type=click.File("rb"), metavar="CERTIFICATE")
+def import_certificate(ctx, key, cert, admin_pin):
+    """
+    Import an OpenPGP certificate.
+
+    \b
+    KEY          key slot to import certificate to (sig, dec, aut, or att)
+    CERTIFICATE  file containing the certificate (use '-' to use stdin)
+    """
+    session = ctx.obj["session"]
+
+    if admin_pin is None:
+        admin_pin = click_prompt("Enter Admin PIN", hide_input=True)
+
+    try:
+        certs = parse_certificates(cert.read(), password=None)
+    except Exception:
+        raise CliFail("Failed to parse certificate.")
+    if len(certs) != 1:
+        raise CliFail("Can only import one certificate.")
+    try:
+        session.verify_admin(admin_pin)
+        session.put_certificate(key, certs[0])
+    except Exception:
+        raise CliFail("Failed to import certificate")
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/otp.py` & `yubikey_manager-5.1.1/ykman/_cli/otp.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,931 +1,933 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from base64 import b32encode
-from yubikit.yubiotp import (
-    SLOT,
-    NDEF_TYPE,
-    YubiOtpSession,
-    YubiOtpSlotConfiguration,
-    HmacSha1SlotConfiguration,
-    StaticPasswordSlotConfiguration,
-    HotpSlotConfiguration,
-    UpdateConfiguration,
-)
-from yubikit.core import TRANSPORT, CommandError
-from yubikit.core.otp import (
-    MODHEX_ALPHABET,
-    modhex_encode,
-    modhex_decode,
-    OtpConnection,
-)
-from yubikit.core.smartcard import SmartCardConnection
-
-from .util import (
-    CliFail,
-    click_group,
-    click_force_option,
-    click_callback,
-    click_parse_b32_key,
-    click_postpone_execution,
-    click_prompt,
-    prompt_for_touch,
-    EnumChoice,
-    is_yk4_fips,
-)
-from .. import __version__
-from ..scancodes import encode, KEYBOARD_LAYOUT
-from ..otp import (
-    _PrepareUploadFailed,
-    _prepare_upload_key,
-    is_in_fips_mode,
-    generate_static_pw,
-    parse_oath_key,
-    parse_b32_key,
-    time_challenge,
-    format_oath_code,
-    format_csv,
-)
-from threading import Event
-from time import time
-import logging
-import os
-import struct
-import click
-import webbrowser
-
-
-logger = logging.getLogger(__name__)
-
-
-def parse_hex(length):
-    @click_callback()
-    def inner(ctx, param, val):
-        val = bytes.fromhex(val)
-        if len(val) != length:
-            raise ValueError(f"Must be exactly {length} bytes.")
-        return val
-
-    return inner
-
-
-def parse_access_code_hex(access_code_hex):
-    try:
-        access_code = bytes.fromhex(access_code_hex)
-    except TypeError as e:
-        raise ValueError(e)
-    if len(access_code) != 6:
-        raise ValueError("Must be exactly 6 bytes.")
-
-    return access_code
-
-
-click_slot_argument = click.argument(
-    "slot", type=click.Choice(["1", "2"]), callback=lambda c, p, v: SLOT(int(v))
-)
-
-
-_WRITE_FAIL_MSG = (
-    "Failed to write to the YubiKey. Make sure the device does not "
-    'have restricted access (see "ykman otp --help" for more info).'
-)
-
-
-def _confirm_slot_overwrite(slot_state, slot):
-    if slot_state.is_configured(slot):
-        click.confirm(
-            f"Slot {slot} is already configured. Overwrite configuration?",
-            abort=True,
-            err=True,
-        )
-
-
-def _fname(fobj):
-    return getattr(fobj, "name", fobj)
-
-
-@click_group(connections=[OtpConnection, SmartCardConnection])
-@click.pass_context
-@click_postpone_execution
-@click.option(
-    "--access-code",
-    required=False,
-    metavar="HEX",
-    help='6 byte access code (use "-" as a value to prompt for input)',
-)
-def otp(ctx, access_code):
-    """
-    Manage the YubiOTP application.
-
-    The YubiKey provides two keyboard-based slots which can each be configured
-    with a credential. Several credential types are supported.
-
-    A slot configuration may be write-protected with an access code. This
-    prevents the configuration to be overwritten without the access code
-    provided. Mode switching the YubiKey is not possible when a slot is
-    configured with an access code. To provide an access code to commands
-    which require it, use the --access-code option. Note that this option must
-    be given directly after the "otp" command, before any sub-command.
-
-    Examples:
-
-    \b
-      Swap the configurations between the two slots:
-      $ ykman otp swap
-
-    \b
-      Program a random challenge-response credential to slot 2:
-      $ ykman otp chalresp --generate 2
-
-    \b
-      Program a Yubico OTP credential to slot 1, using the serial as public id:
-      $ ykman otp yubiotp 1 --serial-public-id
-
-    \b
-      Program a random 38 characters long static password to slot 2:
-      $ ykman otp static --generate 2 --length 38
-
-    \b
-      Remove a currently set access code from slot 2):
-      $ ykman otp --access-code 0123456789ab settings 2 --delete-access-code
-    """
-
-    """
-    # TODO: Require OTP for chalresp, or FW < 5.?. Require CCID for HashOTP
-    dev = ctx.obj["device"]
-    if dev.supports_connection(OtpConnection):
-        conn = dev.open_connection(OtpConnection)
-    else:
-        conn = dev.open_connection(SmartCardConnection)
-    ctx.call_on_close(conn.close)
-
-    ctx.obj["session"] = YubiOtpSession(conn)
-    """
-
-    if access_code is not None:
-        if access_code == "-":
-            access_code = click_prompt("Enter the access code", hide_input=True)
-
-        try:
-            access_code = parse_access_code_hex(access_code)
-        except Exception as e:
-            ctx.fail(f"Failed to parse access code: {e}")
-
-    ctx.obj["access_code"] = access_code
-
-
-def _get_session(ctx, types=[OtpConnection, SmartCardConnection]):
-    dev = ctx.obj["device"]
-    for conn_type in types:
-        if dev.supports_connection(conn_type):
-            conn = dev.open_connection(conn_type)
-            ctx.call_on_close(conn.close)
-            return YubiOtpSession(conn)
-    raise CliFail(
-        "The connection type required for this command is not supported/enabled on the "
-        "YubiKey"
-    )
-
-
-@otp.command()
-@click.pass_context
-def info(ctx):
-    """
-    Display general status of the YubiKey OTP slots.
-    """
-    session = _get_session(ctx)
-    state = session.get_config_state()
-    slot1 = state.is_configured(1)
-    slot2 = state.is_configured(2)
-
-    click.echo(f"Slot 1: {slot1 and 'programmed' or 'empty'}")
-    click.echo(f"Slot 2: {slot2 and 'programmed' or 'empty'}")
-
-    if is_yk4_fips(ctx.obj["info"]):
-        click.echo(f"FIPS Approved Mode: {'Yes' if is_in_fips_mode(session) else 'No'}")
-
-
-@otp.command()
-@click_force_option
-@click.pass_context
-def swap(ctx, force):
-    """
-    Swaps the two slot configurations.
-    """
-    session = _get_session(ctx)
-    force or click.confirm(
-        "Swap the two slots of the YubiKey?",
-        abort=True,
-        err=True,
-    )
-
-    click.echo("Swapping slots...")
-    try:
-        session.swap_slots()
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click.pass_context
-@click.option("-p", "--prefix", help="added before the NDEF payload, typically a URI")
-@click.option(
-    "-t",
-    "--ndef-type",
-    type=EnumChoice(NDEF_TYPE),
-    default="URI",
-    show_default=True,
-    help="NDEF payload type",
-)
-def ndef(ctx, slot, prefix, ndef_type):
-    """
-    Configure a slot to be used over NDEF (NFC).
-
-    \b
-    If "--prefix" is not specified, a default value will be used, based on the type:
-    - For URI the default value is: "https://my.yubico.com/yk/#"
-    - For TEXT the default is an empty string
-    """
-    info = ctx.obj["info"]
-    session = _get_session(ctx)
-    state = session.get_config_state()
-    if not info.has_transport(TRANSPORT.NFC):
-        raise CliFail("This YubiKey does not support NFC.")
-
-    if not state.is_configured(slot):
-        raise CliFail(f"Slot {slot} is empty.")
-
-    try:
-        session.set_ndef_configuration(slot, prefix, ctx.obj["access_code"], ndef_type)
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click_force_option
-@click.pass_context
-def delete(ctx, slot, force):
-    """
-    Deletes the configuration stored in a slot.
-    """
-    session = _get_session(ctx)
-    state = session.get_config_state()
-    if not force and not state.is_configured(slot):
-        raise CliFail("Not possible to delete an empty slot.")
-    force or click.confirm(
-        f"Do you really want to delete the configuration of slot {slot}?",
-        abort=True,
-        err=True,
-    )
-    click.echo(f"Deleting the configuration in slot {slot}...")
-    try:
-        session.delete_slot(slot, ctx.obj["access_code"])
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click.option(
-    "-P",
-    "--public-id",
-    required=False,
-    help="public identifier prefix",
-    metavar="MODHEX",
-)
-@click.option(
-    "-p",
-    "--private-id",
-    required=False,
-    metavar="HEX",
-    callback=parse_hex(6),
-    help="6 byte private identifier",
-)
-@click.option(
-    "-k",
-    "--key",
-    required=False,
-    metavar="HEX",
-    callback=parse_hex(16),
-    help="16 byte secret key",
-)
-@click.option(
-    "--no-enter",
-    is_flag=True,
-    help="don't send an Enter keystroke after emitting the OTP",
-)
-@click.option(
-    "-S",
-    "--serial-public-id",
-    is_flag=True,
-    required=False,
-    help="use YubiKey serial number as public ID (can't be used with --public-id)",
-)
-@click.option(
-    "-g",
-    "--generate-private-id",
-    is_flag=True,
-    required=False,
-    help="generate a random private ID (can't be used with --private-id)",
-)
-@click.option(
-    "-G",
-    "--generate-key",
-    is_flag=True,
-    required=False,
-    help="generate a random secret key (can't be used with --key)",
-)
-@click.option(
-    "-u",
-    "--upload",
-    is_flag=True,
-    required=False,
-    help="upload credential to YubiCloud (opens a browser, can't be used with --force)",
-)
-@click.option(
-    "-O",
-    "--config-output",
-    type=click.File("a"),
-    required=False,
-    help="file to output the configuration to (existing file will be appended to)",
-)
-@click_force_option
-@click.pass_context
-def yubiotp(
-    ctx,
-    slot,
-    public_id,
-    private_id,
-    key,
-    no_enter,
-    force,
-    serial_public_id,
-    generate_private_id,
-    generate_key,
-    upload,
-    config_output,
-):
-    """
-    Program a Yubico OTP credential.
-    """
-
-    info = ctx.obj["info"]
-    session = _get_session(ctx)
-    serial = None
-
-    if public_id and serial_public_id:
-        ctx.fail("Invalid options: --public-id conflicts with --serial-public-id.")
-
-    if private_id and generate_private_id:
-        ctx.fail("Invalid options: --private-id conflicts with --generate-public-id.")
-
-    if upload and force:
-        ctx.fail("Invalid options: --upload conflicts with --force.")
-
-    if key and generate_key:
-        ctx.fail("Invalid options: --key conflicts with --generate-key.")
-
-    if not public_id:
-        if serial_public_id:
-            try:
-                serial = session.get_serial()
-            except CommandError:
-                raise CliFail("Serial number not set, public ID must be provided")
-
-            public_id = modhex_encode(b"\xff\x00" + struct.pack(b">I", serial))
-            click.echo(f"Using YubiKey serial as public ID: {public_id}")
-        elif force:
-            ctx.fail(
-                "Public ID not given. Please remove the --force flag, or "
-                "add the --serial-public-id flag or --public-id option."
-            )
-        else:
-            public_id = click_prompt("Enter public ID")
-
-    try:
-        public_id = modhex_decode(public_id)
-    except ValueError:
-        ctx.fail(f"Invalid public ID, must be modhex ({MODHEX_ALPHABET}).")
-
-    if not private_id:
-        if generate_private_id:
-            private_id = os.urandom(6)
-            click.echo(f"Using a randomly generated private ID: {private_id.hex()}")
-        elif force:
-            ctx.fail(
-                "Private ID not given. Please remove the --force flag, or "
-                "add the --generate-private-id flag or --private-id option."
-            )
-        else:
-            private_id = click_prompt("Enter private ID")
-            private_id = bytes.fromhex(private_id)
-
-    if not key:
-        if generate_key:
-            key = os.urandom(16)
-            click.echo(f"Using a randomly generated secret key: {key.hex()}")
-        elif force:
-            ctx.fail(
-                "Secret key not given. Please remove the --force flag, or "
-                "add the --generate-key flag or --key option."
-            )
-        else:
-            key = click_prompt("Enter secret key")
-            key = bytes.fromhex(key)
-
-    if upload:
-        click.confirm("Upload credential to YubiCloud?", abort=True, err=True)
-
-        try:
-            upload_url = _prepare_upload_key(
-                key,
-                public_id,
-                private_id,
-                serial=info.serial,
-                user_agent="ykman/" + __version__,
-            )
-            click.echo("Upload to YubiCloud initiated successfully.")
-            logger.info("Initiated YubiCloud upload")
-        except _PrepareUploadFailed as e:
-            error_msg = "\n".join(e.messages())
-            raise CliFail("Upload to YubiCloud failed.\n" + error_msg)
-
-    force or click.confirm(
-        f"Program a YubiOTP credential in slot {slot}?", abort=True, err=True
-    )
-
-    access_code = ctx.obj["access_code"]
-    try:
-        session.put_configuration(
-            slot,
-            YubiOtpSlotConfiguration(public_id, private_id, key).append_cr(
-                not no_enter
-            ),
-            access_code,
-            access_code,
-        )
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-    if config_output:
-        serial = serial or session.get_serial()
-        csv = format_csv(serial, public_id, private_id, key, access_code)
-        config_output.write(csv + "\n")
-        logger.info(f"Configuration parameters written to {_fname(config_output)}")
-
-    if upload:
-        logger.info("Launching browser for YubiCloud upload")
-        click.echo("Opening upload form in browser: " + upload_url)
-        webbrowser.open_new_tab(upload_url)
-
-
-@otp.command()
-@click_slot_argument
-@click.argument("password", required=False)
-@click.option("-g", "--generate", is_flag=True, help="generate a random password")
-@click.option(
-    "-l",
-    "--length",
-    metavar="LENGTH",
-    type=click.IntRange(1, 38),
-    default=38,
-    show_default=True,
-    help="length of generated password",
-)
-@click.option(
-    "-k",
-    "--keyboard-layout",
-    type=EnumChoice(KEYBOARD_LAYOUT),
-    default="MODHEX",
-    show_default=True,
-    help="keyboard layout to use for the static password",
-)
-@click.option(
-    "--no-enter",
-    is_flag=True,
-    help="don't send an Enter keystroke after outputting the password",
-)
-@click_force_option
-@click.pass_context
-def static(ctx, slot, password, generate, length, keyboard_layout, no_enter, force):
-    """
-    Configure a static password.
-
-    To avoid problems with different keyboard layouts, the following characters
-    (upper and lower case) are allowed by default: cbdefghijklnrtuv
-
-    Use the --keyboard-layout option to allow more characters based on
-    preferred keyboard layout.
-    """
-
-    session = _get_session(ctx)
-
-    if password and len(password) > 38:
-        ctx.fail("Password too long (maximum length is 38 characters).")
-    if generate and not length:
-        ctx.fail("Provide a length for the generated password.")
-
-    if not password and not generate:
-        password = click_prompt("Enter a static password")
-    elif not password and generate:
-        password = generate_static_pw(length, keyboard_layout)
-
-    scan_codes = encode(password, keyboard_layout)
-
-    if not force:
-        _confirm_slot_overwrite(session.get_config_state(), slot)
-    try:
-        session.put_configuration(
-            slot,
-            StaticPasswordSlotConfiguration(scan_codes).append_cr(not no_enter),
-            ctx.obj["access_code"],
-            ctx.obj["access_code"],
-        )
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click.argument("key", required=False)
-@click.option(
-    "-t",
-    "--touch",
-    is_flag=True,
-    help="require touch on the YubiKey to generate a response",
-)
-@click.option(
-    "-T",
-    "--totp",
-    is_flag=True,
-    required=False,
-    help="use a base32 encoded key (optionally padded) for TOTP credentials",
-)
-@click.option(
-    "-g",
-    "--generate",
-    is_flag=True,
-    required=False,
-    help="generate a random secret key (can't be used with KEY argument)",
-)
-@click_force_option
-@click.pass_context
-def chalresp(ctx, slot, key, totp, touch, force, generate):
-    """
-    Program a challenge-response credential.
-
-    If KEY is not given, an interactive prompt will ask for it.
-
-    \b
-    KEY     a key given in hex (or base32, if --totp is specified)
-    """
-    session = _get_session(ctx)
-
-    if key:
-        if generate:
-            ctx.fail("Invalid options: --generate conflicts with KEY argument.")
-        elif totp:
-            key = parse_b32_key(key)
-        else:
-            key = parse_oath_key(key)
-    else:
-        if force and not generate:
-            ctx.fail(
-                "No secret key given. Please remove the --force flag, "
-                "set the KEY argument or set the --generate flag."
-            )
-        elif generate:
-            key = os.urandom(20)
-            if totp:
-                b32key = b32encode(key).decode()
-                click.echo(f"Using a randomly generated key (base32): {b32key}")
-            else:
-                click.echo(f"Using a randomly generated key (hex): {key.hex()}")
-        elif totp:
-            while True:
-                key = click_prompt("Enter a secret key (base32)")
-                try:
-                    key = parse_b32_key(key)
-                    break
-                except Exception as e:
-                    click.echo(e)
-        else:
-            key = click_prompt("Enter a secret key")
-            key = parse_oath_key(key)
-
-    cred_type = "TOTP" if totp else "challenge-response"
-    force or click.confirm(
-        f"Program a {cred_type} credential in slot {slot}?",
-        abort=True,
-        err=True,
-    )
-    try:
-        session.put_configuration(
-            slot,
-            HmacSha1SlotConfiguration(key).require_touch(touch),
-            ctx.obj["access_code"],
-            ctx.obj["access_code"],
-        )
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click.argument("challenge", required=False)
-@click.option(
-    "-T",
-    "--totp",
-    is_flag=True,
-    help="generate a TOTP code, use the current time if challenge is omitted",
-)
-@click.option(
-    "-d",
-    "--digits",
-    type=click.Choice(["6", "8"]),
-    default="6",
-    help="number of digits in generated TOTP code (default: 6), "
-    "ignored unless --totp is set",
-)
-@click.pass_context
-def calculate(ctx, slot, challenge, totp, digits):
-    """
-    Perform a challenge-response operation.
-
-    Send a challenge (in hex) to a YubiKey slot with a challenge-response
-    credential, and read the response. Supports output as a OATH-TOTP code.
-    """
-    dev = ctx.obj["device"]
-    if dev.transport == TRANSPORT.NFC:
-        session = _get_session(ctx, [SmartCardConnection])
-    else:
-        # Calculate over USB is only available over OtpConnection
-        session = _get_session(ctx, [OtpConnection])
-
-    if not challenge and not totp:
-        challenge = click_prompt("Enter a challenge (hex)")
-
-    # Check that slot is not empty
-    if not session.get_config_state().is_configured(slot):
-        raise CliFail("Cannot perform challenge-response on an empty slot.")
-
-    if totp:  # Challenge omitted or timestamp
-        if challenge is None:
-            challenge = time_challenge(int(time()))
-        else:
-            try:
-                challenge = time_challenge(int(challenge))
-            except Exception:
-                logger.exception("Error parsing challenge")
-                ctx.fail("Timestamp challenge for TOTP must be an integer.")
-    else:  # Challenge is hex
-        challenge = bytes.fromhex(challenge)
-
-    try:
-        event = Event()
-
-        def on_keepalive(status):
-            if not hasattr(on_keepalive, "prompted") and status == 2:
-                prompt_for_touch()
-                setattr(on_keepalive, "prompted", True)
-
-        response = session.calculate_hmac_sha1(slot, challenge, event, on_keepalive)
-        if totp:
-            value = format_oath_code(response, int(digits))
-        else:
-            value = response.hex()
-
-        click.echo(value)
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-def parse_modhex_or_bcd(value):
-    try:
-        return True, modhex_decode(value)
-    except ValueError:
-        try:
-            int(value)
-            return False, bytes.fromhex(value)
-        except ValueError:
-            raise ValueError("value must be modhex or decimal")
-
-
-@otp.command()
-@click_slot_argument
-@click.argument("key", callback=click_parse_b32_key, required=False)
-@click.option(
-    "-d",
-    "--digits",
-    type=click.Choice(["6", "8"]),
-    default="6",
-    help="number of digits in generated code (default is 6)",
-)
-@click.option("-c", "--counter", type=int, default=0, help="initial counter value")
-@click.option("-i", "--identifier", help="token identifier")
-@click.option(
-    "--no-enter",
-    is_flag=True,
-    help="don't send an Enter keystroke after outputting the code",
-)
-@click_force_option
-@click.pass_context
-def hotp(ctx, slot, key, digits, counter, identifier, no_enter, force):
-    """
-    Program an HMAC-SHA1 OATH-HOTP credential.
-
-    The YubiKey can be configured to output an OATH Token Identifier as a prefix
-    to the OTP itself, which consists of OMP+TT+MUI. Using the "--identifier" option,
-    you may specify the OMP+TT as 4 characters, the MUI as 8 characters, or the full
-    OMP+TT+MUI as 12 characters. If omitted, a default value of "ubhe" will be used for
-    OMP+TT, and the YubiKey serial number will be used as MUI.
-    """
-    session = _get_session(ctx)
-
-    mh1 = False
-    mh2 = False
-    if identifier:
-        if identifier == "-":
-            identifier = "ubhe"
-        if len(identifier) == 4:
-            identifier += f"{session.get_serial():08}"
-        elif len(identifier) == 8:
-            identifier = "ubhe" + identifier
-        if len(identifier) != 12:
-            raise ValueError("Incorrect length for token identifier.")
-
-        omp_m, omp = parse_modhex_or_bcd(identifier[:2])
-        tt_m, tt = parse_modhex_or_bcd(identifier[2:4])
-        mui_m, mui = parse_modhex_or_bcd(identifier[4:])
-        if tt_m and not omp_m:
-            raise ValueError("TT can only be modhex encoded if OMP is as well.")
-        if mui_m and not (omp_m and tt_m):
-            raise ValueError(
-                "MUI can only be modhex encoded if OMP and TT are as well."
-            )
-        token_id = omp + tt + mui
-        if mui_m:
-            mh1 = mh2 = True
-        elif tt_m:
-            mh2 = True
-        elif omp_m:
-            mh1 = True
-    else:
-        token_id = b""
-
-    if not key:
-        while True:
-            key = click_prompt("Enter a secret key (base32)")
-            try:
-                key = parse_b32_key(key)
-                break
-            except Exception as e:
-                click.echo(e)
-
-    force or click.confirm(
-        f"Program a HOTP credential in slot {slot}?", abort=True, err=True
-    )
-    try:
-        session.put_configuration(
-            slot,
-            HotpSlotConfiguration(key)
-            .imf(counter)
-            .token_id(token_id, mh1, mh2)
-            .digits8(int(digits) == 8)
-            .append_cr(not no_enter),
-            ctx.obj["access_code"],
-            ctx.obj["access_code"],
-        )
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
-
-
-@otp.command()
-@click_slot_argument
-@click_force_option
-@click.pass_context
-@click.option(
-    "-A",
-    "--new-access-code",
-    metavar="HEX",
-    required=False,
-    help='a new 6 byte access code to set (use "-" as a value to prompt for input)',
-)
-@click.option(
-    "--delete-access-code", is_flag=True, help="remove access code from the slot"
-)
-@click.option(
-    "--enter/--no-enter",
-    default=True,
-    show_default=True,
-    help="send an Enter keystroke after slot output",
-)
-@click.option(
-    "-p",
-    "--pacing",
-    type=click.Choice(["0", "20", "40", "60"]),
-    default="0",
-    show_default=True,
-    help="throttle output speed by adding a delay (in ms) between characters emitted",
-)
-@click.option(
-    "--use-numeric-keypad",
-    is_flag=True,
-    show_default=True,
-    help="use scancodes for numeric keypad when sending digits "
-    "(helps for some keyboard layouts)",
-)
-def settings(
-    ctx,
-    slot,
-    new_access_code,
-    delete_access_code,
-    enter,
-    pacing,
-    use_numeric_keypad,
-    force,
-):
-    """
-    Update the settings for a slot.
-
-    Change the settings for a slot without changing the stored secret.
-    All settings not specified will be written with default values.
-    """
-    session = _get_session(ctx)
-
-    if new_access_code and delete_access_code:
-        ctx.fail("--new-access-code conflicts with --delete-access-code.")
-
-    if delete_access_code and not ctx.obj["access_code"]:
-        raise CliFail(
-            "--delete-access-code used without providing an access code "
-            '(see "ykman otp --help" for more info).'
-        )
-
-    if not session.get_config_state().is_configured(slot):
-        raise CliFail("Not possible to update settings on an empty slot.")
-
-    if new_access_code is None:
-        if not delete_access_code:
-            new_access_code = ctx.obj["access_code"]
-    else:
-        if new_access_code == "-":
-            new_access_code = click_prompt(
-                "Enter new access code", hide_input=True, confirmation_prompt=True
-            )
-
-        try:
-            new_access_code = parse_access_code_hex(new_access_code)
-        except Exception as e:
-            ctx.fail("Failed to parse access code: " + str(e))
-
-    force or click.confirm(
-        f"Update the settings for slot {slot}? "
-        "All existing settings will be overwritten.",
-        abort=True,
-        err=True,
-    )
-    click.echo(f"Updating settings for slot {slot}...")
-
-    pacing_bits = int(pacing or "0") // 20
-    pacing_10ms = bool(pacing_bits & 1)
-    pacing_20ms = bool(pacing_bits & 2)
-
-    try:
-        session.update_configuration(
-            slot,
-            UpdateConfiguration()
-            .append_cr(enter)
-            .use_numeric(use_numeric_keypad)
-            .pacing(pacing_10ms, pacing_20ms),
-            new_access_code,
-            ctx.obj["access_code"],
-        )
-    except CommandError:
-        raise CliFail(_WRITE_FAIL_MSG)
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from base64 import b32encode
+from yubikit.yubiotp import (
+    SLOT,
+    NDEF_TYPE,
+    YubiOtpSession,
+    YubiOtpSlotConfiguration,
+    HmacSha1SlotConfiguration,
+    StaticPasswordSlotConfiguration,
+    HotpSlotConfiguration,
+    UpdateConfiguration,
+)
+from yubikit.core import TRANSPORT, CommandError
+from yubikit.core.otp import (
+    MODHEX_ALPHABET,
+    modhex_encode,
+    modhex_decode,
+    OtpConnection,
+)
+from yubikit.core.smartcard import SmartCardConnection
+
+from .util import (
+    CliFail,
+    click_group,
+    click_force_option,
+    click_callback,
+    click_parse_b32_key,
+    click_postpone_execution,
+    click_prompt,
+    prompt_for_touch,
+    EnumChoice,
+    is_yk4_fips,
+)
+from .. import __version__
+from ..scancodes import encode, KEYBOARD_LAYOUT
+from ..otp import (
+    _PrepareUploadFailed,
+    _prepare_upload_key,
+    is_in_fips_mode,
+    generate_static_pw,
+    parse_oath_key,
+    parse_b32_key,
+    time_challenge,
+    format_oath_code,
+    format_csv,
+)
+from threading import Event
+from time import time
+import logging
+import os
+import struct
+import click
+import webbrowser
+
+
+logger = logging.getLogger(__name__)
+
+
+def parse_hex(length):
+    @click_callback()
+    def inner(ctx, param, val):
+        val = bytes.fromhex(val)
+        if len(val) != length:
+            raise ValueError(f"Must be exactly {length} bytes.")
+        return val
+
+    return inner
+
+
+def parse_access_code_hex(access_code_hex):
+    try:
+        access_code = bytes.fromhex(access_code_hex)
+    except TypeError as e:
+        raise ValueError(e)
+    if len(access_code) != 6:
+        raise ValueError("Must be exactly 6 bytes.")
+
+    return access_code
+
+
+click_slot_argument = click.argument(
+    "slot", type=click.Choice(["1", "2"]), callback=lambda c, p, v: SLOT(int(v))
+)
+
+
+_WRITE_FAIL_MSG = (
+    "Failed to write to the YubiKey. Make sure the device does not "
+    'have restricted access (see "ykman otp --help" for more info).'
+)
+
+
+def _confirm_slot_overwrite(slot_state, slot):
+    if slot_state.is_configured(slot):
+        click.confirm(
+            f"Slot {slot} is already configured. Overwrite configuration?",
+            abort=True,
+            err=True,
+        )
+
+
+def _fname(fobj):
+    return getattr(fobj, "name", fobj)
+
+
+@click_group(connections=[OtpConnection, SmartCardConnection])
+@click.pass_context
+@click_postpone_execution
+@click.option(
+    "--access-code",
+    required=False,
+    metavar="HEX",
+    help='6 byte access code (use "-" as a value to prompt for input)',
+)
+def otp(ctx, access_code):
+    """
+    Manage the YubiOTP application.
+
+    The YubiKey provides two keyboard-based slots which can each be configured
+    with a credential. Several credential types are supported.
+
+    A slot configuration may be write-protected with an access code. This
+    prevents the configuration to be overwritten without the access code
+    provided. Mode switching the YubiKey is not possible when a slot is
+    configured with an access code. To provide an access code to commands
+    which require it, use the --access-code option. Note that this option must
+    be given directly after the "otp" command, before any sub-command.
+
+    Examples:
+
+    \b
+      Swap the configurations between the two slots:
+      $ ykman otp swap
+
+    \b
+      Program a random challenge-response credential to slot 2:
+      $ ykman otp chalresp --generate 2
+
+    \b
+      Program a Yubico OTP credential to slot 1, using the serial as public id:
+      $ ykman otp yubiotp 1 --serial-public-id
+
+    \b
+      Program a random 38 characters long static password to slot 2:
+      $ ykman otp static --generate 2 --length 38
+
+    \b
+      Remove a currently set access code from slot 2):
+      $ ykman otp --access-code 0123456789ab settings 2 --delete-access-code
+    """
+
+    """
+    # TODO: Require OTP for chalresp, or FW < 5.?. Require CCID for HashOTP
+    dev = ctx.obj["device"]
+    if dev.supports_connection(OtpConnection):
+        conn = dev.open_connection(OtpConnection)
+    else:
+        conn = dev.open_connection(SmartCardConnection)
+    ctx.call_on_close(conn.close)
+
+    ctx.obj["session"] = YubiOtpSession(conn)
+    """
+
+    if access_code is not None:
+        if access_code == "-":
+            access_code = click_prompt("Enter the access code", hide_input=True)
+
+        try:
+            access_code = parse_access_code_hex(access_code)
+        except Exception as e:
+            ctx.fail(f"Failed to parse access code: {e}")
+
+    ctx.obj["access_code"] = access_code
+
+
+def _get_session(ctx, types=[OtpConnection, SmartCardConnection]):
+    dev = ctx.obj["device"]
+    for conn_type in types:
+        if dev.supports_connection(conn_type):
+            conn = dev.open_connection(conn_type)
+            ctx.call_on_close(conn.close)
+            return YubiOtpSession(conn)
+    raise CliFail(
+        "The connection type required for this command is not supported/enabled on the "
+        "YubiKey"
+    )
+
+
+@otp.command()
+@click.pass_context
+def info(ctx):
+    """
+    Display general status of the YubiKey OTP slots.
+    """
+    session = _get_session(ctx)
+    state = session.get_config_state()
+    slot1 = state.is_configured(1)
+    slot2 = state.is_configured(2)
+
+    click.echo(f"Slot 1: {slot1 and 'programmed' or 'empty'}")
+    click.echo(f"Slot 2: {slot2 and 'programmed' or 'empty'}")
+
+    if is_yk4_fips(ctx.obj["info"]):
+        click.echo(f"FIPS Approved Mode: {'Yes' if is_in_fips_mode(session) else 'No'}")
+
+
+@otp.command()
+@click_force_option
+@click.pass_context
+def swap(ctx, force):
+    """
+    Swaps the two slot configurations.
+    """
+    session = _get_session(ctx)
+    force or click.confirm(
+        "Swap the two slots of the YubiKey?",
+        abort=True,
+        err=True,
+    )
+
+    click.echo("Swapping slots...")
+    try:
+        session.swap_slots()
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click.pass_context
+@click.option("-p", "--prefix", help="added before the NDEF payload, typically a URI")
+@click.option(
+    "-t",
+    "--ndef-type",
+    type=EnumChoice(NDEF_TYPE),
+    default="URI",
+    show_default=True,
+    help="NDEF payload type",
+)
+def ndef(ctx, slot, prefix, ndef_type):
+    """
+    Configure a slot to be used over NDEF (NFC).
+
+    \b
+    If "--prefix" is not specified, a default value will be used, based on the type:
+    - For URI the default value is: "https://my.yubico.com/yk/#"
+    - For TEXT the default is an empty string
+    """
+    info = ctx.obj["info"]
+    session = _get_session(ctx)
+    state = session.get_config_state()
+    if not info.has_transport(TRANSPORT.NFC):
+        raise CliFail("This YubiKey does not support NFC.")
+
+    if not state.is_configured(slot):
+        raise CliFail(f"Slot {slot} is empty.")
+
+    try:
+        session.set_ndef_configuration(slot, prefix, ctx.obj["access_code"], ndef_type)
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click_force_option
+@click.pass_context
+def delete(ctx, slot, force):
+    """
+    Deletes the configuration stored in a slot.
+    """
+    session = _get_session(ctx)
+    state = session.get_config_state()
+    if not force and not state.is_configured(slot):
+        raise CliFail("Not possible to delete an empty slot.")
+    force or click.confirm(
+        f"Do you really want to delete the configuration of slot {slot}?",
+        abort=True,
+        err=True,
+    )
+    click.echo(f"Deleting the configuration in slot {slot}...")
+    try:
+        session.delete_slot(slot, ctx.obj["access_code"])
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click.option(
+    "-P",
+    "--public-id",
+    required=False,
+    help="public identifier prefix",
+    metavar="MODHEX",
+)
+@click.option(
+    "-p",
+    "--private-id",
+    required=False,
+    metavar="HEX",
+    callback=parse_hex(6),
+    help="6 byte private identifier",
+)
+@click.option(
+    "-k",
+    "--key",
+    required=False,
+    metavar="HEX",
+    callback=parse_hex(16),
+    help="16 byte secret key",
+)
+@click.option(
+    "--no-enter",
+    is_flag=True,
+    help="don't send an Enter keystroke after emitting the OTP",
+)
+@click.option(
+    "-S",
+    "--serial-public-id",
+    is_flag=True,
+    required=False,
+    help="use YubiKey serial number as public ID (can't be used with --public-id)",
+)
+@click.option(
+    "-g",
+    "--generate-private-id",
+    is_flag=True,
+    required=False,
+    help="generate a random private ID (can't be used with --private-id)",
+)
+@click.option(
+    "-G",
+    "--generate-key",
+    is_flag=True,
+    required=False,
+    help="generate a random secret key (can't be used with --key)",
+)
+@click.option(
+    "-u",
+    "--upload",
+    is_flag=True,
+    required=False,
+    help="upload credential to YubiCloud (opens a browser, can't be used with --force)",
+)
+@click.option(
+    "-O",
+    "--config-output",
+    type=click.File("a"),
+    required=False,
+    help="file to output the configuration to (existing file will be appended to)",
+)
+@click_force_option
+@click.pass_context
+def yubiotp(
+    ctx,
+    slot,
+    public_id,
+    private_id,
+    key,
+    no_enter,
+    force,
+    serial_public_id,
+    generate_private_id,
+    generate_key,
+    upload,
+    config_output,
+):
+    """
+    Program a Yubico OTP credential.
+    """
+
+    info = ctx.obj["info"]
+    session = _get_session(ctx)
+    serial = None
+
+    if public_id and serial_public_id:
+        ctx.fail("Invalid options: --public-id conflicts with --serial-public-id.")
+
+    if private_id and generate_private_id:
+        ctx.fail("Invalid options: --private-id conflicts with --generate-public-id.")
+
+    if upload and force:
+        ctx.fail("Invalid options: --upload conflicts with --force.")
+
+    if key and generate_key:
+        ctx.fail("Invalid options: --key conflicts with --generate-key.")
+
+    if not public_id:
+        if serial_public_id:
+            try:
+                serial = session.get_serial()
+            except CommandError:
+                raise CliFail("Serial number not set, public ID must be provided")
+
+            public_id = modhex_encode(b"\xff\x00" + struct.pack(b">I", serial))
+            click.echo(f"Using YubiKey serial as public ID: {public_id}")
+        elif force:
+            ctx.fail(
+                "Public ID not given. Please remove the --force flag, or "
+                "add the --serial-public-id flag or --public-id option."
+            )
+        else:
+            public_id = click_prompt("Enter public ID")
+
+    if len(public_id) % 2:
+        ctx.fail("Invalid public ID, length must be a multiple of 2.")
+    try:
+        public_id = modhex_decode(public_id)
+    except ValueError:
+        ctx.fail(f"Invalid public ID, must be modhex ({MODHEX_ALPHABET}).")
+
+    if not private_id:
+        if generate_private_id:
+            private_id = os.urandom(6)
+            click.echo(f"Using a randomly generated private ID: {private_id.hex()}")
+        elif force:
+            ctx.fail(
+                "Private ID not given. Please remove the --force flag, or "
+                "add the --generate-private-id flag or --private-id option."
+            )
+        else:
+            private_id = click_prompt("Enter private ID")
+            private_id = bytes.fromhex(private_id)
+
+    if not key:
+        if generate_key:
+            key = os.urandom(16)
+            click.echo(f"Using a randomly generated secret key: {key.hex()}")
+        elif force:
+            ctx.fail(
+                "Secret key not given. Please remove the --force flag, or "
+                "add the --generate-key flag or --key option."
+            )
+        else:
+            key = click_prompt("Enter secret key")
+            key = bytes.fromhex(key)
+
+    if upload:
+        click.confirm("Upload credential to YubiCloud?", abort=True, err=True)
+
+        try:
+            upload_url = _prepare_upload_key(
+                key,
+                public_id,
+                private_id,
+                serial=info.serial,
+                user_agent="ykman/" + __version__,
+            )
+            click.echo("Upload to YubiCloud initiated successfully.")
+            logger.info("Initiated YubiCloud upload")
+        except _PrepareUploadFailed as e:
+            error_msg = "\n".join(e.messages())
+            raise CliFail("Upload to YubiCloud failed.\n" + error_msg)
+
+    force or click.confirm(
+        f"Program a YubiOTP credential in slot {slot}?", abort=True, err=True
+    )
+
+    access_code = ctx.obj["access_code"]
+    try:
+        session.put_configuration(
+            slot,
+            YubiOtpSlotConfiguration(public_id, private_id, key).append_cr(
+                not no_enter
+            ),
+            access_code,
+            access_code,
+        )
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+    if config_output:
+        serial = serial or session.get_serial()
+        csv = format_csv(serial, public_id, private_id, key, access_code)
+        config_output.write(csv + "\n")
+        logger.info(f"Configuration parameters written to {_fname(config_output)}")
+
+    if upload:
+        logger.info("Launching browser for YubiCloud upload")
+        click.echo("Opening upload form in browser: " + upload_url)
+        webbrowser.open_new_tab(upload_url)
+
+
+@otp.command()
+@click_slot_argument
+@click.argument("password", required=False)
+@click.option("-g", "--generate", is_flag=True, help="generate a random password")
+@click.option(
+    "-l",
+    "--length",
+    metavar="LENGTH",
+    type=click.IntRange(1, 38),
+    default=38,
+    show_default=True,
+    help="length of generated password",
+)
+@click.option(
+    "-k",
+    "--keyboard-layout",
+    type=EnumChoice(KEYBOARD_LAYOUT),
+    default="MODHEX",
+    show_default=True,
+    help="keyboard layout to use for the static password",
+)
+@click.option(
+    "--no-enter",
+    is_flag=True,
+    help="don't send an Enter keystroke after outputting the password",
+)
+@click_force_option
+@click.pass_context
+def static(ctx, slot, password, generate, length, keyboard_layout, no_enter, force):
+    """
+    Configure a static password.
+
+    To avoid problems with different keyboard layouts, the following characters
+    (upper and lower case) are allowed by default: cbdefghijklnrtuv
+
+    Use the --keyboard-layout option to allow more characters based on
+    preferred keyboard layout.
+    """
+
+    session = _get_session(ctx)
+
+    if password and len(password) > 38:
+        ctx.fail("Password too long (maximum length is 38 characters).")
+    if generate and not length:
+        ctx.fail("Provide a length for the generated password.")
+
+    if not password and not generate:
+        password = click_prompt("Enter a static password")
+    elif not password and generate:
+        password = generate_static_pw(length, keyboard_layout)
+
+    scan_codes = encode(password, keyboard_layout)
+
+    if not force:
+        _confirm_slot_overwrite(session.get_config_state(), slot)
+    try:
+        session.put_configuration(
+            slot,
+            StaticPasswordSlotConfiguration(scan_codes).append_cr(not no_enter),
+            ctx.obj["access_code"],
+            ctx.obj["access_code"],
+        )
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click.argument("key", required=False)
+@click.option(
+    "-t",
+    "--touch",
+    is_flag=True,
+    help="require touch on the YubiKey to generate a response",
+)
+@click.option(
+    "-T",
+    "--totp",
+    is_flag=True,
+    required=False,
+    help="use a base32 encoded key (optionally padded) for TOTP credentials",
+)
+@click.option(
+    "-g",
+    "--generate",
+    is_flag=True,
+    required=False,
+    help="generate a random secret key (can't be used with KEY argument)",
+)
+@click_force_option
+@click.pass_context
+def chalresp(ctx, slot, key, totp, touch, force, generate):
+    """
+    Program a challenge-response credential.
+
+    If KEY is not given, an interactive prompt will ask for it.
+
+    \b
+    KEY     a key given in hex (or base32, if --totp is specified)
+    """
+    session = _get_session(ctx)
+
+    if key:
+        if generate:
+            ctx.fail("Invalid options: --generate conflicts with KEY argument.")
+        elif totp:
+            key = parse_b32_key(key)
+        else:
+            key = parse_oath_key(key)
+    else:
+        if force and not generate:
+            ctx.fail(
+                "No secret key given. Please remove the --force flag, "
+                "set the KEY argument or set the --generate flag."
+            )
+        elif generate:
+            key = os.urandom(20)
+            if totp:
+                b32key = b32encode(key).decode()
+                click.echo(f"Using a randomly generated key (base32): {b32key}")
+            else:
+                click.echo(f"Using a randomly generated key (hex): {key.hex()}")
+        elif totp:
+            while True:
+                key = click_prompt("Enter a secret key (base32)")
+                try:
+                    key = parse_b32_key(key)
+                    break
+                except Exception as e:
+                    click.echo(e)
+        else:
+            key = click_prompt("Enter a secret key")
+            key = parse_oath_key(key)
+
+    cred_type = "TOTP" if totp else "challenge-response"
+    force or click.confirm(
+        f"Program a {cred_type} credential in slot {slot}?",
+        abort=True,
+        err=True,
+    )
+    try:
+        session.put_configuration(
+            slot,
+            HmacSha1SlotConfiguration(key).require_touch(touch),
+            ctx.obj["access_code"],
+            ctx.obj["access_code"],
+        )
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click.argument("challenge", required=False)
+@click.option(
+    "-T",
+    "--totp",
+    is_flag=True,
+    help="generate a TOTP code, use the current time if challenge is omitted",
+)
+@click.option(
+    "-d",
+    "--digits",
+    type=click.Choice(["6", "8"]),
+    default="6",
+    help="number of digits in generated TOTP code (default: 6), "
+    "ignored unless --totp is set",
+)
+@click.pass_context
+def calculate(ctx, slot, challenge, totp, digits):
+    """
+    Perform a challenge-response operation.
+
+    Send a challenge (in hex) to a YubiKey slot with a challenge-response
+    credential, and read the response. Supports output as a OATH-TOTP code.
+    """
+    dev = ctx.obj["device"]
+    if dev.transport == TRANSPORT.NFC:
+        session = _get_session(ctx, [SmartCardConnection])
+    else:
+        # Calculate over USB is only available over OtpConnection
+        session = _get_session(ctx, [OtpConnection])
+
+    if not challenge and not totp:
+        challenge = click_prompt("Enter a challenge (hex)")
+
+    # Check that slot is not empty
+    if not session.get_config_state().is_configured(slot):
+        raise CliFail("Cannot perform challenge-response on an empty slot.")
+
+    if totp:  # Challenge omitted or timestamp
+        if challenge is None:
+            challenge = time_challenge(int(time()))
+        else:
+            try:
+                challenge = time_challenge(int(challenge))
+            except Exception:
+                logger.exception("Error parsing challenge")
+                ctx.fail("Timestamp challenge for TOTP must be an integer.")
+    else:  # Challenge is hex
+        challenge = bytes.fromhex(challenge)
+
+    try:
+        event = Event()
+
+        def on_keepalive(status):
+            if not hasattr(on_keepalive, "prompted") and status == 2:
+                prompt_for_touch()
+                setattr(on_keepalive, "prompted", True)
+
+        response = session.calculate_hmac_sha1(slot, challenge, event, on_keepalive)
+        if totp:
+            value = format_oath_code(response, int(digits))
+        else:
+            value = response.hex()
+
+        click.echo(value)
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+def parse_modhex_or_bcd(value):
+    try:
+        return True, modhex_decode(value)
+    except ValueError:
+        try:
+            int(value)
+            return False, bytes.fromhex(value)
+        except ValueError:
+            raise ValueError("value must be modhex or decimal")
+
+
+@otp.command()
+@click_slot_argument
+@click.argument("key", callback=click_parse_b32_key, required=False)
+@click.option(
+    "-d",
+    "--digits",
+    type=click.Choice(["6", "8"]),
+    default="6",
+    help="number of digits in generated code (default is 6)",
+)
+@click.option("-c", "--counter", type=int, default=0, help="initial counter value")
+@click.option("-i", "--identifier", help="token identifier")
+@click.option(
+    "--no-enter",
+    is_flag=True,
+    help="don't send an Enter keystroke after outputting the code",
+)
+@click_force_option
+@click.pass_context
+def hotp(ctx, slot, key, digits, counter, identifier, no_enter, force):
+    """
+    Program an HMAC-SHA1 OATH-HOTP credential.
+
+    The YubiKey can be configured to output an OATH Token Identifier as a prefix
+    to the OTP itself, which consists of OMP+TT+MUI. Using the "--identifier" option,
+    you may specify the OMP+TT as 4 characters, the MUI as 8 characters, or the full
+    OMP+TT+MUI as 12 characters. If omitted, a default value of "ubhe" will be used for
+    OMP+TT, and the YubiKey serial number will be used as MUI.
+    """
+    session = _get_session(ctx)
+
+    mh1 = False
+    mh2 = False
+    if identifier:
+        if identifier == "-":
+            identifier = "ubhe"
+        if len(identifier) == 4:
+            identifier += f"{session.get_serial():08}"
+        elif len(identifier) == 8:
+            identifier = "ubhe" + identifier
+        if len(identifier) != 12:
+            raise ValueError("Incorrect length for token identifier.")
+
+        omp_m, omp = parse_modhex_or_bcd(identifier[:2])
+        tt_m, tt = parse_modhex_or_bcd(identifier[2:4])
+        mui_m, mui = parse_modhex_or_bcd(identifier[4:])
+        if tt_m and not omp_m:
+            raise ValueError("TT can only be modhex encoded if OMP is as well.")
+        if mui_m and not (omp_m and tt_m):
+            raise ValueError(
+                "MUI can only be modhex encoded if OMP and TT are as well."
+            )
+        token_id = omp + tt + mui
+        if mui_m:
+            mh1 = mh2 = True
+        elif tt_m:
+            mh2 = True
+        elif omp_m:
+            mh1 = True
+    else:
+        token_id = b""
+
+    if not key:
+        while True:
+            key = click_prompt("Enter a secret key (base32)")
+            try:
+                key = parse_b32_key(key)
+                break
+            except Exception as e:
+                click.echo(e)
+
+    force or click.confirm(
+        f"Program a HOTP credential in slot {slot}?", abort=True, err=True
+    )
+    try:
+        session.put_configuration(
+            slot,
+            HotpSlotConfiguration(key)
+            .imf(counter)
+            .token_id(token_id, mh1, mh2)
+            .digits8(int(digits) == 8)
+            .append_cr(not no_enter),
+            ctx.obj["access_code"],
+            ctx.obj["access_code"],
+        )
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
+
+
+@otp.command()
+@click_slot_argument
+@click_force_option
+@click.pass_context
+@click.option(
+    "-A",
+    "--new-access-code",
+    metavar="HEX",
+    required=False,
+    help='a new 6 byte access code to set (use "-" as a value to prompt for input)',
+)
+@click.option(
+    "--delete-access-code", is_flag=True, help="remove access code from the slot"
+)
+@click.option(
+    "--enter/--no-enter",
+    default=True,
+    show_default=True,
+    help="send an Enter keystroke after slot output",
+)
+@click.option(
+    "-p",
+    "--pacing",
+    type=click.Choice(["0", "20", "40", "60"]),
+    default="0",
+    show_default=True,
+    help="throttle output speed by adding a delay (in ms) between characters emitted",
+)
+@click.option(
+    "--use-numeric-keypad",
+    is_flag=True,
+    show_default=True,
+    help="use scancodes for numeric keypad when sending digits "
+    "(helps for some keyboard layouts)",
+)
+def settings(
+    ctx,
+    slot,
+    new_access_code,
+    delete_access_code,
+    enter,
+    pacing,
+    use_numeric_keypad,
+    force,
+):
+    """
+    Update the settings for a slot.
+
+    Change the settings for a slot without changing the stored secret.
+    All settings not specified will be written with default values.
+    """
+    session = _get_session(ctx)
+
+    if new_access_code and delete_access_code:
+        ctx.fail("--new-access-code conflicts with --delete-access-code.")
+
+    if delete_access_code and not ctx.obj["access_code"]:
+        raise CliFail(
+            "--delete-access-code used without providing an access code "
+            '(see "ykman otp --help" for more info).'
+        )
+
+    if not session.get_config_state().is_configured(slot):
+        raise CliFail("Not possible to update settings on an empty slot.")
+
+    if new_access_code is None:
+        if not delete_access_code:
+            new_access_code = ctx.obj["access_code"]
+    else:
+        if new_access_code == "-":
+            new_access_code = click_prompt(
+                "Enter new access code", hide_input=True, confirmation_prompt=True
+            )
+
+        try:
+            new_access_code = parse_access_code_hex(new_access_code)
+        except Exception as e:
+            ctx.fail("Failed to parse access code: " + str(e))
+
+    force or click.confirm(
+        f"Update the settings for slot {slot}? "
+        "All existing settings will be overwritten.",
+        abort=True,
+        err=True,
+    )
+    click.echo(f"Updating settings for slot {slot}...")
+
+    pacing_bits = int(pacing or "0") // 20
+    pacing_10ms = bool(pacing_bits & 1)
+    pacing_20ms = bool(pacing_bits & 2)
+
+    try:
+        session.update_configuration(
+            slot,
+            UpdateConfiguration()
+            .append_cr(enter)
+            .use_numeric(use_numeric_keypad)
+            .pacing(pacing_10ms, pacing_20ms),
+            new_access_code,
+            ctx.obj["access_code"],
+        )
+    except CommandError:
+        raise CliFail(_WRITE_FAIL_MSG)
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/piv.py` & `yubikey_manager-5.1.1/ykman/_cli/piv.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,1259 +1,1259 @@
-# Copyright (c) 2017 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import NotSupportedError
-from yubikit.core.smartcard import SmartCardConnection
-from yubikit.piv import (
-    PivSession,
-    InvalidPinError,
-    KEY_TYPE,
-    MANAGEMENT_KEY_TYPE,
-    OBJECT_ID,
-    SLOT,
-    PIN_POLICY,
-    TOUCH_POLICY,
-    DEFAULT_MANAGEMENT_KEY,
-)
-from yubikit.core.smartcard import ApduError, SW
-
-from ..util import (
-    get_leaf_certificates,
-    parse_private_key,
-    parse_certificates,
-    InvalidPasswordError,
-)
-from ..piv import (
-    get_piv_info,
-    get_pivman_data,
-    get_pivman_protected_data,
-    pivman_set_mgm_key,
-    pivman_change_pin,
-    derive_management_key,
-    generate_random_management_key,
-    generate_chuid,
-    generate_ccc,
-    check_key,
-    generate_self_signed_certificate,
-    generate_csr,
-)
-from .util import (
-    CliFail,
-    click_group,
-    click_force_option,
-    click_format_option,
-    click_postpone_execution,
-    click_callback,
-    click_prompt,
-    prompt_timeout,
-    EnumChoice,
-    pretty_print,
-)
-from cryptography.hazmat.primitives import serialization, hashes
-from cryptography.hazmat.backends import default_backend
-
-import click
-import datetime
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-@click_callback()
-def click_parse_piv_slot(ctx, param, val):
-    try:
-        return SLOT[val.upper().replace("-", "_")]
-    except KeyError:
-        try:
-            return SLOT(int(val, 16))
-        except Exception:
-            raise ValueError(val)
-
-
-@click_callback()
-def click_parse_piv_object(ctx, param, val):
-    if val.upper() == "CCC":
-        return OBJECT_ID.CAPABILITY
-    try:
-        return OBJECT_ID[val.upper().replace("-", "_")]
-    except KeyError:
-        try:
-            return int(val, 16)
-        except Exception:
-            raise ValueError(val)
-
-
-@click_callback()
-def click_parse_management_key(ctx, param, val):
-    try:
-        key = bytes.fromhex(val)
-        if key and len(key) not in (16, 24, 32):
-            raise ValueError(
-                "Management key must be exactly 16, 24, or 32 bytes "
-                "(32, 48, or 64 hexadecimal digits) long."
-            )
-        return key
-    except Exception:
-        raise ValueError(val)
-
-
-@click_callback()
-def click_parse_hash(ctx, param, val):
-    try:
-        return getattr(hashes, val)
-    except AttributeError:
-        raise ValueError(val)
-
-
-click_slot_argument = click.argument("slot", callback=click_parse_piv_slot)
-click_object_argument = click.argument(
-    "object_id", callback=click_parse_piv_object, metavar="OBJECT"
-)
-click_management_key_option = click.option(
-    "-m",
-    "--management-key",
-    help="the management key",
-    callback=click_parse_management_key,
-)
-click_pin_option = click.option("-P", "--pin", help="PIN code")
-click_pin_policy_option = click.option(
-    "--pin-policy",
-    type=EnumChoice(PIN_POLICY),
-    default=PIN_POLICY.DEFAULT.name,
-    help="PIN policy for slot",
-)
-click_touch_policy_option = click.option(
-    "--touch-policy",
-    type=EnumChoice(TOUCH_POLICY),
-    default=TOUCH_POLICY.DEFAULT.name,
-    help="touch policy for slot",
-)
-click_hash_option = click.option(
-    "-a",
-    "--hash-algorithm",
-    type=click.Choice(["SHA256", "SHA384", "SHA512"], case_sensitive=False),
-    default="SHA256",
-    show_default=True,
-    help="hash algorithm",
-    callback=click_parse_hash,
-)
-
-
-def _fname(fobj):
-    return getattr(fobj, "name", fobj)
-
-
-@click_group(connections=[SmartCardConnection])
-@click.pass_context
-@click_postpone_execution
-def piv(ctx):
-    """
-    Manage the PIV application.
-
-    Examples:
-
-    \b
-      Generate an ECC P-256 private key and a self-signed certificate in
-      slot 9a:
-      $ ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
-      $ ykman piv certificates generate --subject "CN=yubico" 9a pubkey.pem
-
-    \b
-      Change the PIN from 123456 to 654321:
-      $ ykman piv access change-pin --pin 123456 --new-pin 654321
-
-    \b
-      Reset all PIV data and restore default settings:
-      $ ykman piv reset
-    """
-
-    dev = ctx.obj["device"]
-    conn = dev.open_connection(SmartCardConnection)
-    ctx.call_on_close(conn.close)
-    session = PivSession(conn)
-    ctx.obj["session"] = session
-    ctx.obj["pivman_data"] = get_pivman_data(session)
-
-
-@piv.command()
-@click.pass_context
-def info(ctx):
-    """
-    Display general status of the PIV application.
-    """
-    info = get_piv_info(ctx.obj["session"])
-    click.echo("\n".join(pretty_print(info)))
-
-
-@piv.command()
-@click.pass_context
-@click_force_option
-def reset(ctx, force):
-    """
-    Reset all PIV data.
-
-    This action will wipe all data and restore factory settings for
-    the PIV application on the YubiKey.
-    """
-    force or click.confirm(
-        "WARNING! This will delete all stored PIV data and restore factory "
-        "settings. Proceed?",
-        abort=True,
-        err=True,
-    )
-
-    click.echo("Resetting PIV data...")
-    ctx.obj["session"].reset()
-
-    click.echo("Success! All PIV data have been cleared from the YubiKey.")
-    click.echo("Your YubiKey now has the default PIN, PUK and Management Key:")
-    click.echo("\tPIN:\t123456")
-    click.echo("\tPUK:\t12345678")
-    click.echo("\tManagement Key:\t010203040506070801020304050607080102030405060708")
-
-
-@piv.group()
-def access():
-    """Manage PIN, PUK, and Management Key."""
-
-
-@access.command("set-retries")
-@click.pass_context
-@click.argument("pin-retries", type=click.IntRange(1, 255), metavar="PIN-RETRIES")
-@click.argument("puk-retries", type=click.IntRange(0, 255), metavar="PUK-RETRIES")
-@click_management_key_option
-@click_pin_option
-@click_force_option
-def set_pin_retries(ctx, management_key, pin, pin_retries, puk_retries, force):
-    """
-    Set the number of PIN and PUK retry attempts.
-
-    NOTE: This will reset the PIN and PUK to their factory defaults.
-    """
-    session = ctx.obj["session"]
-    _ensure_authenticated(
-        ctx, pin, management_key, require_pin_and_key=True, no_prompt=force
-    )
-    click.echo("WARNING: This will reset the PIN and PUK to the factory defaults!")
-    force or click.confirm(
-        f"Set the number of PIN and PUK retry attempts to: {pin_retries} "
-        f"{puk_retries}?",
-        abort=True,
-        err=True,
-    )
-    try:
-        session.set_pin_attempts(pin_retries, puk_retries)
-        click.echo("Default PINs are set:")
-        click.echo("\tPIN:\t123456")
-        click.echo("\tPUK:\t12345678")
-    except Exception:
-        raise CliFail("Setting pin retries failed.")
-
-
-@access.command("change-pin")
-@click.pass_context
-@click.option("-P", "--pin", help="current PIN code")
-@click.option("-n", "--new-pin", help="a new PIN to set")
-def change_pin(ctx, pin, new_pin):
-    """
-    Change the PIN code.
-
-    The PIN must be between 6 and 8 characters long, and supports any type of
-    alphanumeric characters. For cross-platform compatibility, numeric PINs are
-    recommended.
-    """
-
-    session = ctx.obj["session"]
-
-    if not pin:
-        pin = _prompt_pin("Enter the current PIN")
-    if not new_pin:
-        new_pin = click_prompt(
-            "Enter the new PIN",
-            default="",
-            hide_input=True,
-            show_default=False,
-            confirmation_prompt=True,
-        )
-
-    if not _valid_pin_length(pin):
-        ctx.fail("Current PIN must be between 6 and 8 characters long.")
-
-    if not _valid_pin_length(new_pin):
-        ctx.fail("New PIN must be between 6 and 8 characters long.")
-
-    try:
-        pivman_change_pin(session, pin, new_pin)
-        click.echo("New PIN set.")
-    except InvalidPinError as e:
-        attempts = e.attempts_remaining
-        if attempts:
-            raise CliFail("PIN change failed - %d tries left." % attempts)
-        else:
-            raise CliFail("PIN is blocked.")
-
-
-@access.command("change-puk")
-@click.pass_context
-@click.option("-p", "--puk", help="current PUK code")
-@click.option("-n", "--new-puk", help="a new PUK code to set")
-def change_puk(ctx, puk, new_puk):
-    """
-    Change the PUK code.
-
-    If the PIN is lost or blocked it can be reset using a PUK.
-    The PUK must be between 6 and 8 characters long, and supports any type of
-    alphanumeric characters.
-    """
-    session = ctx.obj["session"]
-    if not puk:
-        puk = _prompt_pin("Enter the current PUK")
-    if not new_puk:
-        new_puk = click_prompt(
-            "Enter the new PUK",
-            default="",
-            hide_input=True,
-            show_default=False,
-            confirmation_prompt=True,
-        )
-
-    if not _valid_pin_length(puk):
-        ctx.fail("Current PUK must be between 6 and 8 characters long.")
-
-    if not _valid_pin_length(new_puk):
-        ctx.fail("New PUK must be between 6 and 8 characters long.")
-
-    try:
-        session.change_puk(puk, new_puk)
-        click.echo("New PUK set.")
-    except InvalidPinError as e:
-        attempts = e.attempts_remaining
-        if attempts:
-            raise CliFail("PUK change failed - %d tries left." % attempts)
-        else:
-            raise CliFail("PUK is blocked.")
-
-
-@access.command("change-management-key")
-@click.pass_context
-@click_pin_option
-@click.option(
-    "-t",
-    "--touch",
-    is_flag=True,
-    help="require touch on YubiKey when prompted for management key",
-)
-@click.option(
-    "-n",
-    "--new-management-key",
-    help="a new management key to set",
-    callback=click_parse_management_key,
-)
-@click.option(
-    "-m",
-    "--management-key",
-    help="current management key",
-    callback=click_parse_management_key,
-)
-@click.option(
-    "-a",
-    "--algorithm",
-    help="management key algorithm",
-    type=EnumChoice(MANAGEMENT_KEY_TYPE),
-    default=MANAGEMENT_KEY_TYPE.TDES.name,
-    show_default=True,
-)
-@click.option(
-    "-p",
-    "--protect",
-    is_flag=True,
-    help="store new management key on the YubiKey, protected by PIN "
-    "(a random key will be used if no key is provided)",
-)
-@click.option(
-    "-g",
-    "--generate",
-    is_flag=True,
-    help="generate a random management key "
-    "(implied by --protect unless --new-management-key is also given, "
-    "can't be used with --new-management-key)",
-)
-@click_force_option
-def change_management_key(
-    ctx,
-    management_key,
-    algorithm,
-    pin,
-    new_management_key,
-    touch,
-    protect,
-    generate,
-    force,
-):
-    """
-    Change the management key.
-
-    Management functionality is guarded by a management key.
-    This key is required for administrative tasks, such as generating key pairs.
-    A random key may be generated and stored on the YubiKey, protected by PIN.
-    """
-    session = ctx.obj["session"]
-    pivman = ctx.obj["pivman_data"]
-
-    pin_verified = _ensure_authenticated(
-        ctx,
-        pin,
-        management_key,
-        require_pin_and_key=protect,
-        mgm_key_prompt="Enter the current management key [blank to use default key]",
-        no_prompt=force,
-    )
-
-    # Can't combine new key with generate.
-    if new_management_key and generate:
-        ctx.fail("Invalid options: --new-management-key conflicts with --generate")
-
-    # Touch not supported on NEO.
-    if touch and session.version < (4, 0, 0):
-        raise CliFail("Require touch not supported on this YubiKey.")
-
-    # If an old stored key needs to be cleared, the PIN is needed.
-    if not pin_verified and pivman.has_stored_key:
-        if pin:
-            _verify_pin(ctx, session, pivman, pin, no_prompt=force)
-        elif not force:
-            click.confirm(
-                "The current management key is stored on the YubiKey"
-                " and will not be cleared if no PIN is provided. Continue?",
-                abort=True,
-                err=True,
-            )
-
-    if not new_management_key:
-        if protect or generate:
-            new_management_key = generate_random_management_key(algorithm)
-            if not protect:
-                click.echo(f"Generated management key: {new_management_key.hex()}")
-        elif force:
-            ctx.fail(
-                "New management key not given. Please remove the --force "
-                "flag, or set the --generate flag or the "
-                "--new-management-key option."
-            )
-        else:
-            try:
-                new_management_key = bytes.fromhex(
-                    click_prompt(
-                        "Enter the new management key",
-                        hide_input=True,
-                        confirmation_prompt=True,
-                    )
-                )
-            except Exception:
-                ctx.fail("New management key has the wrong format.")
-
-    if len(new_management_key) != algorithm.key_len:
-        raise CliFail(
-            "Management key has the wrong length (expected %d bytes)"
-            % algorithm.key_len
-        )
-
-    try:
-        pivman_set_mgm_key(
-            session, new_management_key, algorithm, touch=touch, store_on_device=protect
-        )
-    except ApduError:
-        raise CliFail("Changing the management key failed.")
-
-
-@access.command("unblock-pin")
-@click.pass_context
-@click.option("-p", "--puk", required=False)
-@click.option("-n", "--new-pin", required=False, metavar="NEW-PIN")
-def unblock_pin(ctx, puk, new_pin):
-    """
-    Unblock the PIN (using PUK).
-    """
-    session = ctx.obj["session"]
-    if not puk:
-        puk = click_prompt("Enter PUK", default="", show_default=False, hide_input=True)
-    if not new_pin:
-        new_pin = click_prompt(
-            "Enter a new PIN", default="", show_default=False, hide_input=True
-        )
-    try:
-        session.unblock_pin(puk, new_pin)
-        click.echo("PIN unblocked")
-    except InvalidPinError as e:
-        attempts = e.attempts_remaining
-        if attempts:
-            raise CliFail("PIN unblock failed - %d tries left." % attempts)
-        else:
-            raise CliFail("PUK is blocked.")
-
-
-@piv.group()
-def keys():
-    """
-    Manage private keys.
-    """
-
-
-@keys.command("generate")
-@click.pass_context
-@click_management_key_option
-@click_pin_option
-@click.option(
-    "-a",
-    "--algorithm",
-    help="algorithm to use in key generation",
-    type=EnumChoice(KEY_TYPE),
-    default=KEY_TYPE.RSA2048.name,
-    show_default=True,
-)
-@click_format_option
-@click_pin_policy_option
-@click_touch_policy_option
-@click_slot_argument
-@click.argument("public-key-output", type=click.File("wb"), metavar="PUBLIC-KEY")
-def generate_key(
-    ctx,
-    slot,
-    public_key_output,
-    management_key,
-    pin,
-    algorithm,
-    format,
-    pin_policy,
-    touch_policy,
-):
-    """
-    Generate an asymmetric key pair.
-
-    The private key is generated on the YubiKey, and written to one of the slots.
-
-    \b
-    SLOT        PIV slot of the private key
-    PUBLIC-KEY  file containing the generated public key (use '-' to use stdout)
-    """
-
-    session = ctx.obj["session"]
-    _ensure_authenticated(ctx, pin, management_key)
-
-    public_key = session.generate_key(slot, algorithm, pin_policy, touch_policy)
-
-    key_encoding = format
-    public_key_output.write(
-        public_key.public_bytes(
-            encoding=key_encoding,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        )
-    )
-    logger.info(
-        f"Private key generated in slot {slot}, public key written to "
-        f"{_fname(public_key_output)}"
-    )
-
-
-@keys.command("import")
-@click.pass_context
-@click_pin_option
-@click_management_key_option
-@click_pin_policy_option
-@click_touch_policy_option
-@click_slot_argument
-@click.argument("private-key", type=click.File("rb"), metavar="PRIVATE-KEY")
-@click.option("-p", "--password", help="password used to decrypt the private key")
-def import_key(
-    ctx, management_key, pin, slot, private_key, pin_policy, touch_policy, password
-):
-    """
-    Import a private key from file.
-
-    Write a private key to one of the PIV slots on the YubiKey.
-
-    \b
-    SLOT         PIV slot of the private key
-    PRIVATE-KEY  file containing the private key (use '-' to use stdin)
-    """
-    session = ctx.obj["session"]
-
-    data = private_key.read()
-
-    while True:
-        if password is not None:
-            password = password.encode()
-        try:
-            private_key = parse_private_key(data, password)
-        except InvalidPasswordError:
-            logger.debug("Error parsing key", exc_info=True)
-            if password is None:
-                password = click_prompt(
-                    "Enter password to decrypt key",
-                    default="",
-                    hide_input=True,
-                    show_default=False,
-                )
-                continue
-            else:
-                password = None
-                click.echo("Wrong password.")
-            continue
-        break
-
-    _ensure_authenticated(ctx, pin, management_key)
-    session.put_key(slot, private_key, pin_policy, touch_policy)
-
-
-@keys.command()
-@click.pass_context
-@click_format_option
-@click_slot_argument
-@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
-def attest(ctx, slot, certificate, format):
-    """
-    Generate an attestation certificate for a key pair.
-
-    Attestation is used to show that an asymmetric key was generated on the
-    YubiKey and therefore doesn't exist outside the device.
-
-    \b
-    SLOT         PIV slot of the private key
-    CERTIFICATE  file to write attestation certificate to (use '-' to use stdout)
-    """
-    session = ctx.obj["session"]
-    try:
-        cert = session.attest_key(slot)
-    except ApduError:
-        raise CliFail("Attestation failed.")
-    certificate.write(cert.public_bytes(encoding=format))
-    logger.info(
-        f"Attestation certificate for slot {slot} written to {_fname(certificate)}"
-    )
-
-
-@keys.command("info")
-@click.pass_context
-@click_slot_argument
-def metadata(ctx, slot):
-    """
-    Show metadata about a private key.
-
-    This will show what type of key is stored in a specific slot,
-    whether it was imported into the YubiKey, or generated on-chip,
-    and what the PIN and Touch policies are for using the key.
-
-    \b
-    SLOT        PIV slot of the private key
-    """
-
-    session = ctx.obj["session"]
-    try:
-        metadata = session.get_slot_metadata(slot)
-        info = {
-            "Key slot": slot,
-            "Algorithm": metadata.key_type.name,
-            "Origin": "GENERATED" if metadata.generated else "IMPORTED",
-            "PIN required for use": metadata.pin_policy.name,
-            "Touch required for use": metadata.touch_policy.name,
-        }
-        click.echo("\n".join(pretty_print(info)))
-    except ApduError as e:
-        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
-            raise CliFail(f"No key stored in slot {slot}.")
-        raise e
-
-
-@keys.command()
-@click.pass_context
-@click_format_option
-@click_slot_argument
-@click.option(
-    "-v",
-    "--verify",
-    is_flag=True,
-    help="verify that the public key matches the private key in the slot",
-)
-@click.option("-P", "--pin", help="PIN code (used for --verify)")
-@click.argument("public-key-output", type=click.File("wb"), metavar="PUBLIC-KEY")
-def export(ctx, slot, public_key_output, format, verify, pin):
-    """
-    Export a public key corresponding to a stored private key.
-
-    This command uses several different mechanisms for exporting the public key
-    corresponding to a stored private key, which may fail.
-    If a certificate is stored in the slot it is assumed to contain the correct public
-    key. If this is not the case, the wrong public key will be returned.
-
-    The --verify flag can be used to verify that the public key being returned matches
-    the private key, by using the slot to create and verify a signature. This may
-    require the PIN to be provided.
-
-    \b
-    SLOT        PIV slot of the private key
-    PUBLIC-KEY  file to write the public key to (use '-' to use stdout)
-    """
-    session = ctx.obj["session"]
-    try:  # Prefer metadata if available
-        public_key = session.get_slot_metadata(slot).public_key
-        logger.debug("Public key read from YubiKey")
-    except ApduError as e:
-        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
-            raise CliFail(f"No key stored in slot {slot}.")
-        raise CliFail(f"Unable to export public key from slot {slot}.")
-    except NotSupportedError:
-        try:  # Try attestation
-            public_key = session.attest_key(slot).public_key()
-            logger.debug("Public key read using attestation")
-        except (NotSupportedError, ApduError):
-            try:  # Read from stored certificate
-                public_key = session.get_certificate(slot).public_key()
-                logger.debug("Public key read from stored certificate")
-                if verify:  # Only needed when read from certificate
-
-                    def do_verify():
-                        with prompt_timeout(timeout=1.0):
-                            if not check_key(session, slot, public_key):
-                                raise CliFail(
-                                    "This public key is not tied to the private key in "
-                                    f"slot {slot}."
-                                )
-
-                    _verify_pin_if_needed(ctx, session, do_verify, pin)
-            except ApduError:
-                raise CliFail(f"Unable to export public key from slot {slot}.")
-
-    key_encoding = format
-    public_key_output.write(
-        public_key.public_bytes(
-            encoding=key_encoding,
-            format=serialization.PublicFormat.SubjectPublicKeyInfo,
-        )
-    )
-    logger.info(f"Public key for slot {slot} written to {_fname(public_key_output)}")
-
-
-@piv.group("certificates")
-def cert():
-    """
-    Manage certificates.
-    """
-
-
-@cert.command("import")
-@click.pass_context
-@click_management_key_option
-@click_pin_option
-@click.option("-p", "--password", help="a password may be needed to decrypt the data")
-@click.option(
-    "-v",
-    "--verify",
-    is_flag=True,
-    help="verify that the certificate matches the private key in the slot",
-)
-@click_slot_argument
-@click.argument("cert", type=click.File("rb"), metavar="CERTIFICATE")
-def import_certificate(ctx, management_key, pin, slot, cert, password, verify):
-    """
-    Import an X.509 certificate.
-
-    Write a certificate to one of the PIV slots on the YubiKey.
-
-    \b
-    SLOT            PIV slot of the certificate
-    CERTIFICATE     file containing the certificate (use '-' to use stdin)
-    """
-    session = ctx.obj["session"]
-
-    data = cert.read()
-
-    while True:
-        if password is not None:
-            password = password.encode()
-        try:
-            certs = parse_certificates(data, password)
-        except InvalidPasswordError:
-            logger.debug("Error parsing certificate", exc_info=True)
-            if password is None:
-                password = click_prompt(
-                    "Enter password to decrypt certificate",
-                    default="",
-                    hide_input=True,
-                    show_default=False,
-                )
-                continue
-            else:
-                password = None
-                click.echo("Wrong password.")
-            continue
-        break
-
-    if len(certs) > 1:
-        #  If multiple certs, only import leaf.
-        #  Leaf is the cert with a subject that is not an issuer in the chain.
-        leafs = get_leaf_certificates(certs)
-        cert_to_import = leafs[0]
-    else:
-        cert_to_import = certs[0]
-
-    _ensure_authenticated(ctx, pin, management_key)
-
-    if verify:
-        public_key = cert_to_import.public_key()
-
-        try:
-            metadata = session.get_slot_metadata(slot)
-            if metadata.pin_policy in (PIN_POLICY.ALWAYS, PIN_POLICY.ONCE):
-                pivman = ctx.obj["pivman_data"]
-                _verify_pin(ctx, session, pivman, pin)
-
-            if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
-                timeout = 0.0
-            else:
-                timeout = None
-        except ApduError as e:
-            if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
-                raise CliFail("No private key in slot {slot}")
-            raise e
-        except NotSupportedError:
-            timeout = 1.0
-
-        def do_verify():
-            with prompt_timeout(timeout=timeout):
-                if not check_key(session, slot, public_key):
-                    raise CliFail(
-                        "The public key of the certificate does not match the "
-                        f"private key in slot {slot}"
-                    )
-
-        _verify_pin_if_needed(ctx, session, do_verify, pin)
-
-    session.put_certificate(slot, cert_to_import)
-    session.put_object(OBJECT_ID.CHUID, generate_chuid())
-
-
-@cert.command("export")
-@click.pass_context
-@click_format_option
-@click_slot_argument
-@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
-def export_certificate(ctx, format, slot, certificate):
-    """
-    Export an X.509 certificate.
-
-    Reads a certificate from one of the PIV slots on the YubiKey.
-
-    \b
-    SLOT            PIV slot of the certificate
-    CERTIFICATE     file to write certificate to (use '-' to use stdout)
-    """
-    session = ctx.obj["session"]
-    try:
-        cert = session.get_certificate(slot)
-        certificate.write(cert.public_bytes(encoding=format))
-        logger.info(f"Certificate from slot {slot} exported to {_fname(certificate)}")
-    except ApduError as e:
-        if e.sw == SW.FILE_NOT_FOUND:
-            raise CliFail("No certificate found.")
-        else:
-            raise CliFail("Failed reading certificate.")
-
-
-@cert.command("generate")
-@click.pass_context
-@click_management_key_option
-@click_pin_option
-@click_slot_argument
-@click.argument("public-key", type=click.File("rb"), metavar="PUBLIC-KEY")
-@click.option(
-    "-s",
-    "--subject",
-    help="subject for the certificate, as an RFC 4514 string",
-    required=True,
-)
-@click.option(
-    "-d",
-    "--valid-days",
-    help="number of days until the certificate expires",
-    type=click.INT,
-    default=365,
-    show_default=True,
-)
-@click_hash_option
-def generate_certificate(
-    ctx, management_key, pin, slot, public_key, subject, valid_days, hash_algorithm
-):
-    """
-    Generate a self-signed X.509 certificate.
-
-    A self-signed certificate is generated and written to one of the slots on
-    the YubiKey. A private key must already be present in the corresponding key slot.
-
-    \b
-    SLOT            PIV slot of the certificate
-    PUBLIC-KEY      file containing a public key (use '-' to use stdin)
-    """
-    session = ctx.obj["session"]
-
-    try:
-        metadata = session.get_slot_metadata(slot)
-        if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
-            timeout = 0.0
-        else:
-            timeout = None
-    except ApduError as e:
-        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
-            raise CliFail("No private key in slot {slot}")
-    except NotSupportedError:
-        timeout = 1.0
-
-    data = public_key.read()
-    public_key = serialization.load_pem_public_key(data, default_backend())
-
-    now = datetime.datetime.utcnow()
-    valid_to = now + datetime.timedelta(days=valid_days)
-
-    if "=" not in subject:
-        # Old style, common name only.
-        subject = "CN=" + subject
-
-    # This verifies PIN, make sure next action is sign
-    _ensure_authenticated(ctx, pin, management_key, require_pin_and_key=True)
-
-    try:
-        with prompt_timeout(timeout=timeout):
-            cert = generate_self_signed_certificate(
-                session, slot, public_key, subject, now, valid_to, hash_algorithm
-            )
-        session.put_certificate(slot, cert)
-        session.put_object(OBJECT_ID.CHUID, generate_chuid())
-    except ApduError:
-        raise CliFail("Certificate generation failed.")
-
-
-@cert.command("request")
-@click.pass_context
-@click_pin_option
-@click_slot_argument
-@click.argument("public-key", type=click.File("rb"), metavar="PUBLIC-KEY")
-@click.argument("csr-output", type=click.File("wb"), metavar="CSR")
-@click.option(
-    "-s",
-    "--subject",
-    help="subject for the requested certificate, as an RFC 4514 string",
-    required=True,
-)
-@click_hash_option
-def generate_certificate_signing_request(
-    ctx, pin, slot, public_key, csr_output, subject, hash_algorithm
-):
-    """
-    Generate a Certificate Signing Request (CSR).
-
-    A private key must already be present in the corresponding key slot.
-
-    \b
-    SLOT        PIV slot of the certificate
-    PUBLIC-KEY  file containing a public key (use '-' to use stdin)
-    CSR         file to write CSR to (use '-' to use stdout)
-    """
-    session = ctx.obj["session"]
-    pivman = ctx.obj["pivman_data"]
-
-    data = public_key.read()
-    public_key = serialization.load_pem_public_key(data, default_backend())
-
-    if "=" not in subject:
-        # Old style, common name only.
-        subject = "CN=" + subject
-
-    try:
-        metadata = session.get_slot_metadata(slot)
-        if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
-            timeout = 0.0
-        else:
-            timeout = None
-    except ApduError as e:
-        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
-            raise CliFail("No private key in slot {slot}")
-    except NotSupportedError:
-        timeout = 1.0
-
-    # This verifies PIN, make sure next action is sign
-    _verify_pin(ctx, session, pivman, pin)
-
-    try:
-        with prompt_timeout(timeout=timeout):
-            csr = generate_csr(session, slot, public_key, subject, hash_algorithm)
-    except ApduError:
-        raise CliFail("Certificate Signing Request generation failed.")
-
-    csr_output.write(csr.public_bytes(encoding=serialization.Encoding.PEM))
-    logger.info(f"CSR for slot {slot} written to {_fname(csr_output)}")
-
-
-@cert.command("delete")
-@click.pass_context
-@click_management_key_option
-@click_pin_option
-@click_slot_argument
-def delete_certificate(ctx, management_key, pin, slot):
-    """
-    Delete a certificate.
-
-    Delete a certificate from a PIV slot on the YubiKey.
-
-    \b
-    SLOT            PIV slot of the certificate
-    """
-    session = ctx.obj["session"]
-    _ensure_authenticated(ctx, pin, management_key)
-    session.delete_certificate(slot)
-    session.put_object(OBJECT_ID.CHUID, generate_chuid())
-
-
-@piv.group("objects")
-def objects():
-    """
-    Manage PIV data objects.
-
-    Examples:
-
-    \b
-      Write the contents of a file to data object with ID: abc123:
-      $ ykman piv objects import abc123 myfile.txt
-
-    \b
-      Read the contents of the data object with ID: abc123 into a file:
-      $ ykman piv objects export abc123 myfile.txt
-
-    \b
-      Generate a random value for CHUID:
-      $ ykman piv objects generate chuid
-    """
-
-
-@objects.command("export")
-@click_pin_option
-@click.pass_context
-@click_object_argument
-@click.argument("output", type=click.File("wb"), metavar="OUTPUT")
-def read_object(ctx, pin, object_id, output):
-    """
-    Export an arbitrary PIV data object.
-
-    \b
-    OBJECT          name of PIV data object, or ID in HEX
-    OUTPUT          file to write object to (use '-' to use stdout)
-    """
-
-    session = ctx.obj["session"]
-    pivman = ctx.obj["pivman_data"]
-
-    def do_read_object(retry=True):
-        try:
-            output.write(session.get_object(object_id))
-            logger.info(f"Exported object {object_id} to {_fname(output)}")
-        except ApduError as e:
-            if e.sw == SW.FILE_NOT_FOUND:
-                raise CliFail("No data found.")
-            elif e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED and retry:
-                _verify_pin(ctx, session, pivman, pin)
-                do_read_object(retry=False)
-            else:
-                raise
-
-    do_read_object()
-
-
-@objects.command("import")
-@click_pin_option
-@click_management_key_option
-@click.pass_context
-@click_object_argument
-@click.argument("data", type=click.File("rb"), metavar="DATA")
-def write_object(ctx, pin, management_key, object_id, data):
-    """
-    Write an arbitrary PIV object.
-
-    Write a PIV object by providing the object id.
-    Yubico writable PIV objects are available in
-    the range 5f0000 - 5fffff.
-
-    \b
-    OBJECT         name of PIV data object, or ID in HEX
-    DATA           file containing the data to be written (use '-' to use stdin)
-    """
-
-    session = ctx.obj["session"]
-    _ensure_authenticated(ctx, pin, management_key)
-
-    try:
-        session.put_object(object_id, data.read())
-    except ApduError as e:
-        if e.sw == SW.INCORRECT_PARAMETERS:
-            raise CliFail("Something went wrong, is the object id valid?")
-        raise CliFail("Error writing object")
-
-
-@objects.command("generate")
-@click_pin_option
-@click_management_key_option
-@click.pass_context
-@click_object_argument
-def generate_object(ctx, pin, management_key, object_id):
-    """
-    Generate and write data for a supported data object.
-
-    \b
-    Supported data objects:
-      "CHUID" (Card Holder Unique ID)
-      "CCC"   (Card Capability Container)
-
-    \b
-    OBJECT         name of PIV data object, or ID in HEX
-    """
-
-    session = ctx.obj["session"]
-    _ensure_authenticated(ctx, pin, management_key)
-    if OBJECT_ID.CHUID == object_id:
-        session.put_object(OBJECT_ID.CHUID, generate_chuid())
-    elif OBJECT_ID.CAPABILITY == object_id:
-        session.put_object(OBJECT_ID.CAPABILITY, generate_ccc())
-    else:
-        ctx.fail("Unsupported object ID for generate.")
-
-
-def _prompt_management_key(prompt="Enter a management key [blank to use default key]"):
-    management_key = click_prompt(
-        prompt, default="", hide_input=True, show_default=False
-    )
-    if management_key == "":
-        return DEFAULT_MANAGEMENT_KEY
-    try:
-        return bytes.fromhex(management_key)
-    except Exception:
-        raise CliFail("Management key has the wrong format.")
-
-
-def _prompt_pin(prompt="Enter PIN"):
-    return click_prompt(prompt, default="", hide_input=True, show_default=False)
-
-
-def _valid_pin_length(pin):
-    return 6 <= len(pin) <= 8
-
-
-def _ensure_authenticated(
-    ctx,
-    pin=None,
-    management_key=None,
-    require_pin_and_key=False,
-    mgm_key_prompt=None,
-    no_prompt=False,
-):
-    session = ctx.obj["session"]
-    pivman = ctx.obj["pivman_data"]
-
-    if pivman.has_protected_key and not management_key:
-        _verify_pin(ctx, session, pivman, pin, no_prompt=no_prompt)
-        return True
-
-    _authenticate(ctx, session, management_key, mgm_key_prompt, no_prompt=no_prompt)
-
-    if require_pin_and_key:
-        # Ensure verify was the last thing we did
-        _verify_pin(ctx, session, pivman, pin, no_prompt=no_prompt)
-        return True
-
-
-def _verify_pin(ctx, session, pivman, pin, no_prompt=False):
-    if not pin:
-        if no_prompt:
-            raise CliFail("PIN required.")
-        else:
-            pin = _prompt_pin()
-
-    try:
-        session.verify_pin(pin)
-        if pivman.has_derived_key:
-            with prompt_timeout():
-                session.authenticate(
-                    MANAGEMENT_KEY_TYPE.TDES, derive_management_key(pin, pivman.salt)
-                )
-            session.verify_pin(pin)  # Ensure verify was the last thing we did
-        elif pivman.has_stored_key:
-            pivman_prot = get_pivman_protected_data(session)
-            try:
-                key_type = session.get_management_key_metadata().key_type
-            except NotSupportedError:
-                key_type = MANAGEMENT_KEY_TYPE.TDES
-            with prompt_timeout():
-                session.authenticate(key_type, pivman_prot.key)
-            session.verify_pin(pin)  # Ensure verify was the last thing we did
-    except InvalidPinError as e:
-        attempts = e.attempts_remaining
-        if attempts > 0:
-            raise CliFail(f"PIN verification failed, {attempts} tries left.")
-        else:
-            raise CliFail("PIN is blocked.")
-    except Exception:
-        raise CliFail("PIN verification failed.")
-
-
-def _verify_pin_if_needed(ctx, session, func, pin=None, no_prompt=False):
-    try:
-        return func()
-    except ApduError as e:
-        if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
-            logger.debug("Command failed due to PIN required, verifying and retrying")
-            pivman = ctx.obj["pivman_data"]
-            _verify_pin(ctx, session, pivman, pin, no_prompt)
-        else:
-            raise
-    return func()
-
-
-def _authenticate(ctx, session, management_key, mgm_key_prompt, no_prompt=False):
-    if not management_key:
-        if no_prompt:
-            ctx.fail("Management key required.")
-        else:
-            if mgm_key_prompt is None:
-                management_key = _prompt_management_key()
-            else:
-                management_key = _prompt_management_key(mgm_key_prompt)
-    try:
-        try:
-            key_type = session.get_management_key_metadata().key_type
-        except NotSupportedError:
-            key_type = MANAGEMENT_KEY_TYPE.TDES
-
-        with prompt_timeout():
-            session.authenticate(key_type, management_key)
-    except Exception:
-        raise CliFail("Authentication with management key failed.")
+# Copyright (c) 2017 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import NotSupportedError
+from yubikit.core.smartcard import SmartCardConnection
+from yubikit.piv import (
+    PivSession,
+    InvalidPinError,
+    KEY_TYPE,
+    MANAGEMENT_KEY_TYPE,
+    OBJECT_ID,
+    SLOT,
+    PIN_POLICY,
+    TOUCH_POLICY,
+    DEFAULT_MANAGEMENT_KEY,
+)
+from yubikit.core.smartcard import ApduError, SW
+
+from ..util import (
+    get_leaf_certificates,
+    parse_private_key,
+    parse_certificates,
+    InvalidPasswordError,
+)
+from ..piv import (
+    get_piv_info,
+    get_pivman_data,
+    get_pivman_protected_data,
+    pivman_set_mgm_key,
+    pivman_change_pin,
+    derive_management_key,
+    generate_random_management_key,
+    generate_chuid,
+    generate_ccc,
+    check_key,
+    generate_self_signed_certificate,
+    generate_csr,
+)
+from .util import (
+    CliFail,
+    click_group,
+    click_force_option,
+    click_format_option,
+    click_postpone_execution,
+    click_callback,
+    click_prompt,
+    prompt_timeout,
+    EnumChoice,
+    pretty_print,
+)
+from cryptography.hazmat.primitives import serialization, hashes
+from cryptography.hazmat.backends import default_backend
+
+import click
+import datetime
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+@click_callback()
+def click_parse_piv_slot(ctx, param, val):
+    try:
+        return SLOT[val.upper().replace("-", "_")]
+    except KeyError:
+        try:
+            return SLOT(int(val, 16))
+        except Exception:
+            raise ValueError(val)
+
+
+@click_callback()
+def click_parse_piv_object(ctx, param, val):
+    if val.upper() == "CCC":
+        return OBJECT_ID.CAPABILITY
+    try:
+        return OBJECT_ID[val.upper().replace("-", "_")]
+    except KeyError:
+        try:
+            return int(val, 16)
+        except Exception:
+            raise ValueError(val)
+
+
+@click_callback()
+def click_parse_management_key(ctx, param, val):
+    try:
+        key = bytes.fromhex(val)
+        if key and len(key) not in (16, 24, 32):
+            raise ValueError(
+                "Management key must be exactly 16, 24, or 32 bytes "
+                "(32, 48, or 64 hexadecimal digits) long."
+            )
+        return key
+    except Exception:
+        raise ValueError(val)
+
+
+@click_callback()
+def click_parse_hash(ctx, param, val):
+    try:
+        return getattr(hashes, val)
+    except AttributeError:
+        raise ValueError(val)
+
+
+click_slot_argument = click.argument("slot", callback=click_parse_piv_slot)
+click_object_argument = click.argument(
+    "object_id", callback=click_parse_piv_object, metavar="OBJECT"
+)
+click_management_key_option = click.option(
+    "-m",
+    "--management-key",
+    help="the management key",
+    callback=click_parse_management_key,
+)
+click_pin_option = click.option("-P", "--pin", help="PIN code")
+click_pin_policy_option = click.option(
+    "--pin-policy",
+    type=EnumChoice(PIN_POLICY),
+    default=PIN_POLICY.DEFAULT.name,
+    help="PIN policy for slot",
+)
+click_touch_policy_option = click.option(
+    "--touch-policy",
+    type=EnumChoice(TOUCH_POLICY),
+    default=TOUCH_POLICY.DEFAULT.name,
+    help="touch policy for slot",
+)
+click_hash_option = click.option(
+    "-a",
+    "--hash-algorithm",
+    type=click.Choice(["SHA256", "SHA384", "SHA512"], case_sensitive=False),
+    default="SHA256",
+    show_default=True,
+    help="hash algorithm",
+    callback=click_parse_hash,
+)
+
+
+def _fname(fobj):
+    return getattr(fobj, "name", fobj)
+
+
+@click_group(connections=[SmartCardConnection])
+@click.pass_context
+@click_postpone_execution
+def piv(ctx):
+    """
+    Manage the PIV application.
+
+    Examples:
+
+    \b
+      Generate an ECC P-256 private key and a self-signed certificate in
+      slot 9a:
+      $ ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
+      $ ykman piv certificates generate --subject "CN=yubico" 9a pubkey.pem
+
+    \b
+      Change the PIN from 123456 to 654321:
+      $ ykman piv access change-pin --pin 123456 --new-pin 654321
+
+    \b
+      Reset all PIV data and restore default settings:
+      $ ykman piv reset
+    """
+
+    dev = ctx.obj["device"]
+    conn = dev.open_connection(SmartCardConnection)
+    ctx.call_on_close(conn.close)
+    session = PivSession(conn)
+    ctx.obj["session"] = session
+    ctx.obj["pivman_data"] = get_pivman_data(session)
+
+
+@piv.command()
+@click.pass_context
+def info(ctx):
+    """
+    Display general status of the PIV application.
+    """
+    info = get_piv_info(ctx.obj["session"])
+    click.echo("\n".join(pretty_print(info)))
+
+
+@piv.command()
+@click.pass_context
+@click_force_option
+def reset(ctx, force):
+    """
+    Reset all PIV data.
+
+    This action will wipe all data and restore factory settings for
+    the PIV application on the YubiKey.
+    """
+    force or click.confirm(
+        "WARNING! This will delete all stored PIV data and restore factory "
+        "settings. Proceed?",
+        abort=True,
+        err=True,
+    )
+
+    click.echo("Resetting PIV data...")
+    ctx.obj["session"].reset()
+
+    click.echo("Success! All PIV data have been cleared from the YubiKey.")
+    click.echo("Your YubiKey now has the default PIN, PUK and Management Key:")
+    click.echo("\tPIN:\t123456")
+    click.echo("\tPUK:\t12345678")
+    click.echo("\tManagement Key:\t010203040506070801020304050607080102030405060708")
+
+
+@piv.group()
+def access():
+    """Manage PIN, PUK, and Management Key."""
+
+
+@access.command("set-retries")
+@click.pass_context
+@click.argument("pin-retries", type=click.IntRange(1, 255), metavar="PIN-RETRIES")
+@click.argument("puk-retries", type=click.IntRange(0, 255), metavar="PUK-RETRIES")
+@click_management_key_option
+@click_pin_option
+@click_force_option
+def set_pin_retries(ctx, management_key, pin, pin_retries, puk_retries, force):
+    """
+    Set the number of PIN and PUK retry attempts.
+
+    NOTE: This will reset the PIN and PUK to their factory defaults.
+    """
+    session = ctx.obj["session"]
+    _ensure_authenticated(
+        ctx, pin, management_key, require_pin_and_key=True, no_prompt=force
+    )
+    click.echo("WARNING: This will reset the PIN and PUK to the factory defaults!")
+    force or click.confirm(
+        f"Set the number of PIN and PUK retry attempts to: {pin_retries} "
+        f"{puk_retries}?",
+        abort=True,
+        err=True,
+    )
+    try:
+        session.set_pin_attempts(pin_retries, puk_retries)
+        click.echo("Default PINs are set:")
+        click.echo("\tPIN:\t123456")
+        click.echo("\tPUK:\t12345678")
+    except Exception:
+        raise CliFail("Setting pin retries failed.")
+
+
+@access.command("change-pin")
+@click.pass_context
+@click.option("-P", "--pin", help="current PIN code")
+@click.option("-n", "--new-pin", help="a new PIN to set")
+def change_pin(ctx, pin, new_pin):
+    """
+    Change the PIN code.
+
+    The PIN must be between 6 and 8 characters long, and supports any type of
+    alphanumeric characters. For cross-platform compatibility, numeric PINs are
+    recommended.
+    """
+
+    session = ctx.obj["session"]
+
+    if not pin:
+        pin = _prompt_pin("Enter the current PIN")
+    if not new_pin:
+        new_pin = click_prompt(
+            "Enter the new PIN",
+            default="",
+            hide_input=True,
+            show_default=False,
+            confirmation_prompt=True,
+        )
+
+    if not _valid_pin_length(pin):
+        ctx.fail("Current PIN must be between 6 and 8 characters long.")
+
+    if not _valid_pin_length(new_pin):
+        ctx.fail("New PIN must be between 6 and 8 characters long.")
+
+    try:
+        pivman_change_pin(session, pin, new_pin)
+        click.echo("New PIN set.")
+    except InvalidPinError as e:
+        attempts = e.attempts_remaining
+        if attempts:
+            raise CliFail("PIN change failed - %d tries left." % attempts)
+        else:
+            raise CliFail("PIN is blocked.")
+
+
+@access.command("change-puk")
+@click.pass_context
+@click.option("-p", "--puk", help="current PUK code")
+@click.option("-n", "--new-puk", help="a new PUK code to set")
+def change_puk(ctx, puk, new_puk):
+    """
+    Change the PUK code.
+
+    If the PIN is lost or blocked it can be reset using a PUK.
+    The PUK must be between 6 and 8 characters long, and supports any type of
+    alphanumeric characters.
+    """
+    session = ctx.obj["session"]
+    if not puk:
+        puk = _prompt_pin("Enter the current PUK")
+    if not new_puk:
+        new_puk = click_prompt(
+            "Enter the new PUK",
+            default="",
+            hide_input=True,
+            show_default=False,
+            confirmation_prompt=True,
+        )
+
+    if not _valid_pin_length(puk):
+        ctx.fail("Current PUK must be between 6 and 8 characters long.")
+
+    if not _valid_pin_length(new_puk):
+        ctx.fail("New PUK must be between 6 and 8 characters long.")
+
+    try:
+        session.change_puk(puk, new_puk)
+        click.echo("New PUK set.")
+    except InvalidPinError as e:
+        attempts = e.attempts_remaining
+        if attempts:
+            raise CliFail("PUK change failed - %d tries left." % attempts)
+        else:
+            raise CliFail("PUK is blocked.")
+
+
+@access.command("change-management-key")
+@click.pass_context
+@click_pin_option
+@click.option(
+    "-t",
+    "--touch",
+    is_flag=True,
+    help="require touch on YubiKey when prompted for management key",
+)
+@click.option(
+    "-n",
+    "--new-management-key",
+    help="a new management key to set",
+    callback=click_parse_management_key,
+)
+@click.option(
+    "-m",
+    "--management-key",
+    help="current management key",
+    callback=click_parse_management_key,
+)
+@click.option(
+    "-a",
+    "--algorithm",
+    help="management key algorithm",
+    type=EnumChoice(MANAGEMENT_KEY_TYPE),
+    default=MANAGEMENT_KEY_TYPE.TDES.name,
+    show_default=True,
+)
+@click.option(
+    "-p",
+    "--protect",
+    is_flag=True,
+    help="store new management key on the YubiKey, protected by PIN "
+    "(a random key will be used if no key is provided)",
+)
+@click.option(
+    "-g",
+    "--generate",
+    is_flag=True,
+    help="generate a random management key "
+    "(implied by --protect unless --new-management-key is also given, "
+    "can't be used with --new-management-key)",
+)
+@click_force_option
+def change_management_key(
+    ctx,
+    management_key,
+    algorithm,
+    pin,
+    new_management_key,
+    touch,
+    protect,
+    generate,
+    force,
+):
+    """
+    Change the management key.
+
+    Management functionality is guarded by a management key.
+    This key is required for administrative tasks, such as generating key pairs.
+    A random key may be generated and stored on the YubiKey, protected by PIN.
+    """
+    session = ctx.obj["session"]
+    pivman = ctx.obj["pivman_data"]
+
+    pin_verified = _ensure_authenticated(
+        ctx,
+        pin,
+        management_key,
+        require_pin_and_key=protect,
+        mgm_key_prompt="Enter the current management key [blank to use default key]",
+        no_prompt=force,
+    )
+
+    # Can't combine new key with generate.
+    if new_management_key and generate:
+        ctx.fail("Invalid options: --new-management-key conflicts with --generate")
+
+    # Touch not supported on NEO.
+    if touch and session.version < (4, 0, 0):
+        raise CliFail("Require touch not supported on this YubiKey.")
+
+    # If an old stored key needs to be cleared, the PIN is needed.
+    if not pin_verified and pivman.has_stored_key:
+        if pin:
+            _verify_pin(ctx, session, pivman, pin, no_prompt=force)
+        elif not force:
+            click.confirm(
+                "The current management key is stored on the YubiKey"
+                " and will not be cleared if no PIN is provided. Continue?",
+                abort=True,
+                err=True,
+            )
+
+    if not new_management_key:
+        if protect or generate:
+            new_management_key = generate_random_management_key(algorithm)
+            if not protect:
+                click.echo(f"Generated management key: {new_management_key.hex()}")
+        elif force:
+            ctx.fail(
+                "New management key not given. Please remove the --force "
+                "flag, or set the --generate flag or the "
+                "--new-management-key option."
+            )
+        else:
+            try:
+                new_management_key = bytes.fromhex(
+                    click_prompt(
+                        "Enter the new management key",
+                        hide_input=True,
+                        confirmation_prompt=True,
+                    )
+                )
+            except Exception:
+                ctx.fail("New management key has the wrong format.")
+
+    if len(new_management_key) != algorithm.key_len:
+        raise CliFail(
+            "Management key has the wrong length (expected %d bytes)"
+            % algorithm.key_len
+        )
+
+    try:
+        pivman_set_mgm_key(
+            session, new_management_key, algorithm, touch=touch, store_on_device=protect
+        )
+    except ApduError:
+        raise CliFail("Changing the management key failed.")
+
+
+@access.command("unblock-pin")
+@click.pass_context
+@click.option("-p", "--puk", required=False)
+@click.option("-n", "--new-pin", required=False, metavar="NEW-PIN")
+def unblock_pin(ctx, puk, new_pin):
+    """
+    Unblock the PIN (using PUK).
+    """
+    session = ctx.obj["session"]
+    if not puk:
+        puk = click_prompt("Enter PUK", default="", show_default=False, hide_input=True)
+    if not new_pin:
+        new_pin = click_prompt(
+            "Enter a new PIN", default="", show_default=False, hide_input=True
+        )
+    try:
+        session.unblock_pin(puk, new_pin)
+        click.echo("PIN unblocked")
+    except InvalidPinError as e:
+        attempts = e.attempts_remaining
+        if attempts:
+            raise CliFail("PIN unblock failed - %d tries left." % attempts)
+        else:
+            raise CliFail("PUK is blocked.")
+
+
+@piv.group()
+def keys():
+    """
+    Manage private keys.
+    """
+
+
+@keys.command("generate")
+@click.pass_context
+@click_management_key_option
+@click_pin_option
+@click.option(
+    "-a",
+    "--algorithm",
+    help="algorithm to use in key generation",
+    type=EnumChoice(KEY_TYPE),
+    default=KEY_TYPE.RSA2048.name,
+    show_default=True,
+)
+@click_format_option
+@click_pin_policy_option
+@click_touch_policy_option
+@click_slot_argument
+@click.argument("public-key-output", type=click.File("wb"), metavar="PUBLIC-KEY")
+def generate_key(
+    ctx,
+    slot,
+    public_key_output,
+    management_key,
+    pin,
+    algorithm,
+    format,
+    pin_policy,
+    touch_policy,
+):
+    """
+    Generate an asymmetric key pair.
+
+    The private key is generated on the YubiKey, and written to one of the slots.
+
+    \b
+    SLOT        PIV slot of the private key
+    PUBLIC-KEY  file containing the generated public key (use '-' to use stdout)
+    """
+
+    session = ctx.obj["session"]
+    _ensure_authenticated(ctx, pin, management_key)
+
+    public_key = session.generate_key(slot, algorithm, pin_policy, touch_policy)
+
+    key_encoding = format
+    public_key_output.write(
+        public_key.public_bytes(
+            encoding=key_encoding,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+    )
+    logger.info(
+        f"Private key generated in slot {slot}, public key written to "
+        f"{_fname(public_key_output)}"
+    )
+
+
+@keys.command("import")
+@click.pass_context
+@click_pin_option
+@click_management_key_option
+@click_pin_policy_option
+@click_touch_policy_option
+@click_slot_argument
+@click.argument("private-key", type=click.File("rb"), metavar="PRIVATE-KEY")
+@click.option("-p", "--password", help="password used to decrypt the private key")
+def import_key(
+    ctx, management_key, pin, slot, private_key, pin_policy, touch_policy, password
+):
+    """
+    Import a private key from file.
+
+    Write a private key to one of the PIV slots on the YubiKey.
+
+    \b
+    SLOT         PIV slot of the private key
+    PRIVATE-KEY  file containing the private key (use '-' to use stdin)
+    """
+    session = ctx.obj["session"]
+
+    data = private_key.read()
+
+    while True:
+        if password is not None:
+            password = password.encode()
+        try:
+            private_key = parse_private_key(data, password)
+        except InvalidPasswordError:
+            logger.debug("Error parsing key", exc_info=True)
+            if password is None:
+                password = click_prompt(
+                    "Enter password to decrypt key",
+                    default="",
+                    hide_input=True,
+                    show_default=False,
+                )
+                continue
+            else:
+                password = None
+                click.echo("Wrong password.")
+            continue
+        break
+
+    _ensure_authenticated(ctx, pin, management_key)
+    session.put_key(slot, private_key, pin_policy, touch_policy)
+
+
+@keys.command()
+@click.pass_context
+@click_format_option
+@click_slot_argument
+@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
+def attest(ctx, slot, certificate, format):
+    """
+    Generate an attestation certificate for a key pair.
+
+    Attestation is used to show that an asymmetric key was generated on the
+    YubiKey and therefore doesn't exist outside the device.
+
+    \b
+    SLOT         PIV slot of the private key
+    CERTIFICATE  file to write attestation certificate to (use '-' to use stdout)
+    """
+    session = ctx.obj["session"]
+    try:
+        cert = session.attest_key(slot)
+    except ApduError:
+        raise CliFail("Attestation failed.")
+    certificate.write(cert.public_bytes(encoding=format))
+    logger.info(
+        f"Attestation certificate for slot {slot} written to {_fname(certificate)}"
+    )
+
+
+@keys.command("info")
+@click.pass_context
+@click_slot_argument
+def metadata(ctx, slot):
+    """
+    Show metadata about a private key.
+
+    This will show what type of key is stored in a specific slot,
+    whether it was imported into the YubiKey, or generated on-chip,
+    and what the PIN and Touch policies are for using the key.
+
+    \b
+    SLOT        PIV slot of the private key
+    """
+
+    session = ctx.obj["session"]
+    try:
+        metadata = session.get_slot_metadata(slot)
+        info = {
+            "Key slot": slot,
+            "Algorithm": metadata.key_type.name,
+            "Origin": "GENERATED" if metadata.generated else "IMPORTED",
+            "PIN required for use": metadata.pin_policy.name,
+            "Touch required for use": metadata.touch_policy.name,
+        }
+        click.echo("\n".join(pretty_print(info)))
+    except ApduError as e:
+        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
+            raise CliFail(f"No key stored in slot {slot}.")
+        raise e
+
+
+@keys.command()
+@click.pass_context
+@click_format_option
+@click_slot_argument
+@click.option(
+    "-v",
+    "--verify",
+    is_flag=True,
+    help="verify that the public key matches the private key in the slot",
+)
+@click.option("-P", "--pin", help="PIN code (used for --verify)")
+@click.argument("public-key-output", type=click.File("wb"), metavar="PUBLIC-KEY")
+def export(ctx, slot, public_key_output, format, verify, pin):
+    """
+    Export a public key corresponding to a stored private key.
+
+    This command uses several different mechanisms for exporting the public key
+    corresponding to a stored private key, which may fail.
+    If a certificate is stored in the slot it is assumed to contain the correct public
+    key. If this is not the case, the wrong public key will be returned.
+
+    The --verify flag can be used to verify that the public key being returned matches
+    the private key, by using the slot to create and verify a signature. This may
+    require the PIN to be provided.
+
+    \b
+    SLOT        PIV slot of the private key
+    PUBLIC-KEY  file to write the public key to (use '-' to use stdout)
+    """
+    session = ctx.obj["session"]
+    try:  # Prefer metadata if available
+        public_key = session.get_slot_metadata(slot).public_key
+        logger.debug("Public key read from YubiKey")
+    except ApduError as e:
+        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
+            raise CliFail(f"No key stored in slot {slot}.")
+        raise CliFail(f"Unable to export public key from slot {slot}.")
+    except NotSupportedError:
+        try:  # Try attestation
+            public_key = session.attest_key(slot).public_key()
+            logger.debug("Public key read using attestation")
+        except (NotSupportedError, ApduError):
+            try:  # Read from stored certificate
+                public_key = session.get_certificate(slot).public_key()
+                logger.debug("Public key read from stored certificate")
+                if verify:  # Only needed when read from certificate
+
+                    def do_verify():
+                        with prompt_timeout(timeout=1.0):
+                            if not check_key(session, slot, public_key):
+                                raise CliFail(
+                                    "This public key is not tied to the private key in "
+                                    f"slot {slot}."
+                                )
+
+                    _verify_pin_if_needed(ctx, session, do_verify, pin)
+            except ApduError:
+                raise CliFail(f"Unable to export public key from slot {slot}.")
+
+    key_encoding = format
+    public_key_output.write(
+        public_key.public_bytes(
+            encoding=key_encoding,
+            format=serialization.PublicFormat.SubjectPublicKeyInfo,
+        )
+    )
+    logger.info(f"Public key for slot {slot} written to {_fname(public_key_output)}")
+
+
+@piv.group("certificates")
+def cert():
+    """
+    Manage certificates.
+    """
+
+
+@cert.command("import")
+@click.pass_context
+@click_management_key_option
+@click_pin_option
+@click.option("-p", "--password", help="a password may be needed to decrypt the data")
+@click.option(
+    "-v",
+    "--verify",
+    is_flag=True,
+    help="verify that the certificate matches the private key in the slot",
+)
+@click_slot_argument
+@click.argument("cert", type=click.File("rb"), metavar="CERTIFICATE")
+def import_certificate(ctx, management_key, pin, slot, cert, password, verify):
+    """
+    Import an X.509 certificate.
+
+    Write a certificate to one of the PIV slots on the YubiKey.
+
+    \b
+    SLOT            PIV slot of the certificate
+    CERTIFICATE     file containing the certificate (use '-' to use stdin)
+    """
+    session = ctx.obj["session"]
+
+    data = cert.read()
+
+    while True:
+        if password is not None:
+            password = password.encode()
+        try:
+            certs = parse_certificates(data, password)
+        except InvalidPasswordError:
+            logger.debug("Error parsing certificate", exc_info=True)
+            if password is None:
+                password = click_prompt(
+                    "Enter password to decrypt certificate",
+                    default="",
+                    hide_input=True,
+                    show_default=False,
+                )
+                continue
+            else:
+                password = None
+                click.echo("Wrong password.")
+            continue
+        break
+
+    if len(certs) > 1:
+        #  If multiple certs, only import leaf.
+        #  Leaf is the cert with a subject that is not an issuer in the chain.
+        leafs = get_leaf_certificates(certs)
+        cert_to_import = leafs[0]
+    else:
+        cert_to_import = certs[0]
+
+    _ensure_authenticated(ctx, pin, management_key)
+
+    if verify:
+        public_key = cert_to_import.public_key()
+
+        try:
+            metadata = session.get_slot_metadata(slot)
+            if metadata.pin_policy in (PIN_POLICY.ALWAYS, PIN_POLICY.ONCE):
+                pivman = ctx.obj["pivman_data"]
+                _verify_pin(ctx, session, pivman, pin)
+
+            if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
+                timeout = 0.0
+            else:
+                timeout = None
+        except ApduError as e:
+            if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
+                raise CliFail("No private key in slot {slot}")
+            raise e
+        except NotSupportedError:
+            timeout = 1.0
+
+        def do_verify():
+            with prompt_timeout(timeout=timeout):
+                if not check_key(session, slot, public_key):
+                    raise CliFail(
+                        "The public key of the certificate does not match the "
+                        f"private key in slot {slot}"
+                    )
+
+        _verify_pin_if_needed(ctx, session, do_verify, pin)
+
+    session.put_certificate(slot, cert_to_import)
+    session.put_object(OBJECT_ID.CHUID, generate_chuid())
+
+
+@cert.command("export")
+@click.pass_context
+@click_format_option
+@click_slot_argument
+@click.argument("certificate", type=click.File("wb"), metavar="CERTIFICATE")
+def export_certificate(ctx, format, slot, certificate):
+    """
+    Export an X.509 certificate.
+
+    Reads a certificate from one of the PIV slots on the YubiKey.
+
+    \b
+    SLOT            PIV slot of the certificate
+    CERTIFICATE     file to write certificate to (use '-' to use stdout)
+    """
+    session = ctx.obj["session"]
+    try:
+        cert = session.get_certificate(slot)
+        certificate.write(cert.public_bytes(encoding=format))
+        logger.info(f"Certificate from slot {slot} exported to {_fname(certificate)}")
+    except ApduError as e:
+        if e.sw == SW.FILE_NOT_FOUND:
+            raise CliFail("No certificate found.")
+        else:
+            raise CliFail("Failed reading certificate.")
+
+
+@cert.command("generate")
+@click.pass_context
+@click_management_key_option
+@click_pin_option
+@click_slot_argument
+@click.argument("public-key", type=click.File("rb"), metavar="PUBLIC-KEY")
+@click.option(
+    "-s",
+    "--subject",
+    help="subject for the certificate, as an RFC 4514 string",
+    required=True,
+)
+@click.option(
+    "-d",
+    "--valid-days",
+    help="number of days until the certificate expires",
+    type=click.INT,
+    default=365,
+    show_default=True,
+)
+@click_hash_option
+def generate_certificate(
+    ctx, management_key, pin, slot, public_key, subject, valid_days, hash_algorithm
+):
+    """
+    Generate a self-signed X.509 certificate.
+
+    A self-signed certificate is generated and written to one of the slots on
+    the YubiKey. A private key must already be present in the corresponding key slot.
+
+    \b
+    SLOT            PIV slot of the certificate
+    PUBLIC-KEY      file containing a public key (use '-' to use stdin)
+    """
+    session = ctx.obj["session"]
+
+    try:
+        metadata = session.get_slot_metadata(slot)
+        if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
+            timeout = 0.0
+        else:
+            timeout = None
+    except ApduError as e:
+        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
+            raise CliFail("No private key in slot {slot}")
+    except NotSupportedError:
+        timeout = 1.0
+
+    data = public_key.read()
+    public_key = serialization.load_pem_public_key(data, default_backend())
+
+    now = datetime.datetime.utcnow()
+    valid_to = now + datetime.timedelta(days=valid_days)
+
+    if "=" not in subject:
+        # Old style, common name only.
+        subject = "CN=" + subject
+
+    # This verifies PIN, make sure next action is sign
+    _ensure_authenticated(ctx, pin, management_key, require_pin_and_key=True)
+
+    try:
+        with prompt_timeout(timeout=timeout):
+            cert = generate_self_signed_certificate(
+                session, slot, public_key, subject, now, valid_to, hash_algorithm
+            )
+        session.put_certificate(slot, cert)
+        session.put_object(OBJECT_ID.CHUID, generate_chuid())
+    except ApduError:
+        raise CliFail("Certificate generation failed.")
+
+
+@cert.command("request")
+@click.pass_context
+@click_pin_option
+@click_slot_argument
+@click.argument("public-key", type=click.File("rb"), metavar="PUBLIC-KEY")
+@click.argument("csr-output", type=click.File("wb"), metavar="CSR")
+@click.option(
+    "-s",
+    "--subject",
+    help="subject for the requested certificate, as an RFC 4514 string",
+    required=True,
+)
+@click_hash_option
+def generate_certificate_signing_request(
+    ctx, pin, slot, public_key, csr_output, subject, hash_algorithm
+):
+    """
+    Generate a Certificate Signing Request (CSR).
+
+    A private key must already be present in the corresponding key slot.
+
+    \b
+    SLOT        PIV slot of the certificate
+    PUBLIC-KEY  file containing a public key (use '-' to use stdin)
+    CSR         file to write CSR to (use '-' to use stdout)
+    """
+    session = ctx.obj["session"]
+    pivman = ctx.obj["pivman_data"]
+
+    data = public_key.read()
+    public_key = serialization.load_pem_public_key(data, default_backend())
+
+    if "=" not in subject:
+        # Old style, common name only.
+        subject = "CN=" + subject
+
+    try:
+        metadata = session.get_slot_metadata(slot)
+        if metadata.touch_policy in (TOUCH_POLICY.ALWAYS, TOUCH_POLICY.CACHED):
+            timeout = 0.0
+        else:
+            timeout = None
+    except ApduError as e:
+        if e.sw == SW.REFERENCE_DATA_NOT_FOUND:
+            raise CliFail("No private key in slot {slot}")
+    except NotSupportedError:
+        timeout = 1.0
+
+    # This verifies PIN, make sure next action is sign
+    _verify_pin(ctx, session, pivman, pin)
+
+    try:
+        with prompt_timeout(timeout=timeout):
+            csr = generate_csr(session, slot, public_key, subject, hash_algorithm)
+    except ApduError:
+        raise CliFail("Certificate Signing Request generation failed.")
+
+    csr_output.write(csr.public_bytes(encoding=serialization.Encoding.PEM))
+    logger.info(f"CSR for slot {slot} written to {_fname(csr_output)}")
+
+
+@cert.command("delete")
+@click.pass_context
+@click_management_key_option
+@click_pin_option
+@click_slot_argument
+def delete_certificate(ctx, management_key, pin, slot):
+    """
+    Delete a certificate.
+
+    Delete a certificate from a PIV slot on the YubiKey.
+
+    \b
+    SLOT            PIV slot of the certificate
+    """
+    session = ctx.obj["session"]
+    _ensure_authenticated(ctx, pin, management_key)
+    session.delete_certificate(slot)
+    session.put_object(OBJECT_ID.CHUID, generate_chuid())
+
+
+@piv.group("objects")
+def objects():
+    """
+    Manage PIV data objects.
+
+    Examples:
+
+    \b
+      Write the contents of a file to data object with ID: abc123:
+      $ ykman piv objects import abc123 myfile.txt
+
+    \b
+      Read the contents of the data object with ID: abc123 into a file:
+      $ ykman piv objects export abc123 myfile.txt
+
+    \b
+      Generate a random value for CHUID:
+      $ ykman piv objects generate chuid
+    """
+
+
+@objects.command("export")
+@click_pin_option
+@click.pass_context
+@click_object_argument
+@click.argument("output", type=click.File("wb"), metavar="OUTPUT")
+def read_object(ctx, pin, object_id, output):
+    """
+    Export an arbitrary PIV data object.
+
+    \b
+    OBJECT          name of PIV data object, or ID in HEX
+    OUTPUT          file to write object to (use '-' to use stdout)
+    """
+
+    session = ctx.obj["session"]
+    pivman = ctx.obj["pivman_data"]
+
+    def do_read_object(retry=True):
+        try:
+            output.write(session.get_object(object_id))
+            logger.info(f"Exported object {object_id} to {_fname(output)}")
+        except ApduError as e:
+            if e.sw == SW.FILE_NOT_FOUND:
+                raise CliFail("No data found.")
+            elif e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED and retry:
+                _verify_pin(ctx, session, pivman, pin)
+                do_read_object(retry=False)
+            else:
+                raise
+
+    do_read_object()
+
+
+@objects.command("import")
+@click_pin_option
+@click_management_key_option
+@click.pass_context
+@click_object_argument
+@click.argument("data", type=click.File("rb"), metavar="DATA")
+def write_object(ctx, pin, management_key, object_id, data):
+    """
+    Write an arbitrary PIV object.
+
+    Write a PIV object by providing the object id.
+    Yubico writable PIV objects are available in
+    the range 5f0000 - 5fffff.
+
+    \b
+    OBJECT         name of PIV data object, or ID in HEX
+    DATA           file containing the data to be written (use '-' to use stdin)
+    """
+
+    session = ctx.obj["session"]
+    _ensure_authenticated(ctx, pin, management_key)
+
+    try:
+        session.put_object(object_id, data.read())
+    except ApduError as e:
+        if e.sw == SW.INCORRECT_PARAMETERS:
+            raise CliFail("Something went wrong, is the object id valid?")
+        raise CliFail("Error writing object")
+
+
+@objects.command("generate")
+@click_pin_option
+@click_management_key_option
+@click.pass_context
+@click_object_argument
+def generate_object(ctx, pin, management_key, object_id):
+    """
+    Generate and write data for a supported data object.
+
+    \b
+    Supported data objects:
+      "CHUID" (Card Holder Unique ID)
+      "CCC"   (Card Capability Container)
+
+    \b
+    OBJECT         name of PIV data object, or ID in HEX
+    """
+
+    session = ctx.obj["session"]
+    _ensure_authenticated(ctx, pin, management_key)
+    if OBJECT_ID.CHUID == object_id:
+        session.put_object(OBJECT_ID.CHUID, generate_chuid())
+    elif OBJECT_ID.CAPABILITY == object_id:
+        session.put_object(OBJECT_ID.CAPABILITY, generate_ccc())
+    else:
+        ctx.fail("Unsupported object ID for generate.")
+
+
+def _prompt_management_key(prompt="Enter a management key [blank to use default key]"):
+    management_key = click_prompt(
+        prompt, default="", hide_input=True, show_default=False
+    )
+    if management_key == "":
+        return DEFAULT_MANAGEMENT_KEY
+    try:
+        return bytes.fromhex(management_key)
+    except Exception:
+        raise CliFail("Management key has the wrong format.")
+
+
+def _prompt_pin(prompt="Enter PIN"):
+    return click_prompt(prompt, default="", hide_input=True, show_default=False)
+
+
+def _valid_pin_length(pin):
+    return 6 <= len(pin) <= 8
+
+
+def _ensure_authenticated(
+    ctx,
+    pin=None,
+    management_key=None,
+    require_pin_and_key=False,
+    mgm_key_prompt=None,
+    no_prompt=False,
+):
+    session = ctx.obj["session"]
+    pivman = ctx.obj["pivman_data"]
+
+    if pivman.has_protected_key and not management_key:
+        _verify_pin(ctx, session, pivman, pin, no_prompt=no_prompt)
+        return True
+
+    _authenticate(ctx, session, management_key, mgm_key_prompt, no_prompt=no_prompt)
+
+    if require_pin_and_key:
+        # Ensure verify was the last thing we did
+        _verify_pin(ctx, session, pivman, pin, no_prompt=no_prompt)
+        return True
+
+
+def _verify_pin(ctx, session, pivman, pin, no_prompt=False):
+    if not pin:
+        if no_prompt:
+            raise CliFail("PIN required.")
+        else:
+            pin = _prompt_pin()
+
+    try:
+        session.verify_pin(pin)
+        if pivman.has_derived_key:
+            with prompt_timeout():
+                session.authenticate(
+                    MANAGEMENT_KEY_TYPE.TDES, derive_management_key(pin, pivman.salt)
+                )
+            session.verify_pin(pin)  # Ensure verify was the last thing we did
+        elif pivman.has_stored_key:
+            pivman_prot = get_pivman_protected_data(session)
+            try:
+                key_type = session.get_management_key_metadata().key_type
+            except NotSupportedError:
+                key_type = MANAGEMENT_KEY_TYPE.TDES
+            with prompt_timeout():
+                session.authenticate(key_type, pivman_prot.key)
+            session.verify_pin(pin)  # Ensure verify was the last thing we did
+    except InvalidPinError as e:
+        attempts = e.attempts_remaining
+        if attempts > 0:
+            raise CliFail(f"PIN verification failed, {attempts} tries left.")
+        else:
+            raise CliFail("PIN is blocked.")
+    except Exception:
+        raise CliFail("PIN verification failed.")
+
+
+def _verify_pin_if_needed(ctx, session, func, pin=None, no_prompt=False):
+    try:
+        return func()
+    except ApduError as e:
+        if e.sw == SW.SECURITY_CONDITION_NOT_SATISFIED:
+            logger.debug("Command failed due to PIN required, verifying and retrying")
+            pivman = ctx.obj["pivman_data"]
+            _verify_pin(ctx, session, pivman, pin, no_prompt)
+        else:
+            raise
+    return func()
+
+
+def _authenticate(ctx, session, management_key, mgm_key_prompt, no_prompt=False):
+    if not management_key:
+        if no_prompt:
+            ctx.fail("Management key required.")
+        else:
+            if mgm_key_prompt is None:
+                management_key = _prompt_management_key()
+            else:
+                management_key = _prompt_management_key(mgm_key_prompt)
+    try:
+        try:
+            key_type = session.get_management_key_metadata().key_type
+        except NotSupportedError:
+            key_type = MANAGEMENT_KEY_TYPE.TDES
+
+        with prompt_timeout():
+            session.authenticate(key_type, management_key)
+    except Exception:
+        raise CliFail("Authentication with management key failed.")
```

### Comparing `yubikey_manager-5.1.0/ykman/_cli/script.py` & `yubikey_manager-5.1.1/ykman/_cli/script.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,105 +1,105 @@
-# Copyright (c) 2021 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from .util import click_force_option, click_command
-from .. import scripting  # noqa - make sure this file gets included by PyInstaller.
-
-import sys
-import click
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-_WARNING = """
-WARNING: Never run a script without fully understanding what it does!
-
-Scripts are very powerful, and have the power to harm to both your YubiKey and
-your computer.
-
-ONLY run scripts that you fully trust!
-"""
-
-
-def _add_warning(obj):
-    obj.__doc__ = obj.__doc__.format("\n    ".join(_WARNING.splitlines()))
-    return obj
-
-
-@click_command(
-    "script",
-    context_settings=dict(ignore_unknown_options=True),
-)
-@click.pass_context
-@click.option(
-    "-s",
-    "--site-dir",
-    type=click.Path(exists=True),
-    multiple=True,
-    metavar="DIR",
-    help="specify additional path(s) to load python modules from",
-)
-@click.argument("script", type=click.File("rb"), metavar="FILE")
-@click.argument("arguments", nargs=-1, type=click.UNPROCESSED)
-@click_force_option
-@_add_warning
-def run_script(ctx, site_dir, script, arguments, force):
-    """
-    Run a python script.
-
-    {0}
-
-    Argument can be passed to the script by adding them after the end of the
-    command. These will be accessible inside the script as sys.argv, with the script
-    name as the initial value. For more information on scripting, see the "Scripting"
-    page in the documentation.
-
-    Examples:
-
-    \b
-      Run the file "myscript.py", passing arguments "123456" and "indata.csv":
-      $ ykman script myscript.py 123456 indata.csv
-
-    """
-
-    force or click.confirm(
-        f"{_WARNING}\n"
-        "You can bypass this message by running the command with the --force flag.\n\n"
-        "Run script?",
-        abort=True,
-        err=True,
-    )
-
-    for sd in site_dir:
-        logger.debug("Add %s to path.", sd)
-        sys.path.append(sd)
-
-    script_body = script.read()
-
-    sys.argv = [script.name, *arguments]
-    exec(script_body, {})  # nosec
+# Copyright (c) 2021 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from .util import click_force_option, click_command
+from .. import scripting  # noqa - make sure this file gets included by PyInstaller.
+
+import sys
+import click
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+_WARNING = """
+WARNING: Never run a script without fully understanding what it does!
+
+Scripts are very powerful, and have the power to harm to both your YubiKey and
+your computer.
+
+ONLY run scripts that you fully trust!
+"""
+
+
+def _add_warning(obj):
+    obj.__doc__ = obj.__doc__.format("\n    ".join(_WARNING.splitlines()))
+    return obj
+
+
+@click_command(
+    "script",
+    context_settings=dict(ignore_unknown_options=True),
+)
+@click.pass_context
+@click.option(
+    "-s",
+    "--site-dir",
+    type=click.Path(exists=True),
+    multiple=True,
+    metavar="DIR",
+    help="specify additional path(s) to load python modules from",
+)
+@click.argument("script", type=click.File("rb"), metavar="FILE")
+@click.argument("arguments", nargs=-1, type=click.UNPROCESSED)
+@click_force_option
+@_add_warning
+def run_script(ctx, site_dir, script, arguments, force):
+    """
+    Run a python script.
+
+    {0}
+
+    Argument can be passed to the script by adding them after the end of the
+    command. These will be accessible inside the script as sys.argv, with the script
+    name as the initial value. For more information on scripting, see the "Scripting"
+    page in the documentation.
+
+    Examples:
+
+    \b
+      Run the file "myscript.py", passing arguments "123456" and "indata.csv":
+      $ ykman script myscript.py 123456 indata.csv
+
+    """
+
+    force or click.confirm(
+        f"{_WARNING}\n"
+        "You can bypass this message by running the command with the --force flag.\n\n"
+        "Run script?",
+        abort=True,
+        err=True,
+    )
+
+    for sd in site_dir:
+        logger.debug("Add %s to path.", sd)
+        sys.path.append(sd)
+
+    script_body = script.read()
+
+    sys.argv = [script.name, *arguments]
+    exec(script_body, {})  # nosec
```

### Comparing `yubikey_manager-5.1.0/ykman/base.py` & `yubikey_manager-5.1.1/ykman/base.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,49 +1,49 @@
-# Copyright (c) 2015-2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import TRANSPORT, PID, YubiKeyDevice
-from typing import Optional, Hashable
-
-
-class YkmanDevice(YubiKeyDevice):
-    """YubiKey device reference, with optional PID"""
-
-    def __init__(self, transport: TRANSPORT, fingerprint: Hashable, pid: Optional[PID]):
-        super(YkmanDevice, self).__init__(transport, fingerprint)
-        self._pid = pid
-
-    @property
-    def pid(self) -> Optional[PID]:
-        """Return the PID of the YubiKey, if available."""
-        return self._pid
-
-    def __repr__(self):
-        return "%s(pid=%04x, fingerprint=%r)" % (
-            type(self).__name__,
-            self.pid or 0,
-            self.fingerprint,
-        )
+# Copyright (c) 2015-2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import TRANSPORT, PID, YubiKeyDevice
+from typing import Optional, Hashable
+
+
+class YkmanDevice(YubiKeyDevice):
+    """YubiKey device reference, with optional PID"""
+
+    def __init__(self, transport: TRANSPORT, fingerprint: Hashable, pid: Optional[PID]):
+        super(YkmanDevice, self).__init__(transport, fingerprint)
+        self._pid = pid
+
+    @property
+    def pid(self) -> Optional[PID]:
+        """Return the PID of the YubiKey, if available."""
+        return self._pid
+
+    def __repr__(self):
+        return "%s(pid=%04x, fingerprint=%r)" % (
+            type(self).__name__,
+            self.pid or 0,
+            self.fingerprint,
+        )
```

### Comparing `yubikey_manager-5.1.0/ykman/fido.py` & `yubikey_manager-5.1.1/ykman/fido.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,99 +1,99 @@
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-import time
-import struct
-from yubikit.core.fido import FidoConnection
-from yubikit.core.smartcard import SW
-from fido2.ctap1 import Ctap1, ApduError
-
-from typing import Optional
-
-
-U2F_VENDOR_FIRST = 0x40
-
-# FIPS specific INS values
-INS_FIPS_VERIFY_PIN = U2F_VENDOR_FIRST + 3
-INS_FIPS_SET_PIN = U2F_VENDOR_FIRST + 4
-INS_FIPS_RESET = U2F_VENDOR_FIRST + 5
-INS_FIPS_VERIFY_FIPS_MODE = U2F_VENDOR_FIRST + 6
-
-
-def is_in_fips_mode(fido_connection: FidoConnection) -> bool:
-    """Check if a YubiKey FIPS is in FIPS approved mode."""
-    try:
-        ctap = Ctap1(fido_connection)
-        ctap.send_apdu(ins=INS_FIPS_VERIFY_FIPS_MODE)
-        return True
-    except ApduError as e:
-        # 0x6a81: Function not supported (PIN not set - not FIPS Mode)
-        if e.code == SW.FUNCTION_NOT_SUPPORTED:
-            return False
-        raise
-
-
-def fips_change_pin(
-    fido_connection: FidoConnection, old_pin: Optional[str], new_pin: str
-):
-    """Change the PIN on a YubiKey FIPS.
-
-    If no PIN is set, pass None or an empty string as old_pin.
-    """
-    ctap = Ctap1(fido_connection)
-
-    old_pin_bytes = old_pin.encode() if old_pin else b""
-    new_pin_bytes = new_pin.encode()
-    new_length = len(new_pin_bytes)
-
-    data = struct.pack("B", new_length) + old_pin_bytes + new_pin_bytes
-
-    ctap.send_apdu(ins=INS_FIPS_SET_PIN, data=data)
-
-
-def fips_verify_pin(fido_connection: FidoConnection, pin: str):
-    """Unlock the YubiKey FIPS U2F module for credential creation."""
-    ctap = Ctap1(fido_connection)
-    ctap.send_apdu(ins=INS_FIPS_VERIFY_PIN, data=pin.encode())
-
-
-def fips_reset(fido_connection: FidoConnection):
-    """Reset the FIDO module of a YubiKey FIPS.
-
-    Note: This action is only permitted immediately after YubiKey FIPS power-up. It
-    also requires the user to touch the flashing button on the YubiKey, and will halt
-    until that happens, or the command times out.
-    """
-    ctap = Ctap1(fido_connection)
-    while True:
-        try:
-            ctap.send_apdu(ins=INS_FIPS_RESET)
-            return
-        except ApduError as e:
-            if e.code == SW.CONDITIONS_NOT_SATISFIED:
-                time.sleep(0.5)
-            else:
-                raise e
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+import time
+import struct
+from yubikit.core.fido import FidoConnection
+from yubikit.core.smartcard import SW
+from fido2.ctap1 import Ctap1, ApduError
+
+from typing import Optional
+
+
+U2F_VENDOR_FIRST = 0x40
+
+# FIPS specific INS values
+INS_FIPS_VERIFY_PIN = U2F_VENDOR_FIRST + 3
+INS_FIPS_SET_PIN = U2F_VENDOR_FIRST + 4
+INS_FIPS_RESET = U2F_VENDOR_FIRST + 5
+INS_FIPS_VERIFY_FIPS_MODE = U2F_VENDOR_FIRST + 6
+
+
+def is_in_fips_mode(fido_connection: FidoConnection) -> bool:
+    """Check if a YubiKey FIPS is in FIPS approved mode."""
+    try:
+        ctap = Ctap1(fido_connection)
+        ctap.send_apdu(ins=INS_FIPS_VERIFY_FIPS_MODE)
+        return True
+    except ApduError as e:
+        # 0x6a81: Function not supported (PIN not set - not FIPS Mode)
+        if e.code == SW.FUNCTION_NOT_SUPPORTED:
+            return False
+        raise
+
+
+def fips_change_pin(
+    fido_connection: FidoConnection, old_pin: Optional[str], new_pin: str
+):
+    """Change the PIN on a YubiKey FIPS.
+
+    If no PIN is set, pass None or an empty string as old_pin.
+    """
+    ctap = Ctap1(fido_connection)
+
+    old_pin_bytes = old_pin.encode() if old_pin else b""
+    new_pin_bytes = new_pin.encode()
+    new_length = len(new_pin_bytes)
+
+    data = struct.pack("B", new_length) + old_pin_bytes + new_pin_bytes
+
+    ctap.send_apdu(ins=INS_FIPS_SET_PIN, data=data)
+
+
+def fips_verify_pin(fido_connection: FidoConnection, pin: str):
+    """Unlock the YubiKey FIPS U2F module for credential creation."""
+    ctap = Ctap1(fido_connection)
+    ctap.send_apdu(ins=INS_FIPS_VERIFY_PIN, data=pin.encode())
+
+
+def fips_reset(fido_connection: FidoConnection):
+    """Reset the FIDO module of a YubiKey FIPS.
+
+    Note: This action is only permitted immediately after YubiKey FIPS power-up. It
+    also requires the user to touch the flashing button on the YubiKey, and will halt
+    until that happens, or the command times out.
+    """
+    ctap = Ctap1(fido_connection)
+    while True:
+        try:
+            ctap.send_apdu(ins=INS_FIPS_RESET)
+            return
+        except ApduError as e:
+            if e.code == SW.CONDITIONS_NOT_SATISFIED:
+                time.sleep(0.5)
+            else:
+                raise e
```

### Comparing `yubikey_manager-5.1.0/ykman/hid/base.py` & `yubikey_manager-5.1.1/ykman/hid/base.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import TRANSPORT, PID
-from ..base import YkmanDevice
-
-YUBICO_VID = 0x1050
-
-USAGE_FIDO = (0xF1D0, 1)
-USAGE_OTP = (1, 6)
-
-
-class OtpYubiKeyDevice(YkmanDevice):
-    """YubiKey USB HID OTP device"""
-
-    def __init__(self, path, pid, connection_cls):
-        super(OtpYubiKeyDevice, self).__init__(TRANSPORT.USB, path, PID(pid))
-        self.path = path
-        self._connection_cls = connection_cls
-
-    def supports_connection(self, connection_type):
-        return issubclass(self._connection_cls, connection_type)
-
-    def open_connection(self, connection_type):
-        if self.supports_connection(connection_type):
-            return self._connection_cls(self.path)
-        return super(OtpYubiKeyDevice, self).open_connection(connection_type)
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import TRANSPORT, PID
+from ..base import YkmanDevice
+
+YUBICO_VID = 0x1050
+
+USAGE_FIDO = (0xF1D0, 1)
+USAGE_OTP = (1, 6)
+
+
+class OtpYubiKeyDevice(YkmanDevice):
+    """YubiKey USB HID OTP device"""
+
+    def __init__(self, path, pid, connection_cls):
+        super(OtpYubiKeyDevice, self).__init__(TRANSPORT.USB, path, PID(pid))
+        self.path = path
+        self._connection_cls = connection_cls
+
+    def supports_connection(self, connection_type):
+        return issubclass(self._connection_cls, connection_type)
+
+    def open_connection(self, connection_type):
+        if self.supports_connection(connection_type):
+            return self._connection_cls(self.path)
+        return super(OtpYubiKeyDevice, self).open_connection(connection_type)
```

### Comparing `yubikey_manager-5.1.0/ykman/hid/freebsd.py` & `yubikey_manager-5.1.1/ykman/hid/freebsd.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,301 +1,301 @@
-# Original work Copyright 2016 Google Inc. All Rights Reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# Modified work Copyright 2022 Michael Gmelin. All Rights Reserved.
-# This file, with modifications, is licensed under the above Apache License.
-#
-# Modified work Copyright 2022 Yubico AB. All Rights Reserved.
-# This file, with modifications, is licensed under the above Apache License.
-
-# FreeBSD HID driver.
-#
-# There are two options to access UHID on FreeBSD:
-#
-# hidraw(4) - New method, not enabled by default
-#             on FreeBSD 13.x and earlier
-# uhid(4) - Classic method, default option on
-#           FreeBSD 13.x and earlier
-#
-# To avoid attaching the Yubikey as a keyboard, do:
-#
-#     usbconfig ugenX.Y add_quirk UQ_KBD_IGNORE
-#     usbconfig ugenX.Y reset
-#
-# The list of available devices is shown using `usbconfig list`
-# You can make these changes permanent by altering loader.conf.
-#
-# Starting from FreeBSD 13 hidraw(4) can be enabled using:
-#
-#     sysrc kld_list+="hidraw hkbd"
-#     cat >>/boot/loader.conf<<EOF
-#     hw.usb.usbhid.enable="1"
-#     hw.usb.quirk.0="0x1050 0x0010 0 0xffff UQ_KBD_IGNORE"  # YKS_OTP
-#     hw.usb.quirk.1="0x1050 0x0110 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP
-#     hw.usb.quirk.2="0x1050 0x0111 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_CCID
-#     hw.usb.quirk.3="0x1050 0x0114 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO
-#     hw.usb.quirk.4="0x1050 0x0116 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO_CCID
-#     hw.usb.quirk.5="0x1050 0x0401 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP
-#     hw.usb.quirk.6="0x1050 0x0403 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO
-#     hw.usb.quirk.7="0x1050 0x0405 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_CCID
-#     hw.usb.quirk.8="0x1050 0x0407 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO_CCID
-#     hw.usb.quirk.9="0x1050 0x0410 0 0xffff UQ_KBD_IGNORE"  # YKP_OTP_FIDO
-#     EOF
-#     reboot
-#
-from yubikit.core.otp import OtpConnection
-from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
-
-from ctypes.util import find_library
-import ctypes
-
-import glob
-import fcntl
-import os
-import re
-import sys
-import struct
-import logging
-
-# Don't typecheck this file on Windows
-assert sys.platform != "win32"  # nosec
-
-logger = logging.getLogger(__name__)
-
-devdir = "/dev/"
-
-# /usr/include/dev/usb/usb_ioctl.h
-USB_GET_REPORT = 0xC0205517
-USB_SET_REPORT = 0x80205518
-USB_GET_REPORT_DESC = 0xC0205515
-
-# /usr/include/dev/hid/hidraw.h>
-HIDIOCGRAWINFO = 0x40085520
-HIDIOCGRDESC = 0x2000551F
-HIDIOCGRDESCSIZE = 0x4004551E
-HIDIOCGFEATURE_9 = 0xC0095524
-HIDIOCSFEATURE_9 = 0x80095523
-
-
-class HidrawConnection(OtpConnection):
-    """
-    hidraw(4) is FreeBSD's modern raw access driver, based on usbhid(4).
-    It is available since FreeBSD 13 and can be activated by adding
-    `hw.usb.usbhid.enable="1"` to `/boot/loader.conf`. The actual kernel
-    module is loaded with `kldload hidraw`.
-    """
-
-    def __init__(self, path):
-        self.fd = os.open(path, os.O_RDWR)
-
-    def close(self):
-        os.close(self.fd)
-
-    def receive(self):
-        buf = bytearray(1 + 8)
-        fcntl.ioctl(self.fd, HIDIOCGFEATURE_9, buf, True)
-        return buf[1:]
-
-    def send(self, data):
-        buf = bytes([0]) + data
-        fcntl.ioctl(self.fd, HIDIOCSFEATURE_9, buf)
-
-    @staticmethod
-    def get_info(dev):
-        buf = bytearray(4 + 2 + 2)
-        fcntl.ioctl(dev, HIDIOCGRAWINFO, buf, True)
-        return struct.unpack("<IHH", buf)
-
-    @staticmethod
-    def get_descriptor(dev):
-        buf = bytearray(4)
-        fcntl.ioctl(dev, HIDIOCGRDESCSIZE, buf, True)
-        size = struct.unpack("<I", buf)[0]
-        buf += bytearray(size)
-        fcntl.ioctl(dev, HIDIOCGRDESC, buf, True)
-        return buf[4:]
-
-    @staticmethod
-    def get_usage(dev):
-        buf = HidrawConnection.get_descriptor(dev)
-        usage, usage_page = (None, None)
-        while buf:
-            head, buf = buf[0], buf[1:]
-            typ, size = 0xFC & head, 0x03 & head
-            value, buf = buf[:size], buf[size:]
-            if typ == 4:  # Usage page
-                usage_page = struct.unpack("<I", value.ljust(4, b"\0"))[0]
-                if usage is not None:
-                    return usage_page, usage
-            elif typ == 8:  # Usage
-                usage = struct.unpack("<I", value.ljust(4, b"\0"))[0]
-                if usage_page is not None:
-                    return usage_page, usage
-
-    @staticmethod
-    def list_devices():
-        devices = []
-        for hidraw in glob.glob(devdir + "hidraw?*"):
-            try:
-                with open(hidraw, "rb") as f:
-                    bustype, vid, pid = HidrawConnection.get_info(f)
-                    if vid == YUBICO_VID and HidrawConnection.get_usage(f) == USAGE_OTP:
-                        devices.append(OtpYubiKeyDevice(hidraw, pid, HidrawConnection))
-            except Exception as e:
-                logger.debug("Failed opening HID device", exc_info=e)
-                continue
-        return devices
-
-
-# For UhidConnection
-libc = ctypes.CDLL(find_library("c"))
-
-
-class usb_gen_descriptor(ctypes.Structure):
-    _fields_ = [
-        (
-            "ugd_data",
-            ctypes.c_void_p,
-        ),
-        ("ugd_lang_id", ctypes.c_uint16),
-        ("ugd_maxlen", ctypes.c_uint16),
-        ("ugd_actlen", ctypes.c_uint16),
-        ("ugd_offset", ctypes.c_uint16),
-        ("ugd_config_index", ctypes.c_uint8),
-        ("ugd_string_index", ctypes.c_uint8),
-        ("ugd_iface_index", ctypes.c_uint8),
-        ("ugd_altif_index", ctypes.c_uint8),
-        ("ugd_endpt_index", ctypes.c_uint8),
-        ("ugd_report_type", ctypes.c_uint8),
-        ("reserved", ctypes.c_uint8 * 8),
-    ]
-
-
-class UhidConnection(OtpConnection):
-    """
-    uhid(4) is FreeBSD's classic USB hid access driver and enabled
-    by default in FreeBSD 13.x and earlier.
-    """
-
-    def __init__(self, path):
-        self.fd = os.open(path, os.O_RDWR)
-
-    def close(self):
-        os.close(self.fd)
-
-    def receive(self):
-        buf = ctypes.create_string_buffer(9)
-        desc = usb_gen_descriptor(
-            ugd_data=ctypes.addressof(buf),
-            ugd_maxlen=ctypes.sizeof(buf),
-            ugd_report_type=3,
-        )
-        ret = libc.ioctl(self.fd, USB_GET_REPORT, ctypes.pointer(desc))
-        if ret != 0:
-            raise ValueError("ioctl failed: " + str(ret))
-        return buf[:-1]
-
-    def send(self, data):
-        buf = ctypes.create_string_buffer(8)
-        for i in range(0, len(data)):
-            buf[i] = data[i]
-
-        desc = usb_gen_descriptor(
-            ugd_data=ctypes.addressof(buf),
-            ugd_maxlen=len(buf),
-            ugd_report_type=0x3,
-        )
-        ret = libc.ioctl(self.fd, USB_SET_REPORT, ctypes.pointer(desc))
-        if ret != 0:
-            raise ValueError("ioctl failed: " + str(ret))
-
-    @staticmethod
-    def get_usage(dev):
-        c_data = ctypes.create_string_buffer(4096)
-        desc = usb_gen_descriptor(
-            ugd_data=ctypes.addressof(c_data),
-            ugd_maxlen=ctypes.sizeof(c_data),
-            ugd_report_type=3,
-        )
-        ret = libc.ioctl(dev, USB_GET_REPORT_DESC, ctypes.pointer(desc))
-        if ret != 0:
-            raise ValueError("ioctl failed")
-
-        REPORT_DESCRIPTOR_KEY_MASK = 0xFC
-        SIZE_MASK = ~REPORT_DESCRIPTOR_KEY_MASK
-        USAGE_PAGE = 0x04
-        USAGE = 0x08
-
-        data = c_data.raw
-        usage, usage_page = (None, None)
-        while data and not (usage and usage_page):
-            head, data = struct.unpack_from(">B", data)[0], data[1:]
-            key, size = REPORT_DESCRIPTOR_KEY_MASK & head, SIZE_MASK & head
-            value = struct.unpack_from("<I", data[:size].ljust(4, b"\0"))[0]
-            data = data[size:]
-            if key == USAGE_PAGE and not usage_page:
-                usage_page = value
-            elif key == USAGE and not usage:
-                usage = value
-
-        return (usage_page, usage)
-
-    @staticmethod
-    def get_info(index):
-        vendor_re = re.compile("vendor=(0x[0-9a-fA-F]+)")
-        product_re = re.compile("product=(0x[0-9a-fA-F]+)")
-        sernum_re = re.compile('sernum="([^"]+)')
-
-        pnpinfo = ("dev.uhid." + index + ".%pnpinfo").encode()
-
-        ovalue = ctypes.create_string_buffer(1024)
-        olen = ctypes.c_size_t(ctypes.sizeof(ovalue))
-        key = ctypes.c_char_p(pnpinfo)
-        retval = libc.sysctlbyname(key, ovalue, ctypes.byref(olen), None, None)
-        if retval != 0:
-            raise IOError("sysctlbyname failed")
-
-        value = ovalue.value[: olen.value].decode()
-        m = vendor_re.search(value)
-        vid = int(m.group(1), 16) if m else None
-        m = product_re.search(value)
-        pid = int(m.group(1), 16) if m else None
-        m = sernum_re.search(value)
-        serial = m.group(1) if m else None
-        return (vid, pid, serial)
-
-    @staticmethod
-    def list_devices():
-        devices = []
-        for uhid in glob.glob(devdir + "uhid?*"):
-            index = uhid[len(devdir) + len("uhid") :]
-            if not index.isdigit():
-                continue
-
-            try:
-                (vid, pid, serial) = UhidConnection.get_info(index)
-                if vid == YUBICO_VID:
-                    with open(uhid, "rb") as f:
-                        if UhidConnection.get_usage(f.fileno()) == USAGE_OTP:
-                            devices.append(OtpYubiKeyDevice(uhid, pid, UhidConnection))
-            except Exception as e:
-                logger.debug("Failed opening HID device", exc_info=e)
-                continue
-        return devices
-
-
-def list_devices():
-    devices = HidrawConnection.list_devices()
-    if not devices:
-        devices = UhidConnection.list_devices()
-    return devices
+# Original work Copyright 2016 Google Inc. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Modified work Copyright 2022 Michael Gmelin. All Rights Reserved.
+# This file, with modifications, is licensed under the above Apache License.
+#
+# Modified work Copyright 2022 Yubico AB. All Rights Reserved.
+# This file, with modifications, is licensed under the above Apache License.
+
+# FreeBSD HID driver.
+#
+# There are two options to access UHID on FreeBSD:
+#
+# hidraw(4) - New method, not enabled by default
+#             on FreeBSD 13.x and earlier
+# uhid(4) - Classic method, default option on
+#           FreeBSD 13.x and earlier
+#
+# To avoid attaching the Yubikey as a keyboard, do:
+#
+#     usbconfig ugenX.Y add_quirk UQ_KBD_IGNORE
+#     usbconfig ugenX.Y reset
+#
+# The list of available devices is shown using `usbconfig list`
+# You can make these changes permanent by altering loader.conf.
+#
+# Starting from FreeBSD 13 hidraw(4) can be enabled using:
+#
+#     sysrc kld_list+="hidraw hkbd"
+#     cat >>/boot/loader.conf<<EOF
+#     hw.usb.usbhid.enable="1"
+#     hw.usb.quirk.0="0x1050 0x0010 0 0xffff UQ_KBD_IGNORE"  # YKS_OTP
+#     hw.usb.quirk.1="0x1050 0x0110 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP
+#     hw.usb.quirk.2="0x1050 0x0111 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_CCID
+#     hw.usb.quirk.3="0x1050 0x0114 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO
+#     hw.usb.quirk.4="0x1050 0x0116 0 0xffff UQ_KBD_IGNORE"  # NEO_OTP_FIDO_CCID
+#     hw.usb.quirk.5="0x1050 0x0401 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP
+#     hw.usb.quirk.6="0x1050 0x0403 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO
+#     hw.usb.quirk.7="0x1050 0x0405 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_CCID
+#     hw.usb.quirk.8="0x1050 0x0407 0 0xffff UQ_KBD_IGNORE"  # YK4_OTP_FIDO_CCID
+#     hw.usb.quirk.9="0x1050 0x0410 0 0xffff UQ_KBD_IGNORE"  # YKP_OTP_FIDO
+#     EOF
+#     reboot
+#
+from yubikit.core.otp import OtpConnection
+from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
+
+from ctypes.util import find_library
+import ctypes
+
+import glob
+import fcntl
+import os
+import re
+import sys
+import struct
+import logging
+
+# Don't typecheck this file on Windows
+assert sys.platform != "win32"  # nosec
+
+logger = logging.getLogger(__name__)
+
+devdir = "/dev/"
+
+# /usr/include/dev/usb/usb_ioctl.h
+USB_GET_REPORT = 0xC0205517
+USB_SET_REPORT = 0x80205518
+USB_GET_REPORT_DESC = 0xC0205515
+
+# /usr/include/dev/hid/hidraw.h>
+HIDIOCGRAWINFO = 0x40085520
+HIDIOCGRDESC = 0x2000551F
+HIDIOCGRDESCSIZE = 0x4004551E
+HIDIOCGFEATURE_9 = 0xC0095524
+HIDIOCSFEATURE_9 = 0x80095523
+
+
+class HidrawConnection(OtpConnection):
+    """
+    hidraw(4) is FreeBSD's modern raw access driver, based on usbhid(4).
+    It is available since FreeBSD 13 and can be activated by adding
+    `hw.usb.usbhid.enable="1"` to `/boot/loader.conf`. The actual kernel
+    module is loaded with `kldload hidraw`.
+    """
+
+    def __init__(self, path):
+        self.fd = os.open(path, os.O_RDWR)
+
+    def close(self):
+        os.close(self.fd)
+
+    def receive(self):
+        buf = bytearray(1 + 8)
+        fcntl.ioctl(self.fd, HIDIOCGFEATURE_9, buf, True)
+        return buf[1:]
+
+    def send(self, data):
+        buf = bytes([0]) + data
+        fcntl.ioctl(self.fd, HIDIOCSFEATURE_9, buf)
+
+    @staticmethod
+    def get_info(dev):
+        buf = bytearray(4 + 2 + 2)
+        fcntl.ioctl(dev, HIDIOCGRAWINFO, buf, True)
+        return struct.unpack("<IHH", buf)
+
+    @staticmethod
+    def get_descriptor(dev):
+        buf = bytearray(4)
+        fcntl.ioctl(dev, HIDIOCGRDESCSIZE, buf, True)
+        size = struct.unpack("<I", buf)[0]
+        buf += bytearray(size)
+        fcntl.ioctl(dev, HIDIOCGRDESC, buf, True)
+        return buf[4:]
+
+    @staticmethod
+    def get_usage(dev):
+        buf = HidrawConnection.get_descriptor(dev)
+        usage, usage_page = (None, None)
+        while buf:
+            head, buf = buf[0], buf[1:]
+            typ, size = 0xFC & head, 0x03 & head
+            value, buf = buf[:size], buf[size:]
+            if typ == 4:  # Usage page
+                usage_page = struct.unpack("<I", value.ljust(4, b"\0"))[0]
+                if usage is not None:
+                    return usage_page, usage
+            elif typ == 8:  # Usage
+                usage = struct.unpack("<I", value.ljust(4, b"\0"))[0]
+                if usage_page is not None:
+                    return usage_page, usage
+
+    @staticmethod
+    def list_devices():
+        devices = []
+        for hidraw in glob.glob(devdir + "hidraw?*"):
+            try:
+                with open(hidraw, "rb") as f:
+                    bustype, vid, pid = HidrawConnection.get_info(f)
+                    if vid == YUBICO_VID and HidrawConnection.get_usage(f) == USAGE_OTP:
+                        devices.append(OtpYubiKeyDevice(hidraw, pid, HidrawConnection))
+            except Exception as e:
+                logger.debug("Failed opening HID device", exc_info=e)
+                continue
+        return devices
+
+
+# For UhidConnection
+libc = ctypes.CDLL(find_library("c"))
+
+
+class usb_gen_descriptor(ctypes.Structure):
+    _fields_ = [
+        (
+            "ugd_data",
+            ctypes.c_void_p,
+        ),
+        ("ugd_lang_id", ctypes.c_uint16),
+        ("ugd_maxlen", ctypes.c_uint16),
+        ("ugd_actlen", ctypes.c_uint16),
+        ("ugd_offset", ctypes.c_uint16),
+        ("ugd_config_index", ctypes.c_uint8),
+        ("ugd_string_index", ctypes.c_uint8),
+        ("ugd_iface_index", ctypes.c_uint8),
+        ("ugd_altif_index", ctypes.c_uint8),
+        ("ugd_endpt_index", ctypes.c_uint8),
+        ("ugd_report_type", ctypes.c_uint8),
+        ("reserved", ctypes.c_uint8 * 8),
+    ]
+
+
+class UhidConnection(OtpConnection):
+    """
+    uhid(4) is FreeBSD's classic USB hid access driver and enabled
+    by default in FreeBSD 13.x and earlier.
+    """
+
+    def __init__(self, path):
+        self.fd = os.open(path, os.O_RDWR)
+
+    def close(self):
+        os.close(self.fd)
+
+    def receive(self):
+        buf = ctypes.create_string_buffer(9)
+        desc = usb_gen_descriptor(
+            ugd_data=ctypes.addressof(buf),
+            ugd_maxlen=ctypes.sizeof(buf),
+            ugd_report_type=3,
+        )
+        ret = libc.ioctl(self.fd, USB_GET_REPORT, ctypes.pointer(desc))
+        if ret != 0:
+            raise ValueError("ioctl failed: " + str(ret))
+        return buf[:-1]
+
+    def send(self, data):
+        buf = ctypes.create_string_buffer(8)
+        for i in range(0, len(data)):
+            buf[i] = data[i]
+
+        desc = usb_gen_descriptor(
+            ugd_data=ctypes.addressof(buf),
+            ugd_maxlen=len(buf),
+            ugd_report_type=0x3,
+        )
+        ret = libc.ioctl(self.fd, USB_SET_REPORT, ctypes.pointer(desc))
+        if ret != 0:
+            raise ValueError("ioctl failed: " + str(ret))
+
+    @staticmethod
+    def get_usage(dev):
+        c_data = ctypes.create_string_buffer(4096)
+        desc = usb_gen_descriptor(
+            ugd_data=ctypes.addressof(c_data),
+            ugd_maxlen=ctypes.sizeof(c_data),
+            ugd_report_type=3,
+        )
+        ret = libc.ioctl(dev, USB_GET_REPORT_DESC, ctypes.pointer(desc))
+        if ret != 0:
+            raise ValueError("ioctl failed")
+
+        REPORT_DESCRIPTOR_KEY_MASK = 0xFC
+        SIZE_MASK = ~REPORT_DESCRIPTOR_KEY_MASK
+        USAGE_PAGE = 0x04
+        USAGE = 0x08
+
+        data = c_data.raw
+        usage, usage_page = (None, None)
+        while data and not (usage and usage_page):
+            head, data = struct.unpack_from(">B", data)[0], data[1:]
+            key, size = REPORT_DESCRIPTOR_KEY_MASK & head, SIZE_MASK & head
+            value = struct.unpack_from("<I", data[:size].ljust(4, b"\0"))[0]
+            data = data[size:]
+            if key == USAGE_PAGE and not usage_page:
+                usage_page = value
+            elif key == USAGE and not usage:
+                usage = value
+
+        return (usage_page, usage)
+
+    @staticmethod
+    def get_info(index):
+        vendor_re = re.compile("vendor=(0x[0-9a-fA-F]+)")
+        product_re = re.compile("product=(0x[0-9a-fA-F]+)")
+        sernum_re = re.compile('sernum="([^"]+)')
+
+        pnpinfo = ("dev.uhid." + index + ".%pnpinfo").encode()
+
+        ovalue = ctypes.create_string_buffer(1024)
+        olen = ctypes.c_size_t(ctypes.sizeof(ovalue))
+        key = ctypes.c_char_p(pnpinfo)
+        retval = libc.sysctlbyname(key, ovalue, ctypes.byref(olen), None, None)
+        if retval != 0:
+            raise IOError("sysctlbyname failed")
+
+        value = ovalue.value[: olen.value].decode()
+        m = vendor_re.search(value)
+        vid = int(m.group(1), 16) if m else None
+        m = product_re.search(value)
+        pid = int(m.group(1), 16) if m else None
+        m = sernum_re.search(value)
+        serial = m.group(1) if m else None
+        return (vid, pid, serial)
+
+    @staticmethod
+    def list_devices():
+        devices = []
+        for uhid in glob.glob(devdir + "uhid?*"):
+            index = uhid[len(devdir) + len("uhid") :]
+            if not index.isdigit():
+                continue
+
+            try:
+                (vid, pid, serial) = UhidConnection.get_info(index)
+                if vid == YUBICO_VID:
+                    with open(uhid, "rb") as f:
+                        if UhidConnection.get_usage(f.fileno()) == USAGE_OTP:
+                            devices.append(OtpYubiKeyDevice(uhid, pid, UhidConnection))
+            except Exception as e:
+                logger.debug("Failed opening HID device", exc_info=e)
+                continue
+        return devices
+
+
+def list_devices():
+    devices = HidrawConnection.list_devices()
+    if not devices:
+        devices = UhidConnection.list_devices()
+    return devices
```

### Comparing `yubikey_manager-5.1.0/ykman/hid/macos.py` & `yubikey_manager-5.1.1/ykman/hid/macos.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,303 +1,303 @@
-# Original work Copyright 2016 Google Inc. All Rights Reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# Modified work Copyright 2020 Yubico AB. All Rights Reserved.
-# This file, with modifications, is licensed under the above Apache License.
-
-from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
-from yubikit.core.otp import OtpConnection
-from yubikit.logging import LOG_LEVEL
-
-import ctypes
-import ctypes.util
-import logging
-
-logger = logging.getLogger(__name__)
-
-# Constants
-
-HID_DEVICE_PROPERTY_VENDOR_ID = b"VendorID"
-HID_DEVICE_PROPERTY_PRODUCT_ID = b"ProductID"
-HID_DEVICE_PROPERTY_PRODUCT = b"Product"
-HID_DEVICE_PROPERTY_PRIMARY_USAGE = b"PrimaryUsage"
-HID_DEVICE_PROPERTY_PRIMARY_USAGE_PAGE = b"PrimaryUsagePage"
-HID_DEVICE_PROPERTY_MAX_INPUT_REPORT_SIZE = b"MaxInputReportSize"
-HID_DEVICE_PROPERTY_MAX_OUTPUT_REPORT_SIZE = b"MaxOutputReportSize"
-HID_DEVICE_PROPERTY_REPORT_ID = b"ReportID"
-
-
-# Declare C types
-class _CFType(ctypes.Structure):
-    pass
-
-
-class _CFString(_CFType):
-    pass
-
-
-class _CFSet(_CFType):
-    pass
-
-
-class _IOHIDManager(_CFType):
-    pass
-
-
-class _IOHIDDevice(_CFType):
-    pass
-
-
-class _CFAllocator(_CFType):
-    pass
-
-
-CF_SET_REF = ctypes.POINTER(_CFSet)
-CF_STRING_REF = ctypes.POINTER(_CFString)
-CF_TYPE_REF = ctypes.POINTER(_CFType)
-CF_ALLOCATOR_REF = ctypes.POINTER(_CFAllocator)
-CF_DICTIONARY_REF = ctypes.c_void_p
-CF_MUTABLE_DICTIONARY_REF = ctypes.c_void_p
-CF_TYPE_ID = ctypes.c_ulong
-CF_INDEX = ctypes.c_long
-CF_TIME_INTERVAL = ctypes.c_double
-IO_RETURN = ctypes.c_uint
-IO_HID_REPORT_TYPE = ctypes.c_uint
-IO_OPTION_BITS = ctypes.c_uint
-IO_OBJECT_T = ctypes.c_uint
-MACH_PORT_T = ctypes.c_uint
-IO_SERVICE_T = IO_OBJECT_T
-IO_REGISTRY_ENTRY_T = IO_OBJECT_T
-
-IO_HID_MANAGER_REF = ctypes.POINTER(_IOHIDManager)
-IO_HID_DEVICE_REF = ctypes.POINTER(_IOHIDDevice)
-
-# Define C constants
-K_CF_NUMBER_SINT32_TYPE = 3
-K_CF_ALLOCATOR_DEFAULT = None
-
-K_IO_MASTER_PORT_DEFAULT = 0
-K_IO_HID_REPORT_TYPE_FEATURE = 2
-K_IO_RETURN_SUCCESS = 0
-
-# NOTE: find_library doesn't currently work on Big Sur, requiring the hardcoded paths
-iokit = ctypes.cdll.LoadLibrary(
-    ctypes.util.find_library("IOKit")
-    or "/System/Library/Frameworks/IOKit.framework/IOKit"
-)
-cf = ctypes.cdll.LoadLibrary(
-    ctypes.util.find_library("CoreFoundation")
-    or "/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation"
-)
-
-
-# Declare C function prototypes
-cf.CFSetGetValues.restype = None
-cf.CFSetGetValues.argtypes = [CF_SET_REF, ctypes.POINTER(ctypes.c_void_p)]
-cf.CFStringCreateWithCString.restype = CF_STRING_REF
-cf.CFStringCreateWithCString.argtypes = [
-    ctypes.c_void_p,
-    ctypes.c_char_p,
-    ctypes.c_uint32,
-]
-cf.CFGetTypeID.restype = CF_TYPE_ID
-cf.CFGetTypeID.argtypes = [CF_TYPE_REF]
-cf.CFNumberGetTypeID.restype = CF_TYPE_ID
-cf.CFNumberGetValue.restype = ctypes.c_int
-cf.CFRelease.restype = IO_RETURN
-cf.CFRelease.argtypes = [CF_TYPE_REF]
-
-iokit.IOObjectRelease.argtypes = [IO_OBJECT_T]
-
-iokit.IOHIDManagerCreate.restype = IO_HID_MANAGER_REF
-iokit.IOHIDManagerCreate.argtypes = [CF_ALLOCATOR_REF, IO_OPTION_BITS]
-iokit.IOHIDManagerCopyDevices.restype = CF_SET_REF
-iokit.IOHIDManagerCopyDevices.argtypes = [IO_HID_MANAGER_REF]
-iokit.IOHIDManagerSetDeviceMatching.restype = None
-iokit.IOHIDManagerSetDeviceMatching.argtypes = [IO_HID_MANAGER_REF, CF_TYPE_REF]
-
-iokit.IORegistryEntryIDMatching.restype = CF_MUTABLE_DICTIONARY_REF
-iokit.IORegistryEntryIDMatching.argtypes = [ctypes.c_uint64]
-iokit.IORegistryEntryGetRegistryEntryID.restype = IO_RETURN
-iokit.IORegistryEntryGetRegistryEntryID.argtypes = [
-    IO_REGISTRY_ENTRY_T,
-    ctypes.POINTER(ctypes.c_uint64),
-]
-
-iokit.IOHIDDeviceCreate.restype = IO_HID_DEVICE_REF
-iokit.IOHIDDeviceCreate.argtypes = [CF_ALLOCATOR_REF, IO_SERVICE_T]
-iokit.IOHIDDeviceClose.restype = IO_RETURN
-iokit.IOHIDDeviceClose.argtypes = [IO_HID_DEVICE_REF, ctypes.c_uint32]
-iokit.IOHIDDeviceGetProperty.restype = CF_TYPE_REF
-iokit.IOHIDDeviceGetProperty.argtypes = [IO_HID_DEVICE_REF, CF_STRING_REF]
-iokit.IOHIDDeviceSetReport.restype = IO_RETURN
-iokit.IOHIDDeviceSetReport.argtypes = [
-    IO_HID_DEVICE_REF,
-    IO_HID_REPORT_TYPE,
-    CF_INDEX,
-    ctypes.c_void_p,
-    CF_INDEX,
-]
-iokit.IOHIDDeviceGetReport.restype = IO_RETURN
-iokit.IOHIDDeviceGetReport.argtypes = [
-    IO_HID_DEVICE_REF,
-    IO_HID_REPORT_TYPE,
-    CF_INDEX,
-    ctypes.c_void_p,
-    ctypes.POINTER(CF_INDEX),
-]
-
-iokit.IOServiceGetMatchingService.restype = IO_SERVICE_T
-iokit.IOServiceGetMatchingService.argtypes = [MACH_PORT_T, CF_DICTIONARY_REF]
-
-
-class MacHidOtpConnection(OtpConnection):
-    def __init__(self, path):
-        # Resolve the path to device handle
-        device_id = int(path)
-        entry_id = ctypes.c_uint64(device_id)
-        matching_dict = iokit.IORegistryEntryIDMatching(entry_id)
-        device_entry = iokit.IOServiceGetMatchingService(
-            K_IO_MASTER_PORT_DEFAULT, matching_dict
-        )
-        if not device_entry:
-            raise OSError(
-                f"Device ID {device_id} does not match any HID device on the system"
-            )
-
-        self.handle = iokit.IOHIDDeviceCreate(K_CF_ALLOCATOR_DEFAULT, device_entry)
-        if not self.handle:
-            raise OSError("Failed to obtain device handle from registry entry")
-        iokit.IOObjectRelease(device_entry)
-
-        # Open device
-        result = iokit.IOHIDDeviceOpen(self.handle, 0)
-        if result != K_IO_RETURN_SUCCESS:
-            raise OSError(f"Failed to open device for communication: {result}")
-
-    def close(self):
-        if self.handle:
-            iokit.IOHIDDeviceClose(self.handle, 0)
-            self.handle = None
-
-    def receive(self):
-        buf = ctypes.create_string_buffer(8)
-        report_len = CF_INDEX(ctypes.sizeof(buf))
-
-        result = iokit.IOHIDDeviceGetReport(
-            self.handle,
-            K_IO_HID_REPORT_TYPE_FEATURE,
-            0,
-            buf,
-            ctypes.byref(report_len),
-        )
-
-        # Non-zero status indicates failure
-        if result != K_IO_RETURN_SUCCESS:
-            raise OSError(f"Failed to read report from device: {result}")
-
-        data = buf.raw[:]
-        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", data.hex())
-        return data
-
-    def send(self, data):
-        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", data.hex())
-        result = iokit.IOHIDDeviceSetReport(
-            self.handle,
-            K_IO_HID_REPORT_TYPE_FEATURE,
-            0,
-            data,
-            len(data),
-        )
-
-        # Non-zero status indicates failure
-        if result != K_IO_RETURN_SUCCESS:
-            raise OSError(f"Failed to write report to device: {result}")
-
-
-def get_int_property(dev, key):
-    """Reads int property from the HID device."""
-    cf_key = cf.CFStringCreateWithCString(None, key, 0)
-    type_ref = iokit.IOHIDDeviceGetProperty(dev, cf_key)
-    cf.CFRelease(cf_key)
-    if not type_ref:
-        return None
-
-    if cf.CFGetTypeID(type_ref) != cf.CFNumberGetTypeID():
-        raise OSError(f"Expected number type, got {cf.CFGetTypeID(type_ref)}")
-
-    out = ctypes.c_int32()
-    ret = cf.CFNumberGetValue(type_ref, K_CF_NUMBER_SINT32_TYPE, ctypes.byref(out))
-    if not ret:
-        return None
-
-    return out.value
-
-
-def get_device_id(device_handle):
-    """Obtains the unique IORegistry entry ID for the device.
-
-    Args:
-    device_handle: reference to the device
-
-    Returns:
-    A unique ID for the device, obtained from the IO Registry
-    """
-    # Obtain device entry ID from IO Registry
-    io_service_obj = iokit.IOHIDDeviceGetService(device_handle)
-    entry_id = ctypes.c_uint64()
-    result = iokit.IORegistryEntryGetRegistryEntryID(
-        io_service_obj, ctypes.byref(entry_id)
-    )
-    if result != K_IO_RETURN_SUCCESS:
-        raise OSError(f"Failed to obtain IORegistry entry ID: {result}")
-
-    return entry_id.value
-
-
-def list_devices():
-    # Init a HID manager
-    hid_mgr = iokit.IOHIDManagerCreate(None, 0)
-    if not hid_mgr:
-        raise OSError("Unable to obtain HID manager reference")
-    try:
-        # Get devices from HID manager
-        iokit.IOHIDManagerSetDeviceMatching(hid_mgr, None)
-        device_set_ref = iokit.IOHIDManagerCopyDevices(hid_mgr)
-        if not device_set_ref:
-            raise OSError("Failed to obtain devices from HID manager")
-        try:
-            num = iokit.CFSetGetCount(device_set_ref)
-            devices = (IO_HID_DEVICE_REF * num)()
-            iokit.CFSetGetValues(device_set_ref, devices)
-
-            # Retrieve and build descriptor dictionaries for each device
-            devs = []
-            for dev in devices:
-                vid = get_int_property(dev, HID_DEVICE_PROPERTY_VENDOR_ID)
-                if vid == YUBICO_VID:
-                    pid = get_int_property(dev, HID_DEVICE_PROPERTY_PRODUCT_ID)
-                    usage = (
-                        get_int_property(dev, HID_DEVICE_PROPERTY_PRIMARY_USAGE_PAGE),
-                        get_int_property(dev, HID_DEVICE_PROPERTY_PRIMARY_USAGE),
-                    )
-                    device_id = get_device_id(dev)
-                    if usage == USAGE_OTP:
-                        devs.append(
-                            OtpYubiKeyDevice(str(device_id), pid, MacHidOtpConnection)
-                        )
-            return devs
-        finally:
-            cf.CFRelease(device_set_ref)
-    finally:
-        cf.CFRelease(hid_mgr)
+# Original work Copyright 2016 Google Inc. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Modified work Copyright 2020 Yubico AB. All Rights Reserved.
+# This file, with modifications, is licensed under the above Apache License.
+
+from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
+from yubikit.core.otp import OtpConnection
+from yubikit.logging import LOG_LEVEL
+
+import ctypes
+import ctypes.util
+import logging
+
+logger = logging.getLogger(__name__)
+
+# Constants
+
+HID_DEVICE_PROPERTY_VENDOR_ID = b"VendorID"
+HID_DEVICE_PROPERTY_PRODUCT_ID = b"ProductID"
+HID_DEVICE_PROPERTY_PRODUCT = b"Product"
+HID_DEVICE_PROPERTY_PRIMARY_USAGE = b"PrimaryUsage"
+HID_DEVICE_PROPERTY_PRIMARY_USAGE_PAGE = b"PrimaryUsagePage"
+HID_DEVICE_PROPERTY_MAX_INPUT_REPORT_SIZE = b"MaxInputReportSize"
+HID_DEVICE_PROPERTY_MAX_OUTPUT_REPORT_SIZE = b"MaxOutputReportSize"
+HID_DEVICE_PROPERTY_REPORT_ID = b"ReportID"
+
+
+# Declare C types
+class _CFType(ctypes.Structure):
+    pass
+
+
+class _CFString(_CFType):
+    pass
+
+
+class _CFSet(_CFType):
+    pass
+
+
+class _IOHIDManager(_CFType):
+    pass
+
+
+class _IOHIDDevice(_CFType):
+    pass
+
+
+class _CFAllocator(_CFType):
+    pass
+
+
+CF_SET_REF = ctypes.POINTER(_CFSet)
+CF_STRING_REF = ctypes.POINTER(_CFString)
+CF_TYPE_REF = ctypes.POINTER(_CFType)
+CF_ALLOCATOR_REF = ctypes.POINTER(_CFAllocator)
+CF_DICTIONARY_REF = ctypes.c_void_p
+CF_MUTABLE_DICTIONARY_REF = ctypes.c_void_p
+CF_TYPE_ID = ctypes.c_ulong
+CF_INDEX = ctypes.c_long
+CF_TIME_INTERVAL = ctypes.c_double
+IO_RETURN = ctypes.c_uint
+IO_HID_REPORT_TYPE = ctypes.c_uint
+IO_OPTION_BITS = ctypes.c_uint
+IO_OBJECT_T = ctypes.c_uint
+MACH_PORT_T = ctypes.c_uint
+IO_SERVICE_T = IO_OBJECT_T
+IO_REGISTRY_ENTRY_T = IO_OBJECT_T
+
+IO_HID_MANAGER_REF = ctypes.POINTER(_IOHIDManager)
+IO_HID_DEVICE_REF = ctypes.POINTER(_IOHIDDevice)
+
+# Define C constants
+K_CF_NUMBER_SINT32_TYPE = 3
+K_CF_ALLOCATOR_DEFAULT = None
+
+K_IO_MASTER_PORT_DEFAULT = 0
+K_IO_HID_REPORT_TYPE_FEATURE = 2
+K_IO_RETURN_SUCCESS = 0
+
+# NOTE: find_library doesn't currently work on Big Sur, requiring the hardcoded paths
+iokit = ctypes.cdll.LoadLibrary(
+    ctypes.util.find_library("IOKit")
+    or "/System/Library/Frameworks/IOKit.framework/IOKit"
+)
+cf = ctypes.cdll.LoadLibrary(
+    ctypes.util.find_library("CoreFoundation")
+    or "/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation"
+)
+
+
+# Declare C function prototypes
+cf.CFSetGetValues.restype = None
+cf.CFSetGetValues.argtypes = [CF_SET_REF, ctypes.POINTER(ctypes.c_void_p)]
+cf.CFStringCreateWithCString.restype = CF_STRING_REF
+cf.CFStringCreateWithCString.argtypes = [
+    ctypes.c_void_p,
+    ctypes.c_char_p,
+    ctypes.c_uint32,
+]
+cf.CFGetTypeID.restype = CF_TYPE_ID
+cf.CFGetTypeID.argtypes = [CF_TYPE_REF]
+cf.CFNumberGetTypeID.restype = CF_TYPE_ID
+cf.CFNumberGetValue.restype = ctypes.c_int
+cf.CFRelease.restype = IO_RETURN
+cf.CFRelease.argtypes = [CF_TYPE_REF]
+
+iokit.IOObjectRelease.argtypes = [IO_OBJECT_T]
+
+iokit.IOHIDManagerCreate.restype = IO_HID_MANAGER_REF
+iokit.IOHIDManagerCreate.argtypes = [CF_ALLOCATOR_REF, IO_OPTION_BITS]
+iokit.IOHIDManagerCopyDevices.restype = CF_SET_REF
+iokit.IOHIDManagerCopyDevices.argtypes = [IO_HID_MANAGER_REF]
+iokit.IOHIDManagerSetDeviceMatching.restype = None
+iokit.IOHIDManagerSetDeviceMatching.argtypes = [IO_HID_MANAGER_REF, CF_TYPE_REF]
+
+iokit.IORegistryEntryIDMatching.restype = CF_MUTABLE_DICTIONARY_REF
+iokit.IORegistryEntryIDMatching.argtypes = [ctypes.c_uint64]
+iokit.IORegistryEntryGetRegistryEntryID.restype = IO_RETURN
+iokit.IORegistryEntryGetRegistryEntryID.argtypes = [
+    IO_REGISTRY_ENTRY_T,
+    ctypes.POINTER(ctypes.c_uint64),
+]
+
+iokit.IOHIDDeviceCreate.restype = IO_HID_DEVICE_REF
+iokit.IOHIDDeviceCreate.argtypes = [CF_ALLOCATOR_REF, IO_SERVICE_T]
+iokit.IOHIDDeviceClose.restype = IO_RETURN
+iokit.IOHIDDeviceClose.argtypes = [IO_HID_DEVICE_REF, ctypes.c_uint32]
+iokit.IOHIDDeviceGetProperty.restype = CF_TYPE_REF
+iokit.IOHIDDeviceGetProperty.argtypes = [IO_HID_DEVICE_REF, CF_STRING_REF]
+iokit.IOHIDDeviceSetReport.restype = IO_RETURN
+iokit.IOHIDDeviceSetReport.argtypes = [
+    IO_HID_DEVICE_REF,
+    IO_HID_REPORT_TYPE,
+    CF_INDEX,
+    ctypes.c_void_p,
+    CF_INDEX,
+]
+iokit.IOHIDDeviceGetReport.restype = IO_RETURN
+iokit.IOHIDDeviceGetReport.argtypes = [
+    IO_HID_DEVICE_REF,
+    IO_HID_REPORT_TYPE,
+    CF_INDEX,
+    ctypes.c_void_p,
+    ctypes.POINTER(CF_INDEX),
+]
+
+iokit.IOServiceGetMatchingService.restype = IO_SERVICE_T
+iokit.IOServiceGetMatchingService.argtypes = [MACH_PORT_T, CF_DICTIONARY_REF]
+
+
+class MacHidOtpConnection(OtpConnection):
+    def __init__(self, path):
+        # Resolve the path to device handle
+        device_id = int(path)
+        entry_id = ctypes.c_uint64(device_id)
+        matching_dict = iokit.IORegistryEntryIDMatching(entry_id)
+        device_entry = iokit.IOServiceGetMatchingService(
+            K_IO_MASTER_PORT_DEFAULT, matching_dict
+        )
+        if not device_entry:
+            raise OSError(
+                f"Device ID {device_id} does not match any HID device on the system"
+            )
+
+        self.handle = iokit.IOHIDDeviceCreate(K_CF_ALLOCATOR_DEFAULT, device_entry)
+        if not self.handle:
+            raise OSError("Failed to obtain device handle from registry entry")
+        iokit.IOObjectRelease(device_entry)
+
+        # Open device
+        result = iokit.IOHIDDeviceOpen(self.handle, 0)
+        if result != K_IO_RETURN_SUCCESS:
+            raise OSError(f"Failed to open device for communication: {result}")
+
+    def close(self):
+        if self.handle:
+            iokit.IOHIDDeviceClose(self.handle, 0)
+            self.handle = None
+
+    def receive(self):
+        buf = ctypes.create_string_buffer(8)
+        report_len = CF_INDEX(ctypes.sizeof(buf))
+
+        result = iokit.IOHIDDeviceGetReport(
+            self.handle,
+            K_IO_HID_REPORT_TYPE_FEATURE,
+            0,
+            buf,
+            ctypes.byref(report_len),
+        )
+
+        # Non-zero status indicates failure
+        if result != K_IO_RETURN_SUCCESS:
+            raise OSError(f"Failed to read report from device: {result}")
+
+        data = buf.raw[:]
+        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", data.hex())
+        return data
+
+    def send(self, data):
+        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", data.hex())
+        result = iokit.IOHIDDeviceSetReport(
+            self.handle,
+            K_IO_HID_REPORT_TYPE_FEATURE,
+            0,
+            data,
+            len(data),
+        )
+
+        # Non-zero status indicates failure
+        if result != K_IO_RETURN_SUCCESS:
+            raise OSError(f"Failed to write report to device: {result}")
+
+
+def get_int_property(dev, key):
+    """Reads int property from the HID device."""
+    cf_key = cf.CFStringCreateWithCString(None, key, 0)
+    type_ref = iokit.IOHIDDeviceGetProperty(dev, cf_key)
+    cf.CFRelease(cf_key)
+    if not type_ref:
+        return None
+
+    if cf.CFGetTypeID(type_ref) != cf.CFNumberGetTypeID():
+        raise OSError(f"Expected number type, got {cf.CFGetTypeID(type_ref)}")
+
+    out = ctypes.c_int32()
+    ret = cf.CFNumberGetValue(type_ref, K_CF_NUMBER_SINT32_TYPE, ctypes.byref(out))
+    if not ret:
+        return None
+
+    return out.value
+
+
+def get_device_id(device_handle):
+    """Obtains the unique IORegistry entry ID for the device.
+
+    Args:
+    device_handle: reference to the device
+
+    Returns:
+    A unique ID for the device, obtained from the IO Registry
+    """
+    # Obtain device entry ID from IO Registry
+    io_service_obj = iokit.IOHIDDeviceGetService(device_handle)
+    entry_id = ctypes.c_uint64()
+    result = iokit.IORegistryEntryGetRegistryEntryID(
+        io_service_obj, ctypes.byref(entry_id)
+    )
+    if result != K_IO_RETURN_SUCCESS:
+        raise OSError(f"Failed to obtain IORegistry entry ID: {result}")
+
+    return entry_id.value
+
+
+def list_devices():
+    # Init a HID manager
+    hid_mgr = iokit.IOHIDManagerCreate(None, 0)
+    if not hid_mgr:
+        raise OSError("Unable to obtain HID manager reference")
+    try:
+        # Get devices from HID manager
+        iokit.IOHIDManagerSetDeviceMatching(hid_mgr, None)
+        device_set_ref = iokit.IOHIDManagerCopyDevices(hid_mgr)
+        if not device_set_ref:
+            raise OSError("Failed to obtain devices from HID manager")
+        try:
+            num = iokit.CFSetGetCount(device_set_ref)
+            devices = (IO_HID_DEVICE_REF * num)()
+            iokit.CFSetGetValues(device_set_ref, devices)
+
+            # Retrieve and build descriptor dictionaries for each device
+            devs = []
+            for dev in devices:
+                vid = get_int_property(dev, HID_DEVICE_PROPERTY_VENDOR_ID)
+                if vid == YUBICO_VID:
+                    pid = get_int_property(dev, HID_DEVICE_PROPERTY_PRODUCT_ID)
+                    usage = (
+                        get_int_property(dev, HID_DEVICE_PROPERTY_PRIMARY_USAGE_PAGE),
+                        get_int_property(dev, HID_DEVICE_PROPERTY_PRIMARY_USAGE),
+                    )
+                    device_id = get_device_id(dev)
+                    if usage == USAGE_OTP:
+                        devs.append(
+                            OtpYubiKeyDevice(str(device_id), pid, MacHidOtpConnection)
+                        )
+            return devs
+        finally:
+            cf.CFRelease(device_set_ref)
+    finally:
+        cf.CFRelease(hid_mgr)
```

### Comparing `yubikey_manager-5.1.0/ykman/hid/windows.py` & `yubikey_manager-5.1.1/ykman/hid/windows.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,371 +1,371 @@
-# Original work Copyright 2016 Google Inc. All Rights Reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-# Modified work Copyright 2020 Yubico AB. All Rights Reserved.
-# This file, with modifications, is licensed under the above Apache License.
-
-from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
-from yubikit.core.otp import OtpConnection
-from yubikit.logging import LOG_LEVEL
-
-from ctypes import wintypes, LibraryLoader
-from typing import Dict, cast
-import ctypes
-import platform
-import logging
-import re
-import sys
-
-# Only typecheck this file on Windows
-assert sys.platform == "win32"  # nosec
-from ctypes import WinDLL, WinError  # noqa: E402
-
-logger = logging.getLogger(__name__)
-
-
-# Load relevant DLLs
-windll = LibraryLoader(WinDLL)
-hid = windll.Hid
-setupapi = windll.SetupAPI
-kernel32 = windll.Kernel32
-
-
-# Various structs that are used in the Windows APIs we call
-class GUID(ctypes.Structure):
-    _fields_ = [
-        ("Data1", ctypes.c_ulong),
-        ("Data2", ctypes.c_ushort),
-        ("Data3", ctypes.c_ushort),
-        ("Data4", ctypes.c_ubyte * 8),
-    ]
-
-
-# On Windows, SetupAPI.h packs structures differently in 64bit and
-# 32bit mode.  In 64-bit mode, the structures are packed on 8 byte
-# boundaries, while in 32-bit mode, they are packed on 1 byte boundaries.
-# This is important to get right for some API calls that fill out these
-# structures.
-if platform.architecture()[0] == "64bit":
-    SETUPAPI_PACK = 8
-elif platform.architecture()[0] == "32bit":
-    SETUPAPI_PACK = 1
-else:
-    raise OSError(f"Unknown architecture: {platform.architecture()[0]}")
-
-
-class DeviceInterfaceData(ctypes.Structure):
-    _fields_ = [
-        ("cbSize", wintypes.DWORD),
-        ("InterfaceClassGuid", GUID),
-        ("Flags", wintypes.DWORD),
-        ("Reserved", ctypes.POINTER(ctypes.c_ulong)),
-    ]
-    _pack_ = SETUPAPI_PACK
-
-
-class DeviceInterfaceDetailData(ctypes.Structure):
-    _fields_ = [("cbSize", wintypes.DWORD), ("DevicePath", ctypes.c_byte * 1)]
-    _pack_ = SETUPAPI_PACK
-
-
-class HidAttributes(ctypes.Structure):
-    _fields_ = [
-        ("Size", ctypes.c_ulong),
-        ("VendorID", ctypes.c_ushort),
-        ("ProductID", ctypes.c_ushort),
-        ("VersionNumber", ctypes.c_ushort),
-    ]
-
-
-class HidCapabilities(ctypes.Structure):
-    _fields_ = [
-        ("Usage", ctypes.c_ushort),
-        ("UsagePage", ctypes.c_ushort),
-        ("InputReportByteLength", ctypes.c_ushort),
-        ("OutputReportByteLength", ctypes.c_ushort),
-        ("FeatureReportByteLength", ctypes.c_ushort),
-        ("Reserved", ctypes.c_ushort * 17),
-        ("NotUsed", ctypes.c_ushort * 10),
-    ]
-
-
-# Various void* aliases for readability.
-HDEVINFO = ctypes.c_void_p
-HANDLE = ctypes.c_void_p
-PHIDP_PREPARSED_DATA = ctypes.c_void_p  # pylint: disable=invalid-name
-
-# This is a HANDLE.
-# INVALID_HANDLE_VALUE = 0xFFFFFFFF
-INVALID_HANDLE_VALUE = (1 << 8 * ctypes.sizeof(ctypes.c_void_p)) - 1
-
-# Status codes
-FILE_SHARE_READ = 0x00000001
-FILE_SHARE_WRITE = 0x00000002
-OPEN_EXISTING = 0x03
-NTSTATUS = ctypes.c_long
-HIDP_STATUS_SUCCESS = 0x00110000
-
-# CreateFile Flags
-GENERIC_WRITE = 0x40000000
-GENERIC_READ = 0x80000000
-
-DIGCF_DEVICEINTERFACE = 0x10
-DIGCF_PRESENT = 0x02
-
-# Function signatures
-hid.HidD_GetHidGuid.restype = None
-hid.HidD_GetHidGuid.argtypes = [ctypes.POINTER(GUID)]
-hid.HidD_GetAttributes.restype = wintypes.BOOLEAN
-hid.HidD_GetAttributes.argtypes = [HANDLE, ctypes.POINTER(HidAttributes)]
-hid.HidD_GetPreparsedData.restype = wintypes.BOOLEAN
-hid.HidD_GetPreparsedData.argtypes = [HANDLE, ctypes.POINTER(PHIDP_PREPARSED_DATA)]
-hid.HidD_FreePreparsedData.restype = wintypes.BOOLEAN
-hid.HidD_FreePreparsedData.argtypes = [PHIDP_PREPARSED_DATA]
-hid.HidD_GetProductString.restype = wintypes.BOOLEAN
-hid.HidD_GetProductString.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
-hid.HidP_GetCaps.restype = NTSTATUS
-hid.HidP_GetCaps.argtypes = [PHIDP_PREPARSED_DATA, ctypes.POINTER(HidCapabilities)]
-
-
-hid.HidD_GetFeature.restype = wintypes.BOOL
-hid.HidD_GetFeature.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
-hid.HidD_SetFeature.restype = wintypes.BOOL
-hid.HidD_SetFeature.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
-
-setupapi.SetupDiGetClassDevsA.argtypes = [
-    ctypes.POINTER(GUID),
-    ctypes.c_char_p,
-    wintypes.HWND,
-    wintypes.DWORD,
-]
-setupapi.SetupDiGetClassDevsA.restype = HDEVINFO
-setupapi.SetupDiEnumDeviceInterfaces.restype = wintypes.BOOL
-setupapi.SetupDiEnumDeviceInterfaces.argtypes = [
-    HDEVINFO,
-    ctypes.c_void_p,
-    ctypes.POINTER(GUID),
-    wintypes.DWORD,
-    ctypes.POINTER(DeviceInterfaceData),
-]
-setupapi.SetupDiGetDeviceInterfaceDetailA.restype = wintypes.BOOL
-setupapi.SetupDiGetDeviceInterfaceDetailA.argtypes = [
-    HDEVINFO,
-    ctypes.POINTER(DeviceInterfaceData),
-    ctypes.POINTER(DeviceInterfaceDetailData),
-    wintypes.DWORD,
-    ctypes.POINTER(wintypes.DWORD),
-    ctypes.c_void_p,
-]
-setupapi.SetupDiDestroyDeviceInfoList.restype = wintypes.BOOL
-setupapi.SetupDiDestroyDeviceInfoList.argtypes = [
-    HDEVINFO,
-]
-
-kernel32.CreateFileA.restype = HANDLE
-kernel32.CreateFileA.argtypes = [
-    ctypes.c_char_p,
-    wintypes.DWORD,
-    wintypes.DWORD,
-    ctypes.c_void_p,
-    wintypes.DWORD,
-    wintypes.DWORD,
-    HANDLE,
-]
-kernel32.CloseHandle.restype = wintypes.BOOL
-kernel32.CloseHandle.argtypes = [HANDLE]
-
-
-class WinHidOtpConnection(OtpConnection):
-    def __init__(self, path):
-        self.handle = kernel32.CreateFileA(
-            path,
-            GENERIC_WRITE,
-            FILE_SHARE_READ | FILE_SHARE_WRITE,
-            None,
-            OPEN_EXISTING,
-            0,
-            None,
-        )
-        if self.handle == INVALID_HANDLE_VALUE:
-            raise WinError()
-
-    def close(self):
-        if self.handle:
-            kernel32.CloseHandle(self.handle)
-            self.handle = None
-
-    def receive(self):
-        buf = ctypes.create_string_buffer(9)
-        result = hid.HidD_GetFeature(self.handle, buf, ctypes.sizeof(buf))
-        if not result:
-            raise WinError()
-        data = buf.raw[1:]
-        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", data.hex())
-        return data
-
-    def send(self, data):
-        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", data.hex())
-        buf = ctypes.create_string_buffer(b"\0" + data)
-        result = hid.HidD_SetFeature(self.handle, buf, ctypes.sizeof(buf))
-        if not result:
-            raise WinError()
-
-
-def get_vid_pid(device):
-    attributes = HidAttributes()
-    result = hid.HidD_GetAttributes(device, ctypes.byref(attributes))
-    if not result:
-        raise WinError()
-
-    return attributes.VendorID, attributes.ProductID
-
-
-def get_usage(device):
-    preparsed_data = PHIDP_PREPARSED_DATA(0)
-    ret = hid.HidD_GetPreparsedData(device, ctypes.byref(preparsed_data))
-    if not ret:
-        raise WinError()
-
-    try:
-        caps = HidCapabilities()
-        ret = hid.HidP_GetCaps(preparsed_data, ctypes.byref(caps))
-
-        if ret != HIDP_STATUS_SUCCESS:
-            raise WinError()
-
-        return caps.UsagePage, caps.Usage
-
-    finally:
-        hid.HidD_FreePreparsedData(preparsed_data)
-
-
-VID_RE = re.compile(rb"\Wvid_%04x\W" % YUBICO_VID)
-PID_RE = re.compile(rb"\Wpid_([a-z0-9]{4})\W")
-
-
-def list_paths():
-    hid_guid = GUID()
-    hid.HidD_GetHidGuid(ctypes.byref(hid_guid))
-
-    collection = setupapi.SetupDiGetClassDevsA(
-        ctypes.byref(hid_guid), None, None, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT
-    )
-    try:
-        index = 0
-        interface_info = DeviceInterfaceData()
-        interface_info.cbSize = ctypes.sizeof(DeviceInterfaceData)
-
-        paths = []
-        while True:
-            result = setupapi.SetupDiEnumDeviceInterfaces(
-                collection,
-                0,
-                ctypes.byref(hid_guid),
-                index,
-                ctypes.byref(interface_info),
-            )
-            index += 1
-            if not result:
-                break
-
-            detail_len_dw = wintypes.DWORD()
-            result = setupapi.SetupDiGetDeviceInterfaceDetailA(
-                collection,
-                ctypes.byref(interface_info),
-                None,
-                0,
-                ctypes.byref(detail_len_dw),
-                None,
-            )
-            if result:
-                raise WinError()
-
-            detail_len = detail_len_dw.value
-            if detail_len == 0:
-                # skip this device, some kind of error
-                continue
-
-            buf = ctypes.create_string_buffer(detail_len)
-            interface_detail = DeviceInterfaceDetailData.from_buffer(buf)
-            interface_detail.cbSize = ctypes.sizeof(DeviceInterfaceDetailData)
-
-            result = setupapi.SetupDiGetDeviceInterfaceDetailA(
-                collection,
-                ctypes.byref(interface_info),
-                ctypes.byref(interface_detail),
-                detail_len,
-                None,
-                None,
-            )
-
-            if not result:
-                raise WinError()
-
-            path = ctypes.string_at(ctypes.addressof(interface_detail.DevicePath))
-            if VID_RE.search(path):
-                pid_match = PID_RE.search(path)
-                if pid_match:
-                    paths.append((int(pid_match.group(1), 16), path))
-        return paths
-    finally:
-        setupapi.SetupDiDestroyDeviceInfoList(collection)
-
-
-_SKIP = cast(OtpYubiKeyDevice, object())
-_device_cache: Dict[bytes, OtpYubiKeyDevice] = {}
-
-
-def list_devices():
-    stale = set(_device_cache)
-    devices = []
-    for pid, path in list_paths():
-        stale.discard(path)
-
-        # Check if path already cached
-        dev = _device_cache.get(path)
-        if dev:
-            if dev is not _SKIP:
-                devices.append(dev)
-            continue
-
-        device = kernel32.CreateFileA(
-            path,
-            0,
-            FILE_SHARE_READ | FILE_SHARE_WRITE,
-            None,
-            OPEN_EXISTING,
-            0,
-            None,
-        )
-        if device == INVALID_HANDLE_VALUE:
-            logger.debug("Couldn't read HID descriptor for %s", path)
-        else:
-            try:
-                usage = get_usage(device)
-                if usage == USAGE_OTP:
-                    dev = OtpYubiKeyDevice(path, pid, WinHidOtpConnection)
-                    _device_cache[path] = dev
-                    devices.append(dev)
-                    continue
-            except Exception:
-                logger.debug("Couldn't read Usage Page for %s:", path, exc_info=True)
-            finally:
-                kernel32.CloseHandle(device)
-        _device_cache[path] = _SKIP
-
-    # Remove entries from the cache that were not seen
-    for path in stale:
-        del _device_cache[path]
-
-    return devices
+# Original work Copyright 2016 Google Inc. All Rights Reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Modified work Copyright 2020 Yubico AB. All Rights Reserved.
+# This file, with modifications, is licensed under the above Apache License.
+
+from .base import OtpYubiKeyDevice, YUBICO_VID, USAGE_OTP
+from yubikit.core.otp import OtpConnection
+from yubikit.logging import LOG_LEVEL
+
+from ctypes import wintypes, LibraryLoader
+from typing import Dict, cast
+import ctypes
+import platform
+import logging
+import re
+import sys
+
+# Only typecheck this file on Windows
+assert sys.platform == "win32"  # nosec
+from ctypes import WinDLL, WinError  # noqa: E402
+
+logger = logging.getLogger(__name__)
+
+
+# Load relevant DLLs
+windll = LibraryLoader(WinDLL)
+hid = windll.Hid
+setupapi = windll.SetupAPI
+kernel32 = windll.Kernel32
+
+
+# Various structs that are used in the Windows APIs we call
+class GUID(ctypes.Structure):
+    _fields_ = [
+        ("Data1", ctypes.c_ulong),
+        ("Data2", ctypes.c_ushort),
+        ("Data3", ctypes.c_ushort),
+        ("Data4", ctypes.c_ubyte * 8),
+    ]
+
+
+# On Windows, SetupAPI.h packs structures differently in 64bit and
+# 32bit mode.  In 64-bit mode, the structures are packed on 8 byte
+# boundaries, while in 32-bit mode, they are packed on 1 byte boundaries.
+# This is important to get right for some API calls that fill out these
+# structures.
+if platform.architecture()[0] == "64bit":
+    SETUPAPI_PACK = 8
+elif platform.architecture()[0] == "32bit":
+    SETUPAPI_PACK = 1
+else:
+    raise OSError(f"Unknown architecture: {platform.architecture()[0]}")
+
+
+class DeviceInterfaceData(ctypes.Structure):
+    _fields_ = [
+        ("cbSize", wintypes.DWORD),
+        ("InterfaceClassGuid", GUID),
+        ("Flags", wintypes.DWORD),
+        ("Reserved", ctypes.POINTER(ctypes.c_ulong)),
+    ]
+    _pack_ = SETUPAPI_PACK
+
+
+class DeviceInterfaceDetailData(ctypes.Structure):
+    _fields_ = [("cbSize", wintypes.DWORD), ("DevicePath", ctypes.c_byte * 1)]
+    _pack_ = SETUPAPI_PACK
+
+
+class HidAttributes(ctypes.Structure):
+    _fields_ = [
+        ("Size", ctypes.c_ulong),
+        ("VendorID", ctypes.c_ushort),
+        ("ProductID", ctypes.c_ushort),
+        ("VersionNumber", ctypes.c_ushort),
+    ]
+
+
+class HidCapabilities(ctypes.Structure):
+    _fields_ = [
+        ("Usage", ctypes.c_ushort),
+        ("UsagePage", ctypes.c_ushort),
+        ("InputReportByteLength", ctypes.c_ushort),
+        ("OutputReportByteLength", ctypes.c_ushort),
+        ("FeatureReportByteLength", ctypes.c_ushort),
+        ("Reserved", ctypes.c_ushort * 17),
+        ("NotUsed", ctypes.c_ushort * 10),
+    ]
+
+
+# Various void* aliases for readability.
+HDEVINFO = ctypes.c_void_p
+HANDLE = ctypes.c_void_p
+PHIDP_PREPARSED_DATA = ctypes.c_void_p  # pylint: disable=invalid-name
+
+# This is a HANDLE.
+# INVALID_HANDLE_VALUE = 0xFFFFFFFF
+INVALID_HANDLE_VALUE = (1 << 8 * ctypes.sizeof(ctypes.c_void_p)) - 1
+
+# Status codes
+FILE_SHARE_READ = 0x00000001
+FILE_SHARE_WRITE = 0x00000002
+OPEN_EXISTING = 0x03
+NTSTATUS = ctypes.c_long
+HIDP_STATUS_SUCCESS = 0x00110000
+
+# CreateFile Flags
+GENERIC_WRITE = 0x40000000
+GENERIC_READ = 0x80000000
+
+DIGCF_DEVICEINTERFACE = 0x10
+DIGCF_PRESENT = 0x02
+
+# Function signatures
+hid.HidD_GetHidGuid.restype = None
+hid.HidD_GetHidGuid.argtypes = [ctypes.POINTER(GUID)]
+hid.HidD_GetAttributes.restype = wintypes.BOOLEAN
+hid.HidD_GetAttributes.argtypes = [HANDLE, ctypes.POINTER(HidAttributes)]
+hid.HidD_GetPreparsedData.restype = wintypes.BOOLEAN
+hid.HidD_GetPreparsedData.argtypes = [HANDLE, ctypes.POINTER(PHIDP_PREPARSED_DATA)]
+hid.HidD_FreePreparsedData.restype = wintypes.BOOLEAN
+hid.HidD_FreePreparsedData.argtypes = [PHIDP_PREPARSED_DATA]
+hid.HidD_GetProductString.restype = wintypes.BOOLEAN
+hid.HidD_GetProductString.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
+hid.HidP_GetCaps.restype = NTSTATUS
+hid.HidP_GetCaps.argtypes = [PHIDP_PREPARSED_DATA, ctypes.POINTER(HidCapabilities)]
+
+
+hid.HidD_GetFeature.restype = wintypes.BOOL
+hid.HidD_GetFeature.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
+hid.HidD_SetFeature.restype = wintypes.BOOL
+hid.HidD_SetFeature.argtypes = [HANDLE, ctypes.c_void_p, ctypes.c_ulong]
+
+setupapi.SetupDiGetClassDevsA.argtypes = [
+    ctypes.POINTER(GUID),
+    ctypes.c_char_p,
+    wintypes.HWND,
+    wintypes.DWORD,
+]
+setupapi.SetupDiGetClassDevsA.restype = HDEVINFO
+setupapi.SetupDiEnumDeviceInterfaces.restype = wintypes.BOOL
+setupapi.SetupDiEnumDeviceInterfaces.argtypes = [
+    HDEVINFO,
+    ctypes.c_void_p,
+    ctypes.POINTER(GUID),
+    wintypes.DWORD,
+    ctypes.POINTER(DeviceInterfaceData),
+]
+setupapi.SetupDiGetDeviceInterfaceDetailA.restype = wintypes.BOOL
+setupapi.SetupDiGetDeviceInterfaceDetailA.argtypes = [
+    HDEVINFO,
+    ctypes.POINTER(DeviceInterfaceData),
+    ctypes.POINTER(DeviceInterfaceDetailData),
+    wintypes.DWORD,
+    ctypes.POINTER(wintypes.DWORD),
+    ctypes.c_void_p,
+]
+setupapi.SetupDiDestroyDeviceInfoList.restype = wintypes.BOOL
+setupapi.SetupDiDestroyDeviceInfoList.argtypes = [
+    HDEVINFO,
+]
+
+kernel32.CreateFileA.restype = HANDLE
+kernel32.CreateFileA.argtypes = [
+    ctypes.c_char_p,
+    wintypes.DWORD,
+    wintypes.DWORD,
+    ctypes.c_void_p,
+    wintypes.DWORD,
+    wintypes.DWORD,
+    HANDLE,
+]
+kernel32.CloseHandle.restype = wintypes.BOOL
+kernel32.CloseHandle.argtypes = [HANDLE]
+
+
+class WinHidOtpConnection(OtpConnection):
+    def __init__(self, path):
+        self.handle = kernel32.CreateFileA(
+            path,
+            GENERIC_WRITE,
+            FILE_SHARE_READ | FILE_SHARE_WRITE,
+            None,
+            OPEN_EXISTING,
+            0,
+            None,
+        )
+        if self.handle == INVALID_HANDLE_VALUE:
+            raise WinError()
+
+    def close(self):
+        if self.handle:
+            kernel32.CloseHandle(self.handle)
+            self.handle = None
+
+    def receive(self):
+        buf = ctypes.create_string_buffer(9)
+        result = hid.HidD_GetFeature(self.handle, buf, ctypes.sizeof(buf))
+        if not result:
+            raise WinError()
+        data = buf.raw[1:]
+        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", data.hex())
+        return data
+
+    def send(self, data):
+        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", data.hex())
+        buf = ctypes.create_string_buffer(b"\0" + data)
+        result = hid.HidD_SetFeature(self.handle, buf, ctypes.sizeof(buf))
+        if not result:
+            raise WinError()
+
+
+def get_vid_pid(device):
+    attributes = HidAttributes()
+    result = hid.HidD_GetAttributes(device, ctypes.byref(attributes))
+    if not result:
+        raise WinError()
+
+    return attributes.VendorID, attributes.ProductID
+
+
+def get_usage(device):
+    preparsed_data = PHIDP_PREPARSED_DATA(0)
+    ret = hid.HidD_GetPreparsedData(device, ctypes.byref(preparsed_data))
+    if not ret:
+        raise WinError()
+
+    try:
+        caps = HidCapabilities()
+        ret = hid.HidP_GetCaps(preparsed_data, ctypes.byref(caps))
+
+        if ret != HIDP_STATUS_SUCCESS:
+            raise WinError()
+
+        return caps.UsagePage, caps.Usage
+
+    finally:
+        hid.HidD_FreePreparsedData(preparsed_data)
+
+
+VID_RE = re.compile(rb"\Wvid_%04x\W" % YUBICO_VID)
+PID_RE = re.compile(rb"\Wpid_([a-z0-9]{4})\W")
+
+
+def list_paths():
+    hid_guid = GUID()
+    hid.HidD_GetHidGuid(ctypes.byref(hid_guid))
+
+    collection = setupapi.SetupDiGetClassDevsA(
+        ctypes.byref(hid_guid), None, None, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT
+    )
+    try:
+        index = 0
+        interface_info = DeviceInterfaceData()
+        interface_info.cbSize = ctypes.sizeof(DeviceInterfaceData)
+
+        paths = []
+        while True:
+            result = setupapi.SetupDiEnumDeviceInterfaces(
+                collection,
+                0,
+                ctypes.byref(hid_guid),
+                index,
+                ctypes.byref(interface_info),
+            )
+            index += 1
+            if not result:
+                break
+
+            detail_len_dw = wintypes.DWORD()
+            result = setupapi.SetupDiGetDeviceInterfaceDetailA(
+                collection,
+                ctypes.byref(interface_info),
+                None,
+                0,
+                ctypes.byref(detail_len_dw),
+                None,
+            )
+            if result:
+                raise WinError()
+
+            detail_len = detail_len_dw.value
+            if detail_len == 0:
+                # skip this device, some kind of error
+                continue
+
+            buf = ctypes.create_string_buffer(detail_len)
+            interface_detail = DeviceInterfaceDetailData.from_buffer(buf)
+            interface_detail.cbSize = ctypes.sizeof(DeviceInterfaceDetailData)
+
+            result = setupapi.SetupDiGetDeviceInterfaceDetailA(
+                collection,
+                ctypes.byref(interface_info),
+                ctypes.byref(interface_detail),
+                detail_len,
+                None,
+                None,
+            )
+
+            if not result:
+                raise WinError()
+
+            path = ctypes.string_at(ctypes.addressof(interface_detail.DevicePath))
+            if VID_RE.search(path):
+                pid_match = PID_RE.search(path)
+                if pid_match:
+                    paths.append((int(pid_match.group(1), 16), path))
+        return paths
+    finally:
+        setupapi.SetupDiDestroyDeviceInfoList(collection)
+
+
+_SKIP = cast(OtpYubiKeyDevice, object())
+_device_cache: Dict[bytes, OtpYubiKeyDevice] = {}
+
+
+def list_devices():
+    stale = set(_device_cache)
+    devices = []
+    for pid, path in list_paths():
+        stale.discard(path)
+
+        # Check if path already cached
+        dev = _device_cache.get(path)
+        if dev:
+            if dev is not _SKIP:
+                devices.append(dev)
+            continue
+
+        device = kernel32.CreateFileA(
+            path,
+            0,
+            FILE_SHARE_READ | FILE_SHARE_WRITE,
+            None,
+            OPEN_EXISTING,
+            0,
+            None,
+        )
+        if device == INVALID_HANDLE_VALUE:
+            logger.debug("Couldn't read HID descriptor for %s", path)
+        else:
+            try:
+                usage = get_usage(device)
+                if usage == USAGE_OTP:
+                    dev = OtpYubiKeyDevice(path, pid, WinHidOtpConnection)
+                    _device_cache[path] = dev
+                    devices.append(dev)
+                    continue
+            except Exception:
+                logger.debug("Couldn't read Usage Page for %s:", path, exc_info=True)
+            finally:
+                kernel32.CloseHandle(device)
+        _device_cache[path] = _SKIP
+
+    # Remove entries from the cache that were not seen
+    for path in stale:
+        del _device_cache[path]
+
+    return devices
```

### Comparing `yubikey_manager-5.1.0/ykman/logging.py` & `yubikey_manager-5.1.1/ykman/logging.py`

 * *Ordering differences only*

 * *Files 15% similar despite different names*

```diff
@@ -1,76 +1,76 @@
-# Copyright (c) 2022 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.logging import LOG_LEVEL
-import logging
-
-
-logging.addLevelName(LOG_LEVEL.TRAFFIC, LOG_LEVEL.TRAFFIC.name)
-logger = logging.getLogger(__name__)
-
-
-def _print_box(*lines):
-    w = max([len(ln) for ln in lines])
-    bar = "#" * (w + 4)
-    box = ["", bar]
-    for ln in [""] + list(lines) + [""]:
-        box.append(f"# {ln.ljust(w)} #")
-    box.append(bar)
-    return "\n".join(box)
-
-
-TRAFFIC_WARNING = (
-    "WARNING: All data sent to/from the YubiKey will be logged!",
-    "This data may contain sensitive values, such as secret keys, PINs or passwords!",
-)
-
-DEBUG_WARNING = (
-    "WARNING: Sensitive data may be logged!",
-    "Some personally identifying information may be logged, such as usernames!",
-)
-
-
-def set_log_level(level: LOG_LEVEL):
-    logging.getLogger().setLevel(level)
-
-    logger.info(f"Logging at level: {level.name}")
-    if level <= LOG_LEVEL.TRAFFIC:
-        logger.warning(_print_box(*TRAFFIC_WARNING))
-    elif level <= LOG_LEVEL.DEBUG:
-        logger.warning(_print_box(*DEBUG_WARNING))
-
-
-def init_logging(log_level: LOG_LEVEL, log_file=None):
-    logging.basicConfig(
-        force=log_file is None,  # Replace the default logger if logging to stderr
-        datefmt="%H:%M:%S",
-        filename=log_file,
-        format="%(levelname)s %(asctime)s.%(msecs)d [%(name)s.%(funcName)s:%(lineno)d] "
-        "%(message)s",
-    )
-
-    set_log_level(log_level)
+# Copyright (c) 2022 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.logging import LOG_LEVEL
+import logging
+
+
+logging.addLevelName(LOG_LEVEL.TRAFFIC, LOG_LEVEL.TRAFFIC.name)
+logger = logging.getLogger(__name__)
+
+
+def _print_box(*lines):
+    w = max([len(ln) for ln in lines])
+    bar = "#" * (w + 4)
+    box = ["", bar]
+    for ln in [""] + list(lines) + [""]:
+        box.append(f"# {ln.ljust(w)} #")
+    box.append(bar)
+    return "\n".join(box)
+
+
+TRAFFIC_WARNING = (
+    "WARNING: All data sent to/from the YubiKey will be logged!",
+    "This data may contain sensitive values, such as secret keys, PINs or passwords!",
+)
+
+DEBUG_WARNING = (
+    "WARNING: Sensitive data may be logged!",
+    "Some personally identifying information may be logged, such as usernames!",
+)
+
+
+def set_log_level(level: LOG_LEVEL):
+    logging.getLogger().setLevel(level)
+
+    logger.info(f"Logging at level: {level.name}")
+    if level <= LOG_LEVEL.TRAFFIC:
+        logger.warning(_print_box(*TRAFFIC_WARNING))
+    elif level <= LOG_LEVEL.DEBUG:
+        logger.warning(_print_box(*DEBUG_WARNING))
+
+
+def init_logging(log_level: LOG_LEVEL, log_file=None):
+    logging.basicConfig(
+        force=log_file is None,  # Replace the default logger if logging to stderr
+        datefmt="%H:%M:%S",
+        filename=log_file,
+        format="%(levelname)s %(asctime)s.%(msecs)d [%(name)s.%(funcName)s:%(lineno)d] "
+        "%(message)s",
+    )
+
+    set_log_level(log_level)
```

### Comparing `yubikey_manager-5.1.0/ykman/logging_setup.py` & `yubikey_manager-5.1.1/ykman/logging_setup.py`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,61 +1,61 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from ykman import __version__ as ykman_version
-from ykman.util import get_windows_version
-from ykman.logging import init_logging
-from yubikit.logging import LOG_LEVEL
-from datetime import datetime
-import platform
-import logging
-import ctypes
-import sys
-import os
-
-
-logger = logging.getLogger(__name__)
-
-
-def log_sys_info(log):
-    log(f"ykman: {ykman_version}")
-    log(f"Python: {sys.version}")
-    log(f"Platform: {sys.platform}")
-    log(f"Arch: {platform.machine()}")
-    if sys.platform == "win32":
-        log(f"Windows version: {get_windows_version()}")
-        is_admin = bool(ctypes.windll.shell32.IsUserAnAdmin())
-    else:
-        is_admin = os.getuid() == 0
-    log(f"Running as admin: {is_admin}")
-    log("System date: %s", datetime.today().strftime("%Y-%m-%d"))
-
-
-def setup(log_level_name, log_file=None):
-    log_level = LOG_LEVEL[log_level_name.upper()]
-    init_logging(log_level, log_file=log_file)
-
-    log_sys_info(logger.debug)
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from ykman import __version__ as ykman_version
+from ykman.util import get_windows_version
+from ykman.logging import init_logging
+from yubikit.logging import LOG_LEVEL
+from datetime import datetime
+import platform
+import logging
+import ctypes
+import sys
+import os
+
+
+logger = logging.getLogger(__name__)
+
+
+def log_sys_info(log):
+    log(f"ykman: {ykman_version}")
+    log(f"Python: {sys.version}")
+    log(f"Platform: {sys.platform}")
+    log(f"Arch: {platform.machine()}")
+    if sys.platform == "win32":
+        log(f"Windows version: {get_windows_version()}")
+        is_admin = bool(ctypes.windll.shell32.IsUserAnAdmin())
+    else:
+        is_admin = os.getuid() == 0
+    log(f"Running as admin: {is_admin}")
+    log("System date: %s", datetime.today().strftime("%Y-%m-%d"))
+
+
+def setup(log_level_name, log_file=None):
+    log_level = LOG_LEVEL[log_level_name.upper()]
+    init_logging(log_level, log_file=log_file)
+
+    log_sys_info(logger.debug)
```

### Comparing `yubikey_manager-5.1.0/ykman/oath.py` & `yubikey_manager-5.1.1/ykman/oath.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.oath import OATH_TYPE
-from time import time
-import struct
-
-
-STEAM_CHAR_TABLE = "23456789BCDFGHJKMNPQRTVWXY"
-
-
-def is_hidden(credential):
-    return credential.issuer == "_hidden"
-
-
-def is_steam(credential):
-    return credential.oath_type == OATH_TYPE.TOTP and credential.issuer == "Steam"
-
-
-def calculate_steam(app, credential, timestamp=None):
-    timestamp = int(timestamp or time())
-    resp = app.calculate(credential.id, struct.pack(">q", timestamp // 30))
-    offset = resp[-1] & 0x0F
-    code = struct.unpack(">I", resp[offset : offset + 4])[0] & 0x7FFFFFFF
-    chars = []
-    for i in range(5):
-        chars.append(STEAM_CHAR_TABLE[code % len(STEAM_CHAR_TABLE)])
-        code //= len(STEAM_CHAR_TABLE)
-    return "".join(chars)
-
-
-def is_in_fips_mode(app):
-    return app.locked
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.oath import OATH_TYPE
+from time import time
+import struct
+
+
+STEAM_CHAR_TABLE = "23456789BCDFGHJKMNPQRTVWXY"
+
+
+def is_hidden(credential):
+    return credential.issuer == "_hidden"
+
+
+def is_steam(credential):
+    return credential.oath_type == OATH_TYPE.TOTP and credential.issuer == "Steam"
+
+
+def calculate_steam(app, credential, timestamp=None):
+    timestamp = int(timestamp or time())
+    resp = app.calculate(credential.id, struct.pack(">q", timestamp // 30))
+    offset = resp[-1] & 0x0F
+    code = struct.unpack(">I", resp[offset : offset + 4])[0] & 0x7FFFFFFF
+    chars = []
+    for i in range(5):
+        chars.append(STEAM_CHAR_TABLE[code % len(STEAM_CHAR_TABLE)])
+        code //= len(STEAM_CHAR_TABLE)
+    return "".join(chars)
+
+
+def is_in_fips_mode(app):
+    return app.locked
```

### Comparing `yubikey_manager-5.1.0/ykman/openpgp.py` & `yubikey_manager-5.1.1/ykman/openpgp.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.openpgp import OpenPgpSession, KEY_REF
-
-
-def get_openpgp_info(session: OpenPgpSession):
-    """Get human readable information about the OpenPGP configuration."""
-    data = session.get_application_related_data()
-    discretionary = data.discretionary
-    retries = discretionary.pw_status
-    info = {
-        "OpenPGP version": "%d.%d" % data.aid.version,
-        "Application version": "%d.%d.%d" % session.version,
-        "PIN tries remaining": retries.attempts_user,
-        "Reset code tries remaining": retries.attempts_reset,
-        "Admin PIN tries remaining": retries.attempts_admin,
-        "Require PIN for signature": retries.pin_policy_user,
-    }
-
-    # Touch only available on YK4 and later
-    if session.version >= (4, 2, 6):
-        touch = {
-            "Signature key": session.get_uif(KEY_REF.SIG),
-            "Encryption key": session.get_uif(KEY_REF.DEC),
-            "Authentication key": session.get_uif(KEY_REF.AUT),
-        }
-        if discretionary.attributes_att is not None:
-            touch["Attestation key"] = session.get_uif(KEY_REF.ATT)
-        info["Touch policies"] = touch
-
-    return info
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.openpgp import OpenPgpSession, KEY_REF
+
+
+def get_openpgp_info(session: OpenPgpSession):
+    """Get human readable information about the OpenPGP configuration."""
+    data = session.get_application_related_data()
+    discretionary = data.discretionary
+    retries = discretionary.pw_status
+    info = {
+        "OpenPGP version": "%d.%d" % data.aid.version,
+        "Application version": "%d.%d.%d" % session.version,
+        "PIN tries remaining": retries.attempts_user,
+        "Reset code tries remaining": retries.attempts_reset,
+        "Admin PIN tries remaining": retries.attempts_admin,
+        "Require PIN for signature": retries.pin_policy_user,
+    }
+
+    # Touch only available on YK4 and later
+    if session.version >= (4, 2, 6):
+        touch = {
+            "Signature key": session.get_uif(KEY_REF.SIG),
+            "Encryption key": session.get_uif(KEY_REF.DEC),
+            "Authentication key": session.get_uif(KEY_REF.AUT),
+        }
+        if discretionary.attributes_att is not None:
+            touch["Attestation key"] = session.get_uif(KEY_REF.ATT)
+        info["Touch policies"] = touch
+
+    return info
```

### Comparing `yubikey_manager-5.1.0/ykman/otp.py` & `yubikey_manager-5.1.1/ykman/otp.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,205 +1,205 @@
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from . import __version__
-from .scancodes import KEYBOARD_LAYOUT
-from yubikit.core.otp import modhex_encode
-from yubikit.yubiotp import YubiOtpSession
-from yubikit.oath import parse_b32_key
-from enum import Enum
-from http.client import HTTPSConnection
-from datetime import datetime
-from typing import Iterable, Optional
-
-import json
-import struct
-import random
-import logging
-
-logger = logging.getLogger(__name__)
-
-
-_UPLOAD_HOST = "upload.yubico.com"
-_UPLOAD_PATH = "/prepare"
-
-
-class _PrepareUploadError(Enum):
-    # Defined here
-    CONNECTION_FAILED = "Failed to open HTTPS connection."
-    NOT_FOUND = "Upload request not recognized by server."
-    SERVICE_UNAVAILABLE = (
-        "Service temporarily unavailable, please try again later."  # noqa: E501
-    )
-
-    # Defined in upload project
-    PRIVATE_ID_INVALID_LENGTH = "Private ID must be 12 characters long."
-    PRIVATE_ID_NOT_HEX = (
-        "Private ID must consist only of hex characters (0-9A-F)."  # noqa: E501
-    )
-    PRIVATE_ID_UNDEFINED = "Private ID is required."
-    PUBLIC_ID_INVALID_LENGTH = "Public ID must be 12 characters long."
-    PUBLIC_ID_NOT_MODHEX = "Public ID must consist only of modhex characters (cbdefghijklnrtuv)."  # noqa: E501
-    PUBLIC_ID_NOT_VV = 'Public ID must begin with "vv".'
-    PUBLIC_ID_OCCUPIED = "Public ID is already in use."
-    PUBLIC_ID_UNDEFINED = "Public ID is required."
-    SECRET_KEY_INVALID_LENGTH = "Secret key must be 32 character long."  # nosec
-    SECRET_KEY_NOT_HEX = (
-        "Secret key must consist only of hex characters (0-9A-F)."  # noqa: E501 # nosec
-    )
-    SECRET_KEY_UNDEFINED = "Secret key is required."  # nosec
-    SERIAL_NOT_INT = "Serial number must be an integer."
-    SERIAL_TOO_LONG = "Serial number is too long."
-
-    def message(self):
-        return self.value
-
-
-class _PrepareUploadFailed(Exception):
-    def __init__(self, status, content, error_ids):
-        super().__init__(f"Upload to YubiCloud failed with status {status}: {content}")
-        self.status = status
-        self.content = content
-        self.errors = [
-            e if isinstance(e, _PrepareUploadError) else _PrepareUploadError[e]
-            for e in error_ids
-        ]
-
-    def messages(self):
-        return [e.message() for e in self.errors]
-
-
-def _prepare_upload_key(
-    key,
-    public_id,
-    private_id,
-    serial=None,
-    user_agent="python-yubikey-manager/" + __version__,
-):
-    modhex_public_id = modhex_encode(public_id)
-    data = {
-        "aes_key": key.hex(),
-        "serial": serial or 0,
-        "public_id": modhex_public_id,
-        "private_id": private_id.hex(),
-    }
-
-    httpconn = HTTPSConnection(_UPLOAD_HOST, timeout=1)  # nosec
-
-    try:
-        httpconn.request(
-            "POST",
-            _UPLOAD_PATH,
-            body=json.dumps(data, indent=False, sort_keys=True).encode("utf-8"),
-            headers={"Content-Type": "application/json", "User-Agent": user_agent},
-        )
-    except Exception:
-        logger.error("Failed to connect to %s", _UPLOAD_HOST, exc_info=True)
-        raise _PrepareUploadFailed(None, None, [_PrepareUploadError.CONNECTION_FAILED])
-
-    resp = httpconn.getresponse()
-    if resp.status == 200:
-        url = json.loads(resp.read().decode("utf-8"))["finish_url"]
-        return url
-    else:
-        resp_body = resp.read()
-        logger.debug("Upload failed with status %d: %s", resp.status, resp_body)
-        if resp.status == 404:
-            raise _PrepareUploadFailed(
-                resp.status, resp_body, [_PrepareUploadError.NOT_FOUND]
-            )
-        elif resp.status == 503:
-            raise _PrepareUploadFailed(
-                resp.status, resp_body, [_PrepareUploadError.SERVICE_UNAVAILABLE]
-            )
-        else:
-            try:
-                errors = json.loads(resp_body.decode("utf-8")).get("errors")
-            except Exception:
-                errors = []
-            raise _PrepareUploadFailed(resp.status, resp_body, errors)
-
-
-def is_in_fips_mode(session: YubiOtpSession) -> bool:
-    """Check if the OTP application of a FIPS YubiKey is in FIPS approved mode."""
-    return session.backend.send_and_receive(0x14, b"", 1) == b"\1"  # type: ignore
-
-
-DEFAULT_PW_CHAR_BLOCKLIST = ["\t", "\n", " "]
-
-
-def generate_static_pw(
-    length: int,
-    keyboard_layout: KEYBOARD_LAYOUT = KEYBOARD_LAYOUT.MODHEX,
-    blocklist: Iterable[str] = DEFAULT_PW_CHAR_BLOCKLIST,
-) -> str:
-    """Generate a random password."""
-    chars = [k for k in keyboard_layout.value.keys() if k not in blocklist]
-    sr = random.SystemRandom()
-    return "".join([sr.choice(chars) for _ in range(length)])
-
-
-def parse_oath_key(val: str) -> bytes:
-    """Parse a secret key encoded as either Hex or Base32."""
-    try:
-        return bytes.fromhex(val)
-    except ValueError:
-        return parse_b32_key(val)
-
-
-def format_oath_code(response: bytes, digits: int = 6) -> str:
-    """Formats an OATH code from a hash response."""
-    offs = response[-1] & 0xF
-    code = struct.unpack_from(">I", response[offs:])[0] & 0x7FFFFFFF
-    return ("%%0%dd" % digits) % (code % 10**digits)
-
-
-def time_challenge(timestamp: int, period: int = 30) -> bytes:
-    """Formats a HMAC-SHA1 challenge based on an OATH timestamp and period."""
-    return struct.pack(">q", int(timestamp // period))
-
-
-def format_csv(
-    serial: int,
-    public_id: bytes,
-    private_id: bytes,
-    key: bytes,
-    access_code: Optional[bytes] = None,
-    timestamp: Optional[datetime] = None,
-) -> str:
-    """Produces a CSV line in the "Yubico" format."""
-    ts = timestamp or datetime.now()
-    return ",".join(
-        [
-            str(serial),
-            modhex_encode(public_id),
-            private_id.hex(),
-            key.hex(),
-            access_code.hex() if access_code else "",
-            ts.isoformat(timespec="seconds"),
-            "",  # Add trailing comma
-        ]
-    )
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from . import __version__
+from .scancodes import KEYBOARD_LAYOUT
+from yubikit.core.otp import modhex_encode
+from yubikit.yubiotp import YubiOtpSession
+from yubikit.oath import parse_b32_key
+from enum import Enum
+from http.client import HTTPSConnection
+from datetime import datetime
+from typing import Iterable, Optional
+
+import json
+import struct
+import random
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+_UPLOAD_HOST = "upload.yubico.com"
+_UPLOAD_PATH = "/prepare"
+
+
+class _PrepareUploadError(Enum):
+    # Defined here
+    CONNECTION_FAILED = "Failed to open HTTPS connection."
+    NOT_FOUND = "Upload request not recognized by server."
+    SERVICE_UNAVAILABLE = (
+        "Service temporarily unavailable, please try again later."  # noqa: E501
+    )
+
+    # Defined in upload project
+    PRIVATE_ID_INVALID_LENGTH = "Private ID must be 12 characters long."
+    PRIVATE_ID_NOT_HEX = (
+        "Private ID must consist only of hex characters (0-9A-F)."  # noqa: E501
+    )
+    PRIVATE_ID_UNDEFINED = "Private ID is required."
+    PUBLIC_ID_INVALID_LENGTH = "Public ID must be 12 characters long."
+    PUBLIC_ID_NOT_MODHEX = "Public ID must consist only of modhex characters (cbdefghijklnrtuv)."  # noqa: E501
+    PUBLIC_ID_NOT_VV = 'Public ID must begin with "vv".'
+    PUBLIC_ID_OCCUPIED = "Public ID is already in use."
+    PUBLIC_ID_UNDEFINED = "Public ID is required."
+    SECRET_KEY_INVALID_LENGTH = "Secret key must be 32 character long."  # nosec
+    SECRET_KEY_NOT_HEX = (
+        "Secret key must consist only of hex characters (0-9A-F)."  # noqa: E501 # nosec
+    )
+    SECRET_KEY_UNDEFINED = "Secret key is required."  # nosec
+    SERIAL_NOT_INT = "Serial number must be an integer."
+    SERIAL_TOO_LONG = "Serial number is too long."
+
+    def message(self):
+        return self.value
+
+
+class _PrepareUploadFailed(Exception):
+    def __init__(self, status, content, error_ids):
+        super().__init__(f"Upload to YubiCloud failed with status {status}: {content}")
+        self.status = status
+        self.content = content
+        self.errors = [
+            e if isinstance(e, _PrepareUploadError) else _PrepareUploadError[e]
+            for e in error_ids
+        ]
+
+    def messages(self):
+        return [e.message() for e in self.errors]
+
+
+def _prepare_upload_key(
+    key,
+    public_id,
+    private_id,
+    serial=None,
+    user_agent="python-yubikey-manager/" + __version__,
+):
+    modhex_public_id = modhex_encode(public_id)
+    data = {
+        "aes_key": key.hex(),
+        "serial": serial or 0,
+        "public_id": modhex_public_id,
+        "private_id": private_id.hex(),
+    }
+
+    httpconn = HTTPSConnection(_UPLOAD_HOST, timeout=1)  # nosec
+
+    try:
+        httpconn.request(
+            "POST",
+            _UPLOAD_PATH,
+            body=json.dumps(data, indent=False, sort_keys=True).encode("utf-8"),
+            headers={"Content-Type": "application/json", "User-Agent": user_agent},
+        )
+    except Exception:
+        logger.error("Failed to connect to %s", _UPLOAD_HOST, exc_info=True)
+        raise _PrepareUploadFailed(None, None, [_PrepareUploadError.CONNECTION_FAILED])
+
+    resp = httpconn.getresponse()
+    if resp.status == 200:
+        url = json.loads(resp.read().decode("utf-8"))["finish_url"]
+        return url
+    else:
+        resp_body = resp.read()
+        logger.debug("Upload failed with status %d: %s", resp.status, resp_body)
+        if resp.status == 404:
+            raise _PrepareUploadFailed(
+                resp.status, resp_body, [_PrepareUploadError.NOT_FOUND]
+            )
+        elif resp.status == 503:
+            raise _PrepareUploadFailed(
+                resp.status, resp_body, [_PrepareUploadError.SERVICE_UNAVAILABLE]
+            )
+        else:
+            try:
+                errors = json.loads(resp_body.decode("utf-8")).get("errors")
+            except Exception:
+                errors = []
+            raise _PrepareUploadFailed(resp.status, resp_body, errors)
+
+
+def is_in_fips_mode(session: YubiOtpSession) -> bool:
+    """Check if the OTP application of a FIPS YubiKey is in FIPS approved mode."""
+    return session.backend.send_and_receive(0x14, b"", 1) == b"\1"  # type: ignore
+
+
+DEFAULT_PW_CHAR_BLOCKLIST = ["\t", "\n", " "]
+
+
+def generate_static_pw(
+    length: int,
+    keyboard_layout: KEYBOARD_LAYOUT = KEYBOARD_LAYOUT.MODHEX,
+    blocklist: Iterable[str] = DEFAULT_PW_CHAR_BLOCKLIST,
+) -> str:
+    """Generate a random password."""
+    chars = [k for k in keyboard_layout.value.keys() if k not in blocklist]
+    sr = random.SystemRandom()
+    return "".join([sr.choice(chars) for _ in range(length)])
+
+
+def parse_oath_key(val: str) -> bytes:
+    """Parse a secret key encoded as either Hex or Base32."""
+    try:
+        return bytes.fromhex(val)
+    except ValueError:
+        return parse_b32_key(val)
+
+
+def format_oath_code(response: bytes, digits: int = 6) -> str:
+    """Formats an OATH code from a hash response."""
+    offs = response[-1] & 0xF
+    code = struct.unpack_from(">I", response[offs:])[0] & 0x7FFFFFFF
+    return ("%%0%dd" % digits) % (code % 10**digits)
+
+
+def time_challenge(timestamp: int, period: int = 30) -> bytes:
+    """Formats a HMAC-SHA1 challenge based on an OATH timestamp and period."""
+    return struct.pack(">q", int(timestamp // period))
+
+
+def format_csv(
+    serial: int,
+    public_id: bytes,
+    private_id: bytes,
+    key: bytes,
+    access_code: Optional[bytes] = None,
+    timestamp: Optional[datetime] = None,
+) -> str:
+    """Produces a CSV line in the "Yubico" format."""
+    ts = timestamp or datetime.now()
+    return ",".join(
+        [
+            str(serial),
+            modhex_encode(public_id),
+            private_id.hex(),
+            key.hex(),
+            access_code.hex() if access_code else "",
+            ts.isoformat(timespec="seconds"),
+            "",  # Add trailing comma
+        ]
+    )
```

### Comparing `yubikey_manager-5.1.0/ykman/piv.py` & `yubikey_manager-5.1.1/ykman/piv.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,675 +1,675 @@
-# Copyright (c) 2017 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-
-from yubikit.core import Tlv, BadResponseError, NotSupportedError
-from yubikit.core.smartcard import ApduError, SW
-from yubikit.piv import (
-    PivSession,
-    SLOT,
-    OBJECT_ID,
-    KEY_TYPE,
-    MANAGEMENT_KEY_TYPE,
-    ALGORITHM,
-    TAG_LRC,
-)
-
-from cryptography import x509
-from cryptography.exceptions import InvalidSignature
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
-from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
-from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
-from cryptography.hazmat.backends import default_backend
-from cryptography.x509.oid import NameOID
-from collections import OrderedDict
-from datetime import datetime
-import logging
-import struct
-import os
-import re
-
-from typing import Union, Mapping, Optional, List, Dict, Type, Any, cast
-
-
-logger = logging.getLogger(__name__)
-
-
-OBJECT_ID_PIVMAN_DATA = 0x5FFF00
-OBJECT_ID_PIVMAN_PROTECTED_DATA = OBJECT_ID.PRINTED  # Use slot for printed information.
-
-
-_NAME_ATTRIBUTES = {
-    "CN": NameOID.COMMON_NAME,
-    "L": NameOID.LOCALITY_NAME,
-    "ST": NameOID.STATE_OR_PROVINCE_NAME,
-    "O": NameOID.ORGANIZATION_NAME,
-    "OU": NameOID.ORGANIZATIONAL_UNIT_NAME,
-    "C": NameOID.COUNTRY_NAME,
-    "STREET": NameOID.STREET_ADDRESS,
-    "DC": NameOID.DOMAIN_COMPONENT,
-    "UID": NameOID.USER_ID,
-}
-
-
-_ESCAPED = "\\\"+,'<> #="
-
-
-def _parse(value: str) -> List[List[str]]:
-    remaining = list(value)
-    name = []
-    entry = []
-    buf = ""
-    hexbuf = b""
-    while remaining:
-        c = remaining.pop(0)
-        if c == "\\":
-            c1 = remaining.pop(0)
-            if c1 in _ESCAPED:
-                c = c1
-            else:
-                c2 = remaining.pop(0)
-                hexbuf += bytes.fromhex(c1 + c2)
-                try:
-                    c = hexbuf.decode()
-                    hexbuf = b""
-                except UnicodeDecodeError:
-                    continue  # Possibly multi-byte, expect more hex
-        elif c in ",+":
-            entry.append(buf)
-            buf = ""
-            if c == ",":
-                name.append(entry)
-                entry = []
-            continue
-        if hexbuf:
-            raise ValueError("Invalid UTF-8 data")
-        buf += c
-    entry.append(buf)
-    name.append(entry)
-    return name
-
-
-_DOTTED_STRING_RE = re.compile(r"\d(\.\d+)+")
-
-
-def parse_rfc4514_string(value: str) -> x509.Name:
-    """Parses an RFC 4514 string into a x509.Name.
-
-    See: https://tools.ietf.org/html/rfc4514.html
-    """
-    name = _parse(value)
-    attributes: List[x509.RelativeDistinguishedName] = []
-    for entry in name:
-        parts = []
-        for part in entry:
-            if "=" not in part:
-                raise ValueError("Invalid RFC 4514 string")
-            k, v = part.split("=", 1)
-            if k in _NAME_ATTRIBUTES:
-                attr = _NAME_ATTRIBUTES[k]
-            elif _DOTTED_STRING_RE.fullmatch(k):
-                attr = x509.ObjectIdentifier(k)
-            else:
-                raise ValueError(f"Unsupported attribute: '{k}'")
-            parts.append(x509.NameAttribute(attr, v))
-        attributes.insert(0, x509.RelativeDistinguishedName(parts))
-
-    return x509.Name(attributes)
-
-
-def _dummy_key(algorithm):
-    if algorithm == KEY_TYPE.RSA1024:
-        return rsa.generate_private_key(65537, 1024, default_backend())  # nosec
-    if algorithm == KEY_TYPE.RSA2048:
-        return rsa.generate_private_key(65537, 2048, default_backend())
-    if algorithm == KEY_TYPE.ECCP256:
-        return ec.generate_private_key(ec.SECP256R1(), default_backend())
-    if algorithm == KEY_TYPE.ECCP384:
-        return ec.generate_private_key(ec.SECP384R1(), default_backend())
-    raise ValueError("Invalid algorithm")
-
-
-def derive_management_key(pin: str, salt: bytes) -> bytes:
-    """Derive a management key from the users PIN and a salt.
-
-    NOTE: This method of derivation is deprecated! Protect the management key using
-    PivmanProtectedData instead.
-    """
-    kdf = PBKDF2HMAC(hashes.SHA1(), 24, salt, 10000, default_backend())  # nosec
-    return kdf.derive(pin.encode("utf-8"))
-
-
-def generate_random_management_key(algorithm: MANAGEMENT_KEY_TYPE) -> bytes:
-    """Generates a new random management key."""
-    return os.urandom(algorithm.key_len)
-
-
-class PivmanData:
-    def __init__(self, raw_data: bytes = Tlv(0x80)):
-        data = Tlv.parse_dict(Tlv(raw_data).value)
-        self._flags = struct.unpack(">B", data[0x81])[0] if 0x81 in data else None
-        self.salt = data.get(0x82)
-        self.pin_timestamp = struct.unpack(">I", data[0x83]) if 0x83 in data else None
-
-    def _get_flag(self, mask: int) -> bool:
-        return bool((self._flags or 0) & mask)
-
-    def _set_flag(self, mask: int, value: bool) -> None:
-        if value:
-            self._flags = (self._flags or 0) | mask
-        elif self._flags is not None:
-            self._flags &= ~mask
-
-    @property
-    def puk_blocked(self) -> bool:
-        return self._get_flag(0x01)
-
-    @puk_blocked.setter
-    def puk_blocked(self, value: bool) -> None:
-        self._set_flag(0x01, value)
-
-    @property
-    def mgm_key_protected(self) -> bool:
-        return self._get_flag(0x02)
-
-    @mgm_key_protected.setter
-    def mgm_key_protected(self, value: bool) -> None:
-        self._set_flag(0x02, value)
-
-    @property
-    def has_protected_key(self) -> bool:
-        return self.has_derived_key or self.has_stored_key
-
-    @property
-    def has_derived_key(self) -> bool:
-        return self.salt is not None
-
-    @property
-    def has_stored_key(self) -> bool:
-        return self.mgm_key_protected
-
-    def get_bytes(self) -> bytes:
-        data = b""
-        if self._flags is not None:
-            data += Tlv(0x81, struct.pack(">B", self._flags))
-        if self.salt is not None:
-            data += Tlv(0x82, self.salt)
-        if self.pin_timestamp is not None:
-            data += Tlv(0x83, struct.pack(">I", self.pin_timestamp))
-        return Tlv(0x80, data)
-
-
-class PivmanProtectedData:
-    def __init__(self, raw_data: bytes = Tlv(0x88)):
-        data = Tlv.parse_dict(Tlv(raw_data).value)
-        self.key = data.get(0x89)
-
-    def get_bytes(self) -> bytes:
-        data = b""
-        if self.key is not None:
-            data += Tlv(0x89, self.key)
-        return Tlv(0x88, data)
-
-
-def get_pivman_data(session: PivSession) -> PivmanData:
-    """Reads out the Pivman data from a YubiKey."""
-    logger.debug("Reading pivman data")
-    try:
-        return PivmanData(session.get_object(OBJECT_ID_PIVMAN_DATA))
-    except ApduError as e:
-        if e.sw == SW.FILE_NOT_FOUND:
-            # No data there, initialise a new object.
-            logger.debug("No data, initializing blank")
-            return PivmanData()
-        raise
-
-
-def get_pivman_protected_data(session: PivSession) -> PivmanProtectedData:
-    """Reads out the Pivman protected data from a YubiKey.
-
-    This function requires PIN verification prior to being called.
-    """
-    logger.debug("Reading protected pivman data")
-    try:
-        return PivmanProtectedData(session.get_object(OBJECT_ID_PIVMAN_PROTECTED_DATA))
-    except ApduError as e:
-        if e.sw == SW.FILE_NOT_FOUND:
-            # No data there, initialise a new object.
-            logger.debug("No data, initializing blank")
-            return PivmanProtectedData()
-        raise
-
-
-def pivman_set_mgm_key(
-    session: PivSession,
-    new_key: bytes,
-    algorithm: MANAGEMENT_KEY_TYPE,
-    touch: bool = False,
-    store_on_device: bool = False,
-) -> None:
-    """Set a new management key, while keeping PivmanData in sync."""
-    pivman = get_pivman_data(session)
-    pivman_prot = None
-
-    if store_on_device or (not store_on_device and pivman.has_stored_key):
-        # Ensure we have access to protected data before overwriting key
-        try:
-            pivman_prot = get_pivman_protected_data(session)
-        except Exception:
-            logger.debug("Failed to initialize protected pivman data", exc_info=True)
-            if store_on_device:
-                raise
-
-    # Set the new management key
-    session.set_management_key(algorithm, new_key, touch)
-
-    if pivman.has_derived_key:
-        # Clear salt for old derived keys.
-        logger.debug("Clearing salt in pivman data")
-        pivman.salt = None
-
-    # Set flag for stored or not stored key.
-    pivman.mgm_key_protected = store_on_device
-
-    # Update readable pivman data
-    session.put_object(OBJECT_ID_PIVMAN_DATA, pivman.get_bytes())
-
-    if pivman_prot is not None:
-        if store_on_device:
-            # Store key in protected pivman data
-            logger.debug("Storing key in protected pivman data")
-            pivman_prot.key = new_key
-            session.put_object(OBJECT_ID_PIVMAN_PROTECTED_DATA, pivman_prot.get_bytes())
-        elif pivman_prot.key:
-            # If new key should not be stored and there is an old stored key,
-            # try to clear it.
-            logger.debug("Clearing old key in protected pivman data")
-            try:
-                pivman_prot.key = None
-                session.put_object(
-                    OBJECT_ID_PIVMAN_PROTECTED_DATA,
-                    pivman_prot.get_bytes(),
-                )
-            except ApduError:
-                logger.debug("No PIN provided, can't clear key...", exc_info=True)
-
-
-def pivman_change_pin(session: PivSession, old_pin: str, new_pin: str) -> None:
-    """Change the PIN, while keeping PivmanData in sync."""
-    session.change_pin(old_pin, new_pin)
-
-    pivman = get_pivman_data(session)
-    if pivman.has_derived_key:
-        logger.debug("Has derived management key, update for new PIN")
-        session.authenticate(
-            MANAGEMENT_KEY_TYPE.TDES,
-            derive_management_key(old_pin, cast(bytes, pivman.salt)),
-        )
-        session.verify_pin(new_pin)
-        new_salt = os.urandom(16)
-        new_key = derive_management_key(new_pin, new_salt)
-        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, new_key)
-        pivman.salt = new_salt
-        session.put_object(OBJECT_ID_PIVMAN_DATA, pivman.get_bytes())
-
-
-def list_certificates(session: PivSession) -> Mapping[SLOT, Optional[x509.Certificate]]:
-    """Reads out and parses stored certificates.
-
-    Only certificates which are successfully parsed are returned.
-    """
-    certs = OrderedDict()
-    for slot in set(SLOT) - {SLOT.ATTESTATION}:
-        try:
-            certs[slot] = session.get_certificate(slot)
-        except ApduError:
-            pass
-        except BadResponseError:
-            certs[slot] = None  # type: ignore
-
-    return certs
-
-
-def check_key(
-    session: PivSession,
-    slot: SLOT,
-    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
-) -> bool:
-    """Check that a given public key corresponds to the private key in a slot.
-
-    This will create a signature using the private key, so the PIN must be verified
-    prior to calling this function if the PIN policy requires it.
-    """
-    try:
-        test_data = b"test"
-        logger.debug(
-            "Testing private key by creating a test signature, and verifying it"
-        )
-
-        test_sig = session.sign(
-            slot,
-            KEY_TYPE.from_public_key(public_key),
-            test_data,
-            hashes.SHA256(),
-            padding.PKCS1v15(),  # Only used for RSA
-        )
-
-        if isinstance(public_key, rsa.RSAPublicKey):
-            public_key.verify(
-                test_sig,
-                test_data,
-                padding.PKCS1v15(),
-                hashes.SHA256(),
-            )
-        elif isinstance(public_key, ec.EllipticCurvePublicKey):
-            public_key.verify(test_sig, test_data, ec.ECDSA(hashes.SHA256()))
-        else:
-            raise ValueError("Unknown key type: " + type(public_key))
-        return True
-
-    except ApduError as e:
-        if e.sw in (SW.INCORRECT_PARAMETERS, SW.WRONG_PARAMETERS_P1P2):
-            logger.debug(f"Couldn't create signature: SW={e.sw:04x}")
-            return False
-        raise
-
-    except InvalidSignature:
-        logger.debug("Signature verification failed")
-        return False
-
-
-def generate_chuid() -> bytes:
-    """Generates a CHUID (Cardholder Unique Identifier)."""
-    # Non-Federal Issuer FASC-N
-    # [9999-9999-999999-0-1-0000000000300001]
-    FASC_N = (
-        b"\xd4\xe7\x39\xda\x73\x9c\xed\x39\xce\x73\x9d\x83\x68"
-        + b"\x58\x21\x08\x42\x10\x84\x21\xc8\x42\x10\xc3\xeb"
-    )
-    # Expires on: 2030-01-01
-    EXPIRY = b"\x32\x30\x33\x30\x30\x31\x30\x31"
-
-    return (
-        Tlv(0x30, FASC_N)
-        + Tlv(0x34, os.urandom(16))
-        + Tlv(0x35, EXPIRY)
-        + Tlv(0x3E)
-        + Tlv(TAG_LRC)
-    )
-
-
-def generate_ccc() -> bytes:
-    """Generates a CCC (Card Capability Container)."""
-    return (
-        Tlv(0xF0, b"\xa0\x00\x00\x01\x16\xff\x02" + os.urandom(14))
-        + Tlv(0xF1, b"\x21")
-        + Tlv(0xF2, b"\x21")
-        + Tlv(0xF3)
-        + Tlv(0xF4, b"\x00")
-        + Tlv(0xF5, b"\x10")
-        + Tlv(0xF6)
-        + Tlv(0xF7)
-        + Tlv(0xFA)
-        + Tlv(0xFB)
-        + Tlv(0xFC)
-        + Tlv(0xFD)
-        + Tlv(TAG_LRC)
-    )
-
-
-def get_piv_info(session: PivSession):
-    """Get human readable information about the PIV configuration."""
-    pivman = get_pivman_data(session)
-    info: Dict[str, Any] = {
-        "PIV version": session.version,
-    }
-    lines: List[Any] = [info]
-
-    try:
-        pin_data = session.get_pin_metadata()
-        if pin_data.default_value:
-            lines.append("WARNING: Using default PIN!")
-        tries_str = "%d/%d" % (pin_data.attempts_remaining, pin_data.total_attempts)
-    except NotSupportedError:
-        # Largest possible number of PIN tries to get back is 15
-        tries = session.get_pin_attempts()
-        tries_str = "15 or more" if tries == 15 else str(tries)
-    info["PIN tries remaining"] = tries_str
-    if pivman.puk_blocked:
-        lines.append("PUK is blocked")
-
-    try:
-        metadata = session.get_management_key_metadata()
-        if metadata.default_value:
-            lines.append("WARNING: Using default Management key!")
-        key_type = metadata.key_type
-    except NotSupportedError:
-        key_type = MANAGEMENT_KEY_TYPE.TDES
-    info["Management key algorithm"] = key_type.name
-
-    if pivman.has_derived_key:
-        lines.append("Management key is derived from PIN.")
-    if pivman.has_stored_key:
-        lines.append("Management key is stored on the YubiKey, protected by PIN.")
-
-    objects: Dict[str, Any] = {}
-    lines.append(objects)
-    try:
-        objects["CHUID"] = session.get_object(OBJECT_ID.CHUID)
-    except ApduError as e:
-        if e.sw == SW.FILE_NOT_FOUND:
-            objects["CHUID"] = "No data available"
-
-    try:
-        objects["CCC"] = session.get_object(OBJECT_ID.CAPABILITY)
-    except ApduError as e:
-        if e.sw == SW.FILE_NOT_FOUND:
-            objects["CCC"] = "No data available"
-
-    for slot, cert in list_certificates(session).items():
-        cert_data: Dict[str, Any] = {}
-        objects[f"Slot {slot}"] = cert_data
-        if cert:
-            try:
-                # Try to read out full DN, fallback to only CN.
-                # Support for DN was added in crytography 2.5
-                subject_dn = cert.subject.rfc4514_string()
-                issuer_dn = cert.issuer.rfc4514_string()
-                print_dn = True
-            except AttributeError:
-                print_dn = False
-                logger.debug("Failed to read DN, falling back to only CNs")
-                cn = cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)
-                subject_cn = cn[0].value if cn else "None"
-                cn = cert.issuer.get_attributes_for_oid(x509.NameOID.COMMON_NAME)
-                issuer_cn = cn[0].value if cn else "None"
-            except ValueError as e:
-                # Malformed certificates may throw ValueError
-                logger.debug("Failed parsing certificate", exc_info=True)
-                cert_data["Error"] = f"Malformed certificate: {e}"
-                continue
-
-            fingerprint = cert.fingerprint(hashes.SHA256()).hex()
-            try:
-                key_algo = KEY_TYPE.from_public_key(cert.public_key()).name
-            except ValueError:
-                key_algo = "Unsupported"
-            serial = cert.serial_number
-            try:
-                not_before: Optional[datetime] = cert.not_valid_before
-            except ValueError:
-                logger.debug("Failed reading not_valid_before", exc_info=True)
-                not_before = None
-            try:
-                not_after: Optional[datetime] = cert.not_valid_after
-            except ValueError:
-                logger.debug("Failed reading not_valid_after", exc_info=True)
-                not_after = None
-
-            # Print out everything
-            cert_data["Algorithm"] = key_algo
-            if print_dn:
-                cert_data["Subject DN"] = subject_dn
-                cert_data["Issuer DN"] = issuer_dn
-            else:
-                cert_data["Subject CN"] = subject_cn
-                cert_data["Issuer CN"] = issuer_cn
-            cert_data["Serial"] = serial
-            cert_data["Fingerprint"] = fingerprint
-            if not_before:
-                cert_data["Not before"] = not_before.isoformat()
-            if not_after:
-                cert_data["Not after"] = not_after.isoformat()
-        else:
-            cert_data["Error"] = "Failed to parse certificate"
-
-    return lines
-
-
-_AllowedHashTypes = Union[
-    hashes.SHA224,
-    hashes.SHA256,
-    hashes.SHA384,
-    hashes.SHA512,
-    hashes.SHA3_224,
-    hashes.SHA3_256,
-    hashes.SHA3_384,
-    hashes.SHA3_512,
-]
-
-
-def sign_certificate_builder(
-    session: PivSession,
-    slot: SLOT,
-    key_type: KEY_TYPE,
-    builder: x509.CertificateBuilder,
-    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
-) -> x509.Certificate:
-    """Sign a Certificate."""
-    logger.debug("Signing a certificate")
-    dummy_key = _dummy_key(key_type)
-    cert = builder.sign(dummy_key, hash_algorithm(), default_backend())
-
-    sig = session.sign(
-        slot,
-        key_type,
-        cert.tbs_certificate_bytes,
-        hash_algorithm(),
-        padding.PKCS1v15(),  # Only used for RSA
-    )
-
-    seq = Tlv.parse_list(Tlv.unpack(0x30, cert.public_bytes(Encoding.DER)))
-    # Replace signature, add unused bits = 0
-    seq[2] = Tlv(seq[2].tag, b"\0" + sig)
-    # Re-assemble sequence
-    der = Tlv(0x30, b"".join(seq))
-
-    return x509.load_der_x509_certificate(der, default_backend())
-
-
-def sign_csr_builder(
-    session: PivSession,
-    slot: SLOT,
-    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
-    builder: x509.CertificateSigningRequestBuilder,
-    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
-) -> x509.CertificateSigningRequest:
-    """Sign a CSR."""
-    logger.debug("Signing a CSR")
-    key_type = KEY_TYPE.from_public_key(public_key)
-    dummy_key = _dummy_key(key_type)
-    csr = builder.sign(dummy_key, hash_algorithm(), default_backend())
-    seq = Tlv.parse_list(Tlv.unpack(0x30, csr.public_bytes(Encoding.DER)))
-
-    # Replace public key
-    pub_format = (
-        PublicFormat.PKCS1
-        if key_type.algorithm == ALGORITHM.RSA
-        else PublicFormat.SubjectPublicKeyInfo
-    )
-    dummy_bytes = dummy_key.public_key().public_bytes(Encoding.DER, pub_format)
-    pub_bytes = public_key.public_bytes(Encoding.DER, pub_format)
-    seq[0] = Tlv(seq[0].replace(dummy_bytes, pub_bytes))
-
-    sig = session.sign(
-        slot,
-        key_type,
-        seq[0],
-        hash_algorithm(),
-        padding.PKCS1v15(),  # Only used for RSA
-    )
-
-    # Replace signature, add unused bits = 0
-    seq[2] = Tlv(seq[2].tag, b"\0" + sig)
-    # Re-assemble sequence
-    der = Tlv(0x30, b"".join(seq))
-
-    return x509.load_der_x509_csr(der, default_backend())
-
-
-def generate_self_signed_certificate(
-    session: PivSession,
-    slot: SLOT,
-    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
-    subject_str: str,
-    valid_from: datetime,
-    valid_to: datetime,
-    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
-) -> x509.Certificate:
-    """Generate a self-signed certificate using a private key in a slot."""
-    logger.debug("Generating a self-signed certificate")
-    key_type = KEY_TYPE.from_public_key(public_key)
-
-    subject = parse_rfc4514_string(subject_str)
-    builder = (
-        x509.CertificateBuilder()
-        .public_key(public_key)
-        .subject_name(subject)
-        .issuer_name(subject)  # Same as subject on self-signed certificate.
-        .serial_number(x509.random_serial_number())
-        .not_valid_before(valid_from)
-        .not_valid_after(valid_to)
-    )
-
-    return sign_certificate_builder(session, slot, key_type, builder, hash_algorithm)
-
-
-def generate_csr(
-    session: PivSession,
-    slot: SLOT,
-    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
-    subject_str: str,
-    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
-) -> x509.CertificateSigningRequest:
-    """Generate a CSR using a private key in a slot."""
-    logger.debug("Generating a CSR")
-    builder = x509.CertificateSigningRequestBuilder().subject_name(
-        parse_rfc4514_string(subject_str)
-    )
-
-    return sign_csr_builder(session, slot, public_key, builder, hash_algorithm)
+# Copyright (c) 2017 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+
+from yubikit.core import Tlv, BadResponseError, NotSupportedError
+from yubikit.core.smartcard import ApduError, SW
+from yubikit.piv import (
+    PivSession,
+    SLOT,
+    OBJECT_ID,
+    KEY_TYPE,
+    MANAGEMENT_KEY_TYPE,
+    ALGORITHM,
+    TAG_LRC,
+)
+
+from cryptography import x509
+from cryptography.exceptions import InvalidSignature
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding
+from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
+from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
+from cryptography.hazmat.backends import default_backend
+from cryptography.x509.oid import NameOID
+from collections import OrderedDict
+from datetime import datetime
+import logging
+import struct
+import os
+import re
+
+from typing import Union, Mapping, Optional, List, Dict, Type, Any, cast
+
+
+logger = logging.getLogger(__name__)
+
+
+OBJECT_ID_PIVMAN_DATA = 0x5FFF00
+OBJECT_ID_PIVMAN_PROTECTED_DATA = OBJECT_ID.PRINTED  # Use slot for printed information.
+
+
+_NAME_ATTRIBUTES = {
+    "CN": NameOID.COMMON_NAME,
+    "L": NameOID.LOCALITY_NAME,
+    "ST": NameOID.STATE_OR_PROVINCE_NAME,
+    "O": NameOID.ORGANIZATION_NAME,
+    "OU": NameOID.ORGANIZATIONAL_UNIT_NAME,
+    "C": NameOID.COUNTRY_NAME,
+    "STREET": NameOID.STREET_ADDRESS,
+    "DC": NameOID.DOMAIN_COMPONENT,
+    "UID": NameOID.USER_ID,
+}
+
+
+_ESCAPED = "\\\"+,'<> #="
+
+
+def _parse(value: str) -> List[List[str]]:
+    remaining = list(value)
+    name = []
+    entry = []
+    buf = ""
+    hexbuf = b""
+    while remaining:
+        c = remaining.pop(0)
+        if c == "\\":
+            c1 = remaining.pop(0)
+            if c1 in _ESCAPED:
+                c = c1
+            else:
+                c2 = remaining.pop(0)
+                hexbuf += bytes.fromhex(c1 + c2)
+                try:
+                    c = hexbuf.decode()
+                    hexbuf = b""
+                except UnicodeDecodeError:
+                    continue  # Possibly multi-byte, expect more hex
+        elif c in ",+":
+            entry.append(buf)
+            buf = ""
+            if c == ",":
+                name.append(entry)
+                entry = []
+            continue
+        if hexbuf:
+            raise ValueError("Invalid UTF-8 data")
+        buf += c
+    entry.append(buf)
+    name.append(entry)
+    return name
+
+
+_DOTTED_STRING_RE = re.compile(r"\d(\.\d+)+")
+
+
+def parse_rfc4514_string(value: str) -> x509.Name:
+    """Parses an RFC 4514 string into a x509.Name.
+
+    See: https://tools.ietf.org/html/rfc4514.html
+    """
+    name = _parse(value)
+    attributes: List[x509.RelativeDistinguishedName] = []
+    for entry in name:
+        parts = []
+        for part in entry:
+            if "=" not in part:
+                raise ValueError("Invalid RFC 4514 string")
+            k, v = part.split("=", 1)
+            if k in _NAME_ATTRIBUTES:
+                attr = _NAME_ATTRIBUTES[k]
+            elif _DOTTED_STRING_RE.fullmatch(k):
+                attr = x509.ObjectIdentifier(k)
+            else:
+                raise ValueError(f"Unsupported attribute: '{k}'")
+            parts.append(x509.NameAttribute(attr, v))
+        attributes.insert(0, x509.RelativeDistinguishedName(parts))
+
+    return x509.Name(attributes)
+
+
+def _dummy_key(algorithm):
+    if algorithm == KEY_TYPE.RSA1024:
+        return rsa.generate_private_key(65537, 1024, default_backend())  # nosec
+    if algorithm == KEY_TYPE.RSA2048:
+        return rsa.generate_private_key(65537, 2048, default_backend())
+    if algorithm == KEY_TYPE.ECCP256:
+        return ec.generate_private_key(ec.SECP256R1(), default_backend())
+    if algorithm == KEY_TYPE.ECCP384:
+        return ec.generate_private_key(ec.SECP384R1(), default_backend())
+    raise ValueError("Invalid algorithm")
+
+
+def derive_management_key(pin: str, salt: bytes) -> bytes:
+    """Derive a management key from the users PIN and a salt.
+
+    NOTE: This method of derivation is deprecated! Protect the management key using
+    PivmanProtectedData instead.
+    """
+    kdf = PBKDF2HMAC(hashes.SHA1(), 24, salt, 10000, default_backend())  # nosec
+    return kdf.derive(pin.encode("utf-8"))
+
+
+def generate_random_management_key(algorithm: MANAGEMENT_KEY_TYPE) -> bytes:
+    """Generates a new random management key."""
+    return os.urandom(algorithm.key_len)
+
+
+class PivmanData:
+    def __init__(self, raw_data: bytes = Tlv(0x80)):
+        data = Tlv.parse_dict(Tlv(raw_data).value)
+        self._flags = struct.unpack(">B", data[0x81])[0] if 0x81 in data else None
+        self.salt = data.get(0x82)
+        self.pin_timestamp = struct.unpack(">I", data[0x83]) if 0x83 in data else None
+
+    def _get_flag(self, mask: int) -> bool:
+        return bool((self._flags or 0) & mask)
+
+    def _set_flag(self, mask: int, value: bool) -> None:
+        if value:
+            self._flags = (self._flags or 0) | mask
+        elif self._flags is not None:
+            self._flags &= ~mask
+
+    @property
+    def puk_blocked(self) -> bool:
+        return self._get_flag(0x01)
+
+    @puk_blocked.setter
+    def puk_blocked(self, value: bool) -> None:
+        self._set_flag(0x01, value)
+
+    @property
+    def mgm_key_protected(self) -> bool:
+        return self._get_flag(0x02)
+
+    @mgm_key_protected.setter
+    def mgm_key_protected(self, value: bool) -> None:
+        self._set_flag(0x02, value)
+
+    @property
+    def has_protected_key(self) -> bool:
+        return self.has_derived_key or self.has_stored_key
+
+    @property
+    def has_derived_key(self) -> bool:
+        return self.salt is not None
+
+    @property
+    def has_stored_key(self) -> bool:
+        return self.mgm_key_protected
+
+    def get_bytes(self) -> bytes:
+        data = b""
+        if self._flags is not None:
+            data += Tlv(0x81, struct.pack(">B", self._flags))
+        if self.salt is not None:
+            data += Tlv(0x82, self.salt)
+        if self.pin_timestamp is not None:
+            data += Tlv(0x83, struct.pack(">I", self.pin_timestamp))
+        return Tlv(0x80, data)
+
+
+class PivmanProtectedData:
+    def __init__(self, raw_data: bytes = Tlv(0x88)):
+        data = Tlv.parse_dict(Tlv(raw_data).value)
+        self.key = data.get(0x89)
+
+    def get_bytes(self) -> bytes:
+        data = b""
+        if self.key is not None:
+            data += Tlv(0x89, self.key)
+        return Tlv(0x88, data)
+
+
+def get_pivman_data(session: PivSession) -> PivmanData:
+    """Reads out the Pivman data from a YubiKey."""
+    logger.debug("Reading pivman data")
+    try:
+        return PivmanData(session.get_object(OBJECT_ID_PIVMAN_DATA))
+    except ApduError as e:
+        if e.sw == SW.FILE_NOT_FOUND:
+            # No data there, initialise a new object.
+            logger.debug("No data, initializing blank")
+            return PivmanData()
+        raise
+
+
+def get_pivman_protected_data(session: PivSession) -> PivmanProtectedData:
+    """Reads out the Pivman protected data from a YubiKey.
+
+    This function requires PIN verification prior to being called.
+    """
+    logger.debug("Reading protected pivman data")
+    try:
+        return PivmanProtectedData(session.get_object(OBJECT_ID_PIVMAN_PROTECTED_DATA))
+    except ApduError as e:
+        if e.sw == SW.FILE_NOT_FOUND:
+            # No data there, initialise a new object.
+            logger.debug("No data, initializing blank")
+            return PivmanProtectedData()
+        raise
+
+
+def pivman_set_mgm_key(
+    session: PivSession,
+    new_key: bytes,
+    algorithm: MANAGEMENT_KEY_TYPE,
+    touch: bool = False,
+    store_on_device: bool = False,
+) -> None:
+    """Set a new management key, while keeping PivmanData in sync."""
+    pivman = get_pivman_data(session)
+    pivman_prot = None
+
+    if store_on_device or (not store_on_device and pivman.has_stored_key):
+        # Ensure we have access to protected data before overwriting key
+        try:
+            pivman_prot = get_pivman_protected_data(session)
+        except Exception:
+            logger.debug("Failed to initialize protected pivman data", exc_info=True)
+            if store_on_device:
+                raise
+
+    # Set the new management key
+    session.set_management_key(algorithm, new_key, touch)
+
+    if pivman.has_derived_key:
+        # Clear salt for old derived keys.
+        logger.debug("Clearing salt in pivman data")
+        pivman.salt = None
+
+    # Set flag for stored or not stored key.
+    pivman.mgm_key_protected = store_on_device
+
+    # Update readable pivman data
+    session.put_object(OBJECT_ID_PIVMAN_DATA, pivman.get_bytes())
+
+    if pivman_prot is not None:
+        if store_on_device:
+            # Store key in protected pivman data
+            logger.debug("Storing key in protected pivman data")
+            pivman_prot.key = new_key
+            session.put_object(OBJECT_ID_PIVMAN_PROTECTED_DATA, pivman_prot.get_bytes())
+        elif pivman_prot.key:
+            # If new key should not be stored and there is an old stored key,
+            # try to clear it.
+            logger.debug("Clearing old key in protected pivman data")
+            try:
+                pivman_prot.key = None
+                session.put_object(
+                    OBJECT_ID_PIVMAN_PROTECTED_DATA,
+                    pivman_prot.get_bytes(),
+                )
+            except ApduError:
+                logger.debug("No PIN provided, can't clear key...", exc_info=True)
+
+
+def pivman_change_pin(session: PivSession, old_pin: str, new_pin: str) -> None:
+    """Change the PIN, while keeping PivmanData in sync."""
+    session.change_pin(old_pin, new_pin)
+
+    pivman = get_pivman_data(session)
+    if pivman.has_derived_key:
+        logger.debug("Has derived management key, update for new PIN")
+        session.authenticate(
+            MANAGEMENT_KEY_TYPE.TDES,
+            derive_management_key(old_pin, cast(bytes, pivman.salt)),
+        )
+        session.verify_pin(new_pin)
+        new_salt = os.urandom(16)
+        new_key = derive_management_key(new_pin, new_salt)
+        session.set_management_key(MANAGEMENT_KEY_TYPE.TDES, new_key)
+        pivman.salt = new_salt
+        session.put_object(OBJECT_ID_PIVMAN_DATA, pivman.get_bytes())
+
+
+def list_certificates(session: PivSession) -> Mapping[SLOT, Optional[x509.Certificate]]:
+    """Reads out and parses stored certificates.
+
+    Only certificates which are successfully parsed are returned.
+    """
+    certs = OrderedDict()
+    for slot in set(SLOT) - {SLOT.ATTESTATION}:
+        try:
+            certs[slot] = session.get_certificate(slot)
+        except ApduError:
+            pass
+        except BadResponseError:
+            certs[slot] = None  # type: ignore
+
+    return certs
+
+
+def check_key(
+    session: PivSession,
+    slot: SLOT,
+    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
+) -> bool:
+    """Check that a given public key corresponds to the private key in a slot.
+
+    This will create a signature using the private key, so the PIN must be verified
+    prior to calling this function if the PIN policy requires it.
+    """
+    try:
+        test_data = b"test"
+        logger.debug(
+            "Testing private key by creating a test signature, and verifying it"
+        )
+
+        test_sig = session.sign(
+            slot,
+            KEY_TYPE.from_public_key(public_key),
+            test_data,
+            hashes.SHA256(),
+            padding.PKCS1v15(),  # Only used for RSA
+        )
+
+        if isinstance(public_key, rsa.RSAPublicKey):
+            public_key.verify(
+                test_sig,
+                test_data,
+                padding.PKCS1v15(),
+                hashes.SHA256(),
+            )
+        elif isinstance(public_key, ec.EllipticCurvePublicKey):
+            public_key.verify(test_sig, test_data, ec.ECDSA(hashes.SHA256()))
+        else:
+            raise ValueError("Unknown key type: " + type(public_key))
+        return True
+
+    except ApduError as e:
+        if e.sw in (SW.INCORRECT_PARAMETERS, SW.WRONG_PARAMETERS_P1P2):
+            logger.debug(f"Couldn't create signature: SW={e.sw:04x}")
+            return False
+        raise
+
+    except InvalidSignature:
+        logger.debug("Signature verification failed")
+        return False
+
+
+def generate_chuid() -> bytes:
+    """Generates a CHUID (Cardholder Unique Identifier)."""
+    # Non-Federal Issuer FASC-N
+    # [9999-9999-999999-0-1-0000000000300001]
+    FASC_N = (
+        b"\xd4\xe7\x39\xda\x73\x9c\xed\x39\xce\x73\x9d\x83\x68"
+        + b"\x58\x21\x08\x42\x10\x84\x21\xc8\x42\x10\xc3\xeb"
+    )
+    # Expires on: 2030-01-01
+    EXPIRY = b"\x32\x30\x33\x30\x30\x31\x30\x31"
+
+    return (
+        Tlv(0x30, FASC_N)
+        + Tlv(0x34, os.urandom(16))
+        + Tlv(0x35, EXPIRY)
+        + Tlv(0x3E)
+        + Tlv(TAG_LRC)
+    )
+
+
+def generate_ccc() -> bytes:
+    """Generates a CCC (Card Capability Container)."""
+    return (
+        Tlv(0xF0, b"\xa0\x00\x00\x01\x16\xff\x02" + os.urandom(14))
+        + Tlv(0xF1, b"\x21")
+        + Tlv(0xF2, b"\x21")
+        + Tlv(0xF3)
+        + Tlv(0xF4, b"\x00")
+        + Tlv(0xF5, b"\x10")
+        + Tlv(0xF6)
+        + Tlv(0xF7)
+        + Tlv(0xFA)
+        + Tlv(0xFB)
+        + Tlv(0xFC)
+        + Tlv(0xFD)
+        + Tlv(TAG_LRC)
+    )
+
+
+def get_piv_info(session: PivSession):
+    """Get human readable information about the PIV configuration."""
+    pivman = get_pivman_data(session)
+    info: Dict[str, Any] = {
+        "PIV version": session.version,
+    }
+    lines: List[Any] = [info]
+
+    try:
+        pin_data = session.get_pin_metadata()
+        if pin_data.default_value:
+            lines.append("WARNING: Using default PIN!")
+        tries_str = "%d/%d" % (pin_data.attempts_remaining, pin_data.total_attempts)
+    except NotSupportedError:
+        # Largest possible number of PIN tries to get back is 15
+        tries = session.get_pin_attempts()
+        tries_str = "15 or more" if tries == 15 else str(tries)
+    info["PIN tries remaining"] = tries_str
+    if pivman.puk_blocked:
+        lines.append("PUK is blocked")
+
+    try:
+        metadata = session.get_management_key_metadata()
+        if metadata.default_value:
+            lines.append("WARNING: Using default Management key!")
+        key_type = metadata.key_type
+    except NotSupportedError:
+        key_type = MANAGEMENT_KEY_TYPE.TDES
+    info["Management key algorithm"] = key_type.name
+
+    if pivman.has_derived_key:
+        lines.append("Management key is derived from PIN.")
+    if pivman.has_stored_key:
+        lines.append("Management key is stored on the YubiKey, protected by PIN.")
+
+    objects: Dict[str, Any] = {}
+    lines.append(objects)
+    try:
+        objects["CHUID"] = session.get_object(OBJECT_ID.CHUID)
+    except ApduError as e:
+        if e.sw == SW.FILE_NOT_FOUND:
+            objects["CHUID"] = "No data available"
+
+    try:
+        objects["CCC"] = session.get_object(OBJECT_ID.CAPABILITY)
+    except ApduError as e:
+        if e.sw == SW.FILE_NOT_FOUND:
+            objects["CCC"] = "No data available"
+
+    for slot, cert in list_certificates(session).items():
+        cert_data: Dict[str, Any] = {}
+        objects[f"Slot {slot}"] = cert_data
+        if cert:
+            try:
+                # Try to read out full DN, fallback to only CN.
+                # Support for DN was added in crytography 2.5
+                subject_dn = cert.subject.rfc4514_string()
+                issuer_dn = cert.issuer.rfc4514_string()
+                print_dn = True
+            except AttributeError:
+                print_dn = False
+                logger.debug("Failed to read DN, falling back to only CNs")
+                cn = cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)
+                subject_cn = cn[0].value if cn else "None"
+                cn = cert.issuer.get_attributes_for_oid(x509.NameOID.COMMON_NAME)
+                issuer_cn = cn[0].value if cn else "None"
+            except ValueError as e:
+                # Malformed certificates may throw ValueError
+                logger.debug("Failed parsing certificate", exc_info=True)
+                cert_data["Error"] = f"Malformed certificate: {e}"
+                continue
+
+            fingerprint = cert.fingerprint(hashes.SHA256()).hex()
+            try:
+                key_algo = KEY_TYPE.from_public_key(cert.public_key()).name
+            except ValueError:
+                key_algo = "Unsupported"
+            serial = cert.serial_number
+            try:
+                not_before: Optional[datetime] = cert.not_valid_before
+            except ValueError:
+                logger.debug("Failed reading not_valid_before", exc_info=True)
+                not_before = None
+            try:
+                not_after: Optional[datetime] = cert.not_valid_after
+            except ValueError:
+                logger.debug("Failed reading not_valid_after", exc_info=True)
+                not_after = None
+
+            # Print out everything
+            cert_data["Algorithm"] = key_algo
+            if print_dn:
+                cert_data["Subject DN"] = subject_dn
+                cert_data["Issuer DN"] = issuer_dn
+            else:
+                cert_data["Subject CN"] = subject_cn
+                cert_data["Issuer CN"] = issuer_cn
+            cert_data["Serial"] = serial
+            cert_data["Fingerprint"] = fingerprint
+            if not_before:
+                cert_data["Not before"] = not_before.isoformat()
+            if not_after:
+                cert_data["Not after"] = not_after.isoformat()
+        else:
+            cert_data["Error"] = "Failed to parse certificate"
+
+    return lines
+
+
+_AllowedHashTypes = Union[
+    hashes.SHA224,
+    hashes.SHA256,
+    hashes.SHA384,
+    hashes.SHA512,
+    hashes.SHA3_224,
+    hashes.SHA3_256,
+    hashes.SHA3_384,
+    hashes.SHA3_512,
+]
+
+
+def sign_certificate_builder(
+    session: PivSession,
+    slot: SLOT,
+    key_type: KEY_TYPE,
+    builder: x509.CertificateBuilder,
+    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
+) -> x509.Certificate:
+    """Sign a Certificate."""
+    logger.debug("Signing a certificate")
+    dummy_key = _dummy_key(key_type)
+    cert = builder.sign(dummy_key, hash_algorithm(), default_backend())
+
+    sig = session.sign(
+        slot,
+        key_type,
+        cert.tbs_certificate_bytes,
+        hash_algorithm(),
+        padding.PKCS1v15(),  # Only used for RSA
+    )
+
+    seq = Tlv.parse_list(Tlv.unpack(0x30, cert.public_bytes(Encoding.DER)))
+    # Replace signature, add unused bits = 0
+    seq[2] = Tlv(seq[2].tag, b"\0" + sig)
+    # Re-assemble sequence
+    der = Tlv(0x30, b"".join(seq))
+
+    return x509.load_der_x509_certificate(der, default_backend())
+
+
+def sign_csr_builder(
+    session: PivSession,
+    slot: SLOT,
+    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
+    builder: x509.CertificateSigningRequestBuilder,
+    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
+) -> x509.CertificateSigningRequest:
+    """Sign a CSR."""
+    logger.debug("Signing a CSR")
+    key_type = KEY_TYPE.from_public_key(public_key)
+    dummy_key = _dummy_key(key_type)
+    csr = builder.sign(dummy_key, hash_algorithm(), default_backend())
+    seq = Tlv.parse_list(Tlv.unpack(0x30, csr.public_bytes(Encoding.DER)))
+
+    # Replace public key
+    pub_format = (
+        PublicFormat.PKCS1
+        if key_type.algorithm == ALGORITHM.RSA
+        else PublicFormat.SubjectPublicKeyInfo
+    )
+    dummy_bytes = dummy_key.public_key().public_bytes(Encoding.DER, pub_format)
+    pub_bytes = public_key.public_bytes(Encoding.DER, pub_format)
+    seq[0] = Tlv(seq[0].replace(dummy_bytes, pub_bytes))
+
+    sig = session.sign(
+        slot,
+        key_type,
+        seq[0],
+        hash_algorithm(),
+        padding.PKCS1v15(),  # Only used for RSA
+    )
+
+    # Replace signature, add unused bits = 0
+    seq[2] = Tlv(seq[2].tag, b"\0" + sig)
+    # Re-assemble sequence
+    der = Tlv(0x30, b"".join(seq))
+
+    return x509.load_der_x509_csr(der, default_backend())
+
+
+def generate_self_signed_certificate(
+    session: PivSession,
+    slot: SLOT,
+    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
+    subject_str: str,
+    valid_from: datetime,
+    valid_to: datetime,
+    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
+) -> x509.Certificate:
+    """Generate a self-signed certificate using a private key in a slot."""
+    logger.debug("Generating a self-signed certificate")
+    key_type = KEY_TYPE.from_public_key(public_key)
+
+    subject = parse_rfc4514_string(subject_str)
+    builder = (
+        x509.CertificateBuilder()
+        .public_key(public_key)
+        .subject_name(subject)
+        .issuer_name(subject)  # Same as subject on self-signed certificate.
+        .serial_number(x509.random_serial_number())
+        .not_valid_before(valid_from)
+        .not_valid_after(valid_to)
+    )
+
+    return sign_certificate_builder(session, slot, key_type, builder, hash_algorithm)
+
+
+def generate_csr(
+    session: PivSession,
+    slot: SLOT,
+    public_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
+    subject_str: str,
+    hash_algorithm: Type[_AllowedHashTypes] = hashes.SHA256,
+) -> x509.CertificateSigningRequest:
+    """Generate a CSR using a private key in a slot."""
+    logger.debug("Generating a CSR")
+    builder = x509.CertificateSigningRequestBuilder().subject_name(
+        parse_rfc4514_string(subject_str)
+    )
+
+    return sign_csr_builder(session, slot, public_key, builder, hash_algorithm)
```

### Comparing `yubikey_manager-5.1.0/ykman/scancodes/__init__.py` & `yubikey_manager-5.1.1/ykman/scancodes/__init__.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from enum import Enum
-from . import us, uk, de, fr, it, modhex, norman, bepo
-
-
-class KEYBOARD_LAYOUT(Enum):
-    MODHEX = modhex.scancodes
-    US = us.scancodes
-    UK = uk.scancodes
-    DE = de.scancodes
-    FR = fr.scancodes
-    IT = it.scancodes
-    BEPO = bepo.scancodes
-    NORMAN = norman.scancodes
-
-
-def encode(data, keyboard_layout=KEYBOARD_LAYOUT.MODHEX):
-    try:
-        return bytes(bytearray(keyboard_layout.value[c] for c in data))
-    except KeyError as e:
-        raise ValueError(f"Unsupported character: {e.args[0]}")
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from enum import Enum
+from . import us, uk, de, fr, it, modhex, norman, bepo
+
+
+class KEYBOARD_LAYOUT(Enum):
+    MODHEX = modhex.scancodes
+    US = us.scancodes
+    UK = uk.scancodes
+    DE = de.scancodes
+    FR = fr.scancodes
+    IT = it.scancodes
+    BEPO = bepo.scancodes
+    NORMAN = norman.scancodes
+
+
+def encode(data, keyboard_layout=KEYBOARD_LAYOUT.MODHEX):
+    try:
+        return bytes(bytearray(keyboard_layout.value[c] for c in data))
+    except KeyError as e:
+        raise ValueError(f"Unsupported character: {e.args[0]}")
```

### Comparing `yubikey_manager-5.1.0/ykman/scancodes/bepo.py` & `yubikey_manager-5.1.1/ykman/scancodes/it.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,134 +1,137 @@
-#  vim: set fileencoding:utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-"""Scancode map for BPO (fr dvorak) keyboard layout"""
-
-SHIFT = 0x80
-
-scancodes = {
-    "\t": 0x2B | SHIFT,
-    "\n": 0x28 | SHIFT,
-    " ": 0x2C,
-    "!": 0x1C | SHIFT,
-    '"': 0x1E,
-    "#": 0x35 | SHIFT,
-    "$": 0x35,
-    "%": 0x2E,
-    "'": 0x11,
-    "(": 0x21,
-    ")": 0x22,
-    "*": 0x27,
-    "+": 0x24,
-    ",": 0x0A,
-    "-": 0x25,
-    ".": 0x19,
-    "/": 0x26,
-    "0": 0x27 | SHIFT,
-    "1": 0x1E | SHIFT,
-    "2": 0x1F | SHIFT,
-    "3": 0x20 | SHIFT,
-    "4": 0x21 | SHIFT,
-    "5": 0x22 | SHIFT,
-    "6": 0x23 | SHIFT,
-    "7": 0x24 | SHIFT,
-    "8": 0x25 | SHIFT,
-    "9": 0x26 | SHIFT,
-    ":": 0x19 | SHIFT,
-    ";": 0x0A | SHIFT,
-    "=": 0x2D,
-    "?": 0x11 | SHIFT,
-    "@": 0x23,
-    "A": 0x04 | SHIFT,
-    "B": 0x14 | SHIFT,
-    "C": 0x0B | SHIFT,
-    "D": 0x0C | SHIFT,
-    "E": 0x09 | SHIFT,
-    "F": 0x38 | SHIFT,
-    "G": 0x36 | SHIFT,
-    "H": 0x37 | SHIFT,
-    "I": 0x07 | SHIFT,
-    "J": 0x13 | SHIFT,
-    "K": 0x05 | SHIFT,
-    "L": 0x12 | SHIFT,
-    "M": 0x34 | SHIFT,
-    "N": 0x33 | SHIFT,
-    "O": 0x15 | SHIFT,
-    "P": 0x08 | SHIFT,
-    "Q": 0x10 | SHIFT,
-    "R": 0x0F | SHIFT,
-    "S": 0x0E | SHIFT,
-    "T": 0x0D | SHIFT,
-    "U": 0x16 | SHIFT,
-    "V": 0x18 | SHIFT,
-    "W": 0x30 | SHIFT,
-    "X": 0x06 | SHIFT,
-    "Y": 0x1B | SHIFT,
-    "Z": 0x2F | SHIFT,
-    "`": 0x2E | SHIFT,
-    "a": 0x04,
-    "b": 0x14,
-    "c": 0x0B,
-    "d": 0x0C,
-    "e": 0x09,
-    "f": 0x38,
-    "g": 0x36,
-    "h": 0x37,
-    "i": 0x07,
-    "j": 0x13,
-    "k": 0x05,
-    "l": 0x12,
-    "m": 0x34,
-    "n": 0x33,
-    "o": 0x15,
-    "p": 0x08,
-    "q": 0x10,
-    "r": 0x0F,
-    "s": 0x0E,
-    "t": 0x0D,
-    "u": 0x16,
-    "v": 0x18,
-    "w": 0x30,
-    "x": 0x06,
-    "y": 0x1B,
-    "z": 0x2F,
-    "\xa0": 0x2C | SHIFT,
-    "": 0x1F,
-    "": 0x2D | SHIFT,
-    "": 0x20,
-    "": 0x1D | SHIFT,
-    "": 0x31 | SHIFT,
-    "": 0x17 | SHIFT,
-    "": 0x1A | SHIFT,
-    "": 0x64 | SHIFT,
-    "": 0x1D,
-    "": 0x31,
-    "": 0x17,
-    "": 0x1A,
-    "": 0x64,
-}
+#  vim: set fileencoding:utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+"""Scancode map for IT Italian (AZERTY) keyboard layout"""
+
+SHIFT = 0x80
+
+scancodes = {
+    "\t": 0x2B,
+    "\n": 0x28,
+    " ": 0x2C,
+    "!": 0x1E | SHIFT,
+    '"': 0x1F | SHIFT,
+    "#": 0x32,
+    "$": 0x21 | SHIFT,
+    "%": 0x22 | SHIFT,
+    "&": 0x23 | SHIFT,
+    "'": 0x2D,
+    "(": 0x25 | SHIFT,
+    ")": 0x26 | SHIFT,
+    "*": 0x55,
+    "+": 0x30,
+    ",": 0x36,
+    "-": 0x38,
+    ".": 0x63,
+    "/": 0x24 | SHIFT,
+    "0": 0x27,
+    "1": 0x1E,
+    "2": 0x1F,
+    "3": 0x20,
+    "4": 0x21,
+    "5": 0x22,
+    "6": 0x23,
+    "7": 0x24,
+    "8": 0x25,
+    "9": 0x26,
+    ":": 0xB7,
+    ";": 0xB6,
+    "<": 0x64,
+    "=": 0x27 | SHIFT,
+    ">": 0x64 | SHIFT,
+    "?": 0x2D | SHIFT,
+    "@": 0x24,
+    "A": 0x04 | SHIFT,
+    "B": 0x05 | SHIFT,
+    "C": 0x06 | SHIFT,
+    "D": 0x07 | SHIFT,
+    "E": 0x08 | SHIFT,
+    "F": 0x09 | SHIFT,
+    "G": 0x0A | SHIFT,
+    "H": 0x0B | SHIFT,
+    "I": 0x0C | SHIFT,
+    "J": 0x0D | SHIFT,
+    "K": 0x0E | SHIFT,
+    "L": 0x0F | SHIFT,
+    "M": 0x10 | SHIFT,
+    "N": 0x11 | SHIFT,
+    "O": 0x12 | SHIFT,
+    "P": 0x13 | SHIFT,
+    "Q": 0x14 | SHIFT,
+    "R": 0x15 | SHIFT,
+    "S": 0x16 | SHIFT,
+    "T": 0x17 | SHIFT,
+    "U": 0x18 | SHIFT,
+    "V": 0x19 | SHIFT,
+    "W": 0x1A | SHIFT,
+    "X": 0x1B | SHIFT,
+    "Y": 0x1C | SHIFT,
+    "Z": 0x1D | SHIFT,
+    "\\": 0x35,
+    "^": 0xAE,
+    "_": 0xB8,
+    "`": 0x2D | SHIFT,
+    "a": 0x04,
+    "b": 0x05,
+    "c": 0x06,
+    "d": 0x07,
+    "e": 0x08,
+    "f": 0x09,
+    "g": 0x0A,
+    "h": 0x0B,
+    "i": 0x0C,
+    "j": 0x0D,
+    "k": 0x0E,
+    "l": 0x0F,
+    "m": 0x10,
+    "n": 0x11,
+    "o": 0x12,
+    "p": 0x13,
+    "q": 0x14,
+    "r": 0x15,
+    "s": 0x16,
+    "t": 0x17,
+    "u": 0x18,
+    "v": 0x19,
+    "w": 0x1A,
+    "x": 0x1B,
+    "y": 0x1C,
+    "z": 0x1D,
+    "|": 0xB5,
+    "": 0xA0,
+    "": 0xB2,
+    "": 0xB4,
+    "": 0xB3,
+    "": 0x2F,
+    "": 0x2F | SHIFT,
+    "": 0x34,
+    "": 0x2E,
+    "": 0x33,
+    "": 0x31,
+}
```

### Comparing `yubikey_manager-5.1.0/ykman/scancodes/de.py` & `yubikey_manager-5.1.1/ykman/scancodes/uk.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,133 +1,132 @@
-#  vim: set fileencoding=utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-"""Scancode map for DE German keyboard layout"""
-
-SHIFT = 0x80
-
-scancodes = {
-    "a": 0x04,
-    "b": 0x05,
-    "c": 0x06,
-    "d": 0x07,
-    "e": 0x08,
-    "f": 0x09,
-    "g": 0x0A,
-    "h": 0x0B,
-    "i": 0x0C,
-    "j": 0x0D,
-    "k": 0x0E,
-    "l": 0x0F,
-    "m": 0x10,
-    "n": 0x11,
-    "o": 0x12,
-    "p": 0x13,
-    "q": 0x14,
-    "r": 0x15,
-    "s": 0x16,
-    "t": 0x17,
-    "u": 0x18,
-    "v": 0x19,
-    "w": 0x1A,
-    "x": 0x1B,
-    "y": 0x1D,
-    "z": 0x1C,
-    "A": 0x04 | SHIFT,
-    "B": 0x05 | SHIFT,
-    "C": 0x06 | SHIFT,
-    "D": 0x07 | SHIFT,
-    "E": 0x08 | SHIFT,
-    "F": 0x09 | SHIFT,
-    "G": 0x0A | SHIFT,
-    "H": 0x0B | SHIFT,
-    "I": 0x0C | SHIFT,
-    "J": 0x0D | SHIFT,
-    "K": 0x0E | SHIFT,
-    "L": 0x0F | SHIFT,
-    "M": 0x10 | SHIFT,
-    "N": 0x11 | SHIFT,
-    "O": 0x12 | SHIFT,
-    "P": 0x13 | SHIFT,
-    "Q": 0x14 | SHIFT,
-    "R": 0x15 | SHIFT,
-    "S": 0x16 | SHIFT,
-    "T": 0x17 | SHIFT,
-    "U": 0x18 | SHIFT,
-    "V": 0x19 | SHIFT,
-    "W": 0x1A | SHIFT,
-    "X": 0x1B | SHIFT,
-    "Y": 0x1D | SHIFT,
-    "Z": 0x1C | SHIFT,
-    "0": 0x27,
-    "1": 0x1E,
-    "2": 0x1F,
-    "3": 0x20,
-    "4": 0x21,
-    "5": 0x22,
-    "6": 0x23,
-    "7": 0x24,
-    "8": 0x25,
-    "9": 0x26,
-    "\t": 0x2B,
-    "\n": 0x28,
-    "!": 0x1E | SHIFT,
-    '"': 0x1F | SHIFT,
-    "#": 0x32,
-    "$": 0x21 | SHIFT,
-    "%": 0x22 | SHIFT,
-    "&": 0x23 | SHIFT,
-    "'": 0x32 | SHIFT,
-    "(": 0x25 | SHIFT,
-    ")": 0x26 | SHIFT,
-    "*": 0x30 | SHIFT,
-    "+": 0x30,
-    ",": 0x36,
-    "-": 0x38,
-    ".": 0x37,
-    "/": 0x24 | SHIFT,
-    ":": 0x37 | SHIFT,
-    ";": 0x36 | SHIFT,
-    "<": 0x64,
-    "=": 0x27 | SHIFT,
-    ">": 0x64 | SHIFT,
-    "?": 0x2D | SHIFT,
-    "^": 0x35,
-    "_": 0x38 | SHIFT,
-    " ": 0x2C,
-    "`": 0x2D | SHIFT,
-    "": 0x20 | SHIFT,
-    "": 0x2E,
-    "": 0x34 | SHIFT,
-    "": 0x33 | SHIFT,
-    "": 0x2F | SHIFT,
-    "": 0x2D,
-    "": 0x34,
-    "": 0x33,
-    "": 0x2F,
-}
+#  vim: set fileencoding=utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+"""Scancode map for UK English keyboard layout"""
+
+SHIFT = 0x80
+
+scancodes = {
+    "a": 0x04,
+    "b": 0x05,
+    "c": 0x06,
+    "d": 0x07,
+    "e": 0x08,
+    "f": 0x09,
+    "g": 0x0A,
+    "h": 0x0B,
+    "i": 0x0C,
+    "j": 0x0D,
+    "k": 0x0E,
+    "l": 0x0F,
+    "m": 0x10,
+    "n": 0x11,
+    "o": 0x12,
+    "p": 0x13,
+    "q": 0x14,
+    "r": 0x15,
+    "s": 0x16,
+    "t": 0x17,
+    "u": 0x18,
+    "v": 0x19,
+    "w": 0x1A,
+    "x": 0x1B,
+    "y": 0x1C,
+    "z": 0x1D,
+    "A": 0x04 | SHIFT,
+    "B": 0x05 | SHIFT,
+    "C": 0x06 | SHIFT,
+    "D": 0x07 | SHIFT,
+    "E": 0x08 | SHIFT,
+    "F": 0x09 | SHIFT,
+    "G": 0x0A | SHIFT,
+    "H": 0x0B | SHIFT,
+    "I": 0x0C | SHIFT,
+    "J": 0x0D | SHIFT,
+    "K": 0x0E | SHIFT,
+    "L": 0x0F | SHIFT,
+    "M": 0x10 | SHIFT,
+    "N": 0x11 | SHIFT,
+    "O": 0x12 | SHIFT,
+    "P": 0x13 | SHIFT,
+    "Q": 0x14 | SHIFT,
+    "R": 0x15 | SHIFT,
+    "S": 0x16 | SHIFT,
+    "T": 0x17 | SHIFT,
+    "U": 0x18 | SHIFT,
+    "V": 0x19 | SHIFT,
+    "W": 0x1A | SHIFT,
+    "X": 0x1B | SHIFT,
+    "Y": 0x1C | SHIFT,
+    "Z": 0x1D | SHIFT,
+    "0": 0x27,
+    "1": 0x1E,
+    "2": 0x1F,
+    "3": 0x20,
+    "4": 0x21,
+    "5": 0x22,
+    "6": 0x23,
+    "7": 0x24,
+    "8": 0x25,
+    "9": 0x26,
+    "\t": 0x2B,
+    "\n": 0x28,
+    "!": 0x1E | SHIFT,
+    "@": 0x34 | SHIFT,
+    "": 0x20 | SHIFT,
+    "$": 0x21 | SHIFT,
+    "%": 0x22 | SHIFT,
+    "&": 0x24 | SHIFT,
+    "'": 0x34,
+    "`": 0x35,
+    "(": 0x26 | SHIFT,
+    ")": 0x27 | SHIFT,
+    "*": 0x25 | SHIFT,
+    "+": 0x2E | SHIFT,
+    ",": 0x36,
+    "-": 0x2D,
+    ".": 0x37,
+    "/": 0x38,
+    ":": 0x33 | SHIFT,
+    ";": 0x33,
+    "<": 0x36 | SHIFT,
+    "=": 0x2E,
+    ">": 0x37 | SHIFT,
+    "?": 0x38 | SHIFT,
+    '"': 0x1F | SHIFT,
+    "[": 0x2F,
+    "#": 0x32,
+    "]": 0x30,
+    "^": 0xA3,
+    "_": 0xAD,
+    "{": 0x2F | SHIFT,
+    "}": 0x30 | SHIFT,
+    "~": 0x32 | SHIFT,
+    "": 0x35 | SHIFT,
+    " ": 0x2C,
+}
```

### Comparing `yubikey_manager-5.1.0/ykman/scancodes/modhex.py` & `yubikey_manager-5.1.1/ykman/scancodes/modhex.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,68 +1,68 @@
-#  vim: set fileencoding=utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-"""Scancode map for keyboard layout based on Modhex. Note that this
-    layouts allows both upper and lowercase characters."""
-
-SHIFT = 0x80
-
-scancodes = {
-    "b": 0x05,
-    "c": 0x06,
-    "d": 0x07,
-    "e": 0x08,
-    "f": 0x09,
-    "g": 0x0A,
-    "h": 0x0B,
-    "i": 0x0C,
-    "j": 0x0D,
-    "k": 0x0E,
-    "l": 0x0F,
-    "n": 0x11,
-    "r": 0x15,
-    "t": 0x17,
-    "u": 0x18,
-    "v": 0x19,
-    "B": 0x05 | SHIFT,
-    "C": 0x06 | SHIFT,
-    "D": 0x07 | SHIFT,
-    "E": 0x08 | SHIFT,
-    "F": 0x09 | SHIFT,
-    "G": 0x0A | SHIFT,
-    "H": 0x0B | SHIFT,
-    "I": 0x0C | SHIFT,
-    "J": 0x0D | SHIFT,
-    "K": 0x0E | SHIFT,
-    "L": 0x0F | SHIFT,
-    "N": 0x11 | SHIFT,
-    "R": 0x15 | SHIFT,
-    "T": 0x17 | SHIFT,
-    "U": 0x18 | SHIFT,
-    "V": 0x19 | SHIFT,
-}
+#  vim: set fileencoding=utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+"""Scancode map for keyboard layout based on Modhex. Note that this
+    layouts allows both upper and lowercase characters."""
+
+SHIFT = 0x80
+
+scancodes = {
+    "b": 0x05,
+    "c": 0x06,
+    "d": 0x07,
+    "e": 0x08,
+    "f": 0x09,
+    "g": 0x0A,
+    "h": 0x0B,
+    "i": 0x0C,
+    "j": 0x0D,
+    "k": 0x0E,
+    "l": 0x0F,
+    "n": 0x11,
+    "r": 0x15,
+    "t": 0x17,
+    "u": 0x18,
+    "v": 0x19,
+    "B": 0x05 | SHIFT,
+    "C": 0x06 | SHIFT,
+    "D": 0x07 | SHIFT,
+    "E": 0x08 | SHIFT,
+    "F": 0x09 | SHIFT,
+    "G": 0x0A | SHIFT,
+    "H": 0x0B | SHIFT,
+    "I": 0x0C | SHIFT,
+    "J": 0x0D | SHIFT,
+    "K": 0x0E | SHIFT,
+    "L": 0x0F | SHIFT,
+    "N": 0x11 | SHIFT,
+    "R": 0x15 | SHIFT,
+    "T": 0x17 | SHIFT,
+    "U": 0x18 | SHIFT,
+    "V": 0x19 | SHIFT,
+}
```

### Comparing `yubikey_manager-5.1.0/ykman/scancodes/norman.py` & `yubikey_manager-5.1.1/ykman/scancodes/us.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,132 +1,132 @@
-#  vim: set fileencoding=utf-8 :
-
-# Copyright (c) 2018 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-"""Scancode map for US English Norman keyboard layout"""
-
-SHIFT = 0x80
-
-scancodes = {
-    "a": 0x04,
-    "b": 0x05,
-    "c": 0x06,
-    "d": 0x08,
-    "e": 0x07,
-    "f": 0x15,
-    "g": 0x0A,
-    "h": 0x33,
-    "i": 0x0E,
-    "j": 0x1C,
-    "k": 0x17,
-    "l": 0x12,
-    "m": 0x10,
-    "n": 0x0D,
-    "o": 0x0F,
-    "p": 0x11,
-    "q": 0x14,
-    "r": 0x0C,
-    "s": 0x16,
-    "t": 0x09,
-    "u": 0x18,
-    "v": 0x19,
-    "w": 0x1A,
-    "x": 0x1B,
-    "y": 0x0B,
-    "z": 0x1D,
-    "A": 0x04 | SHIFT,
-    "B": 0x05 | SHIFT,
-    "C": 0x06 | SHIFT,
-    "D": 0x08 | SHIFT,
-    "E": 0x07 | SHIFT,
-    "F": 0x15 | SHIFT,
-    "G": 0x0A | SHIFT,
-    "H": 0x33 | SHIFT,
-    "I": 0x0E | SHIFT,
-    "J": 0x1C | SHIFT,
-    "K": 0x17 | SHIFT,
-    "L": 0x12 | SHIFT,
-    "M": 0x10 | SHIFT,
-    "N": 0x0D | SHIFT,
-    "O": 0x0F | SHIFT,
-    "P": 0x11 | SHIFT,
-    "Q": 0x14 | SHIFT,
-    "R": 0x0C | SHIFT,
-    "S": 0x16 | SHIFT,
-    "T": 0x09 | SHIFT,
-    "U": 0x18 | SHIFT,
-    "V": 0x19 | SHIFT,
-    "W": 0x1A | SHIFT,
-    "X": 0x1B | SHIFT,
-    "Y": 0x0B | SHIFT,
-    "Z": 0x1D | SHIFT,
-    "0": 0x27,
-    "1": 0x1E,
-    "2": 0x1F,
-    "3": 0x20,
-    "4": 0x21,
-    "5": 0x22,
-    "6": 0x23,
-    "7": 0x24,
-    "8": 0x25,
-    "9": 0x26,
-    "\t": 0x2B,
-    "\n": 0x28,
-    "!": 0x1E | SHIFT,
-    '"': 0x34 | SHIFT,
-    "#": 0x20 | SHIFT,
-    "$": 0x21 | SHIFT,
-    "%": 0x22 | SHIFT,
-    "&": 0x24 | SHIFT,
-    "'": 0x34,
-    "`": 0x35,
-    "(": 0x26 | SHIFT,
-    ")": 0x27 | SHIFT,
-    "*": 0x25 | SHIFT,
-    "+": 0x2E | SHIFT,
-    ",": 0x36,
-    "-": 0x2D,
-    ".": 0x37,
-    "/": 0x38,
-    ":": 0x33 | SHIFT,
-    ";": 0x13,
-    "<": 0x36 | SHIFT,
-    "=": 0x2E,
-    ">": 0x37 | SHIFT,
-    "?": 0x38 | SHIFT,
-    "@": 0x1F | SHIFT,
-    "[": 0x2F,
-    "\\": 0x32,
-    "]": 0x30,
-    "^": 0xA3,
-    "_": 0xAD,
-    "{": 0x2F | SHIFT,
-    "}": 0x30 | SHIFT,
-    "|": 0x32 | SHIFT,
-    "~": 0x35 | SHIFT,
-    " ": 0x2C,
-}
+#  vim: set fileencoding=utf-8 :
+
+# Copyright (c) 2018 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+"""Scancode map for US English keyboard layout"""
+
+SHIFT = 0x80
+
+scancodes = {
+    "a": 0x04,
+    "b": 0x05,
+    "c": 0x06,
+    "d": 0x07,
+    "e": 0x08,
+    "f": 0x09,
+    "g": 0x0A,
+    "h": 0x0B,
+    "i": 0x0C,
+    "j": 0x0D,
+    "k": 0x0E,
+    "l": 0x0F,
+    "m": 0x10,
+    "n": 0x11,
+    "o": 0x12,
+    "p": 0x13,
+    "q": 0x14,
+    "r": 0x15,
+    "s": 0x16,
+    "t": 0x17,
+    "u": 0x18,
+    "v": 0x19,
+    "w": 0x1A,
+    "x": 0x1B,
+    "y": 0x1C,
+    "z": 0x1D,
+    "A": 0x04 | SHIFT,
+    "B": 0x05 | SHIFT,
+    "C": 0x06 | SHIFT,
+    "D": 0x07 | SHIFT,
+    "E": 0x08 | SHIFT,
+    "F": 0x09 | SHIFT,
+    "G": 0x0A | SHIFT,
+    "H": 0x0B | SHIFT,
+    "I": 0x0C | SHIFT,
+    "J": 0x0D | SHIFT,
+    "K": 0x0E | SHIFT,
+    "L": 0x0F | SHIFT,
+    "M": 0x10 | SHIFT,
+    "N": 0x11 | SHIFT,
+    "O": 0x12 | SHIFT,
+    "P": 0x13 | SHIFT,
+    "Q": 0x14 | SHIFT,
+    "R": 0x15 | SHIFT,
+    "S": 0x16 | SHIFT,
+    "T": 0x17 | SHIFT,
+    "U": 0x18 | SHIFT,
+    "V": 0x19 | SHIFT,
+    "W": 0x1A | SHIFT,
+    "X": 0x1B | SHIFT,
+    "Y": 0x1C | SHIFT,
+    "Z": 0x1D | SHIFT,
+    "0": 0x27,
+    "1": 0x1E,
+    "2": 0x1F,
+    "3": 0x20,
+    "4": 0x21,
+    "5": 0x22,
+    "6": 0x23,
+    "7": 0x24,
+    "8": 0x25,
+    "9": 0x26,
+    "\t": 0x2B,
+    "\n": 0x28,
+    "!": 0x1E | SHIFT,
+    '"': 0x34 | SHIFT,
+    "#": 0x20 | SHIFT,
+    "$": 0x21 | SHIFT,
+    "%": 0x22 | SHIFT,
+    "&": 0x24 | SHIFT,
+    "'": 0x34,
+    "`": 0x35,
+    "(": 0x26 | SHIFT,
+    ")": 0x27 | SHIFT,
+    "*": 0x25 | SHIFT,
+    "+": 0x2E | SHIFT,
+    ",": 0x36,
+    "-": 0x2D,
+    ".": 0x37,
+    "/": 0x38,
+    ":": 0x33 | SHIFT,
+    ";": 0x33,
+    "<": 0x36 | SHIFT,
+    "=": 0x2E,
+    ">": 0x37 | SHIFT,
+    "?": 0x38 | SHIFT,
+    "@": 0x1F | SHIFT,
+    "[": 0x2F,
+    "\\": 0x32,
+    "]": 0x30,
+    "^": 0xA3,
+    "_": 0xAD,
+    "{": 0x2F | SHIFT,
+    "}": 0x30 | SHIFT,
+    "|": 0x32 | SHIFT,
+    "~": 0x35 | SHIFT,
+    " ": 0x2C,
+}
```

### Comparing `yubikey_manager-5.1.0/ykman/scripting.py` & `yubikey_manager-5.1.1/ykman/scripting.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,218 +1,218 @@
-# Copyright (c) 2021 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-
-from .base import YkmanDevice
-from .device import list_all_devices, scan_devices
-from .pcsc import list_devices as list_ccid
-
-from yubikit.core import TRANSPORT
-from yubikit.core.otp import OtpConnection
-from yubikit.core.smartcard import SmartCardConnection
-from yubikit.core.fido import FidoConnection
-from yubikit.management import DeviceInfo
-from yubikit.support import get_name, read_info
-from smartcard.Exceptions import NoCardException, CardConnectionException
-
-from time import sleep
-from typing import Generator, Optional, Set
-
-
-"""
-Various helpers intended to simplify scripting.
-
-Add an import to your script:
-
-  from ykman import scripting as s
-
-Example usage:
-
-  yubikey = s.single()
-  print("Here is a YubiKey:", yubikey)
-
-
-  print("Insert multiple YubiKeys")
-  for yubikey in s.multi():
-      print("You inserted {yubikey}")
-  print("You pressed Ctrl+C, end of script")
-
-"""
-
-
-class ScriptingDevice:
-    """Scripting-friendly proxy for YkmanDevice.
-
-    This wrapper adds some helpful utility methods useful for scripting.
-    """
-
-    def __init__(self, wrapped, info):
-        self._wrapped = wrapped
-        self._info = info
-
-    def __getattr__(self, attr):
-        return getattr(self._wrapped, attr)
-
-    def __str__(self):
-        name = get_name(self._info, self.pid.yubikey_type if self.pid else None)
-        serial = self._info.serial
-        return f"{name} ({serial})" if serial else name
-
-    @property
-    def info(self) -> DeviceInfo:
-        return self._info
-
-    def otp(self) -> OtpConnection:
-        return self.open_connection(OtpConnection)
-
-    def smart_card(self) -> SmartCardConnection:
-        return self.open_connection(SmartCardConnection)
-
-    def fido(self) -> FidoConnection:
-        return self.open_connection(FidoConnection)
-
-
-YkmanDevice.register(ScriptingDevice)
-
-
-def single(*, prompt=True) -> ScriptingDevice:
-    pids, state = scan_devices()
-    n_devs = sum(pids.values())
-    if prompt and n_devs == 0:
-        print("Insert YubiKey...")
-    while n_devs == 0:
-        sleep(1.0)
-        pids, new_state = scan_devices()
-        n_devs = sum(pids.values())
-    devs = list_all_devices()
-    if len(devs) == 1:
-        return ScriptingDevice(*devs[0])
-    raise ValueError("Failed to get single YubiKey")
-
-
-def multi(
-    *, ignore_duplicates: bool = True, allow_initial: bool = False, prompt: bool = True
-) -> Generator[ScriptingDevice, None, None]:
-    state = None
-    handled_serials: Set[Optional[int]] = set()
-    pids, _ = scan_devices()
-    n_devs = sum(pids.values())
-    if n_devs == 0:
-        if prompt:
-            print("Insert YubiKeys, one at a time...")
-    elif not allow_initial:
-        raise ValueError("YubiKeys must not be present initially.")
-
-    while True:  # Run this until we stop the script with Ctrl+C
-        pids, new_state = scan_devices()
-        if new_state != state:
-            state = new_state  # State has changed
-            serials = set()
-            if len(pids) == 0 and None in handled_serials:
-                handled_serials.remove(None)  # Allow one key without serial at a time
-            for device, info in list_all_devices():
-                serials.add(info.serial)
-                if info.serial not in handled_serials:
-                    handled_serials.add(info.serial)
-                    yield ScriptingDevice(device, info)
-            if not ignore_duplicates:  # Reset handled serials to currently connected
-                handled_serials = serials
-        else:
-            try:
-                sleep(1.0)  # No change, sleep for 1 second.
-            except KeyboardInterrupt:
-                return  # Stop waiting
-
-
-def _get_reader(reader) -> YkmanDevice:
-    readers = [d for d in list_ccid(reader) if d.transport == TRANSPORT.NFC]
-    if not readers:
-        raise ValueError(f"No NFC reader found matching filter: '{reader}'")
-    elif len(readers) > 1:
-        names = [r.fingerprint for r in readers]
-        raise ValueError(f"Multiple NFC readers matching filter: '{reader}' {names}")
-    return readers[0]
-
-
-def single_nfc(reader="", *, prompt=True) -> ScriptingDevice:
-    device = _get_reader(reader)
-    while True:
-        try:
-            with device.open_connection(SmartCardConnection) as connection:
-                info = read_info(connection)
-            return ScriptingDevice(device, info)
-        except NoCardException:
-            if prompt:
-                print("Place YubiKey on NFC reader...")
-                prompt = False
-            sleep(1.0)
-
-
-def multi_nfc(
-    reader="", *, ignore_duplicates=True, allow_initial=False, prompt=True
-) -> Generator[ScriptingDevice, None, None]:
-    device = _get_reader(reader)
-    prompted = False
-
-    try:
-        with device.open_connection(SmartCardConnection) as connection:
-            if not allow_initial:
-                raise ValueError("YubiKey must not be present initially.")
-    except NoCardException:
-        if prompt:
-            print("Place YubiKey on NFC reader...")
-            prompted = True
-        sleep(1.0)
-
-    handled_serials: Set[Optional[int]] = set()
-    current: Optional[int] = -1
-    while True:  # Run this until we stop the script with Ctrl+C
-        try:
-            with device.open_connection(SmartCardConnection) as connection:
-                info = read_info(connection)
-            if info.serial in handled_serials or current == info.serial:
-                if prompt and not prompted:
-                    print("Remove YubiKey from NFC reader.")
-                    prompted = True
-            else:
-                current = info.serial
-                if ignore_duplicates:
-                    handled_serials.add(current)
-                yield ScriptingDevice(device, info)
-                prompted = False
-        except NoCardException:
-            if None in handled_serials:
-                handled_serials.remove(None)  # Allow one key without serial at a time
-            current = -1
-            if prompt and not prompted:
-                print("Place YubiKey on NFC reader...")
-                prompted = True
-        except CardConnectionException:
-            pass
-        try:
-            sleep(1.0)  # No change, sleep for 1 second.
-        except KeyboardInterrupt:
-            return  # Stop waiting
+# Copyright (c) 2021 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+
+from .base import YkmanDevice
+from .device import list_all_devices, scan_devices
+from .pcsc import list_devices as list_ccid
+
+from yubikit.core import TRANSPORT
+from yubikit.core.otp import OtpConnection
+from yubikit.core.smartcard import SmartCardConnection
+from yubikit.core.fido import FidoConnection
+from yubikit.management import DeviceInfo
+from yubikit.support import get_name, read_info
+from smartcard.Exceptions import NoCardException, CardConnectionException
+
+from time import sleep
+from typing import Generator, Optional, Set
+
+
+"""
+Various helpers intended to simplify scripting.
+
+Add an import to your script:
+
+  from ykman import scripting as s
+
+Example usage:
+
+  yubikey = s.single()
+  print("Here is a YubiKey:", yubikey)
+
+
+  print("Insert multiple YubiKeys")
+  for yubikey in s.multi():
+      print("You inserted {yubikey}")
+  print("You pressed Ctrl+C, end of script")
+
+"""
+
+
+class ScriptingDevice:
+    """Scripting-friendly proxy for YkmanDevice.
+
+    This wrapper adds some helpful utility methods useful for scripting.
+    """
+
+    def __init__(self, wrapped, info):
+        self._wrapped = wrapped
+        self._info = info
+
+    def __getattr__(self, attr):
+        return getattr(self._wrapped, attr)
+
+    def __str__(self):
+        name = get_name(self._info, self.pid.yubikey_type if self.pid else None)
+        serial = self._info.serial
+        return f"{name} ({serial})" if serial else name
+
+    @property
+    def info(self) -> DeviceInfo:
+        return self._info
+
+    def otp(self) -> OtpConnection:
+        return self.open_connection(OtpConnection)
+
+    def smart_card(self) -> SmartCardConnection:
+        return self.open_connection(SmartCardConnection)
+
+    def fido(self) -> FidoConnection:
+        return self.open_connection(FidoConnection)
+
+
+YkmanDevice.register(ScriptingDevice)
+
+
+def single(*, prompt=True) -> ScriptingDevice:
+    pids, state = scan_devices()
+    n_devs = sum(pids.values())
+    if prompt and n_devs == 0:
+        print("Insert YubiKey...")
+    while n_devs == 0:
+        sleep(1.0)
+        pids, new_state = scan_devices()
+        n_devs = sum(pids.values())
+    devs = list_all_devices()
+    if len(devs) == 1:
+        return ScriptingDevice(*devs[0])
+    raise ValueError("Failed to get single YubiKey")
+
+
+def multi(
+    *, ignore_duplicates: bool = True, allow_initial: bool = False, prompt: bool = True
+) -> Generator[ScriptingDevice, None, None]:
+    state = None
+    handled_serials: Set[Optional[int]] = set()
+    pids, _ = scan_devices()
+    n_devs = sum(pids.values())
+    if n_devs == 0:
+        if prompt:
+            print("Insert YubiKeys, one at a time...")
+    elif not allow_initial:
+        raise ValueError("YubiKeys must not be present initially.")
+
+    while True:  # Run this until we stop the script with Ctrl+C
+        pids, new_state = scan_devices()
+        if new_state != state:
+            state = new_state  # State has changed
+            serials = set()
+            if len(pids) == 0 and None in handled_serials:
+                handled_serials.remove(None)  # Allow one key without serial at a time
+            for device, info in list_all_devices():
+                serials.add(info.serial)
+                if info.serial not in handled_serials:
+                    handled_serials.add(info.serial)
+                    yield ScriptingDevice(device, info)
+            if not ignore_duplicates:  # Reset handled serials to currently connected
+                handled_serials = serials
+        else:
+            try:
+                sleep(1.0)  # No change, sleep for 1 second.
+            except KeyboardInterrupt:
+                return  # Stop waiting
+
+
+def _get_reader(reader) -> YkmanDevice:
+    readers = [d for d in list_ccid(reader) if d.transport == TRANSPORT.NFC]
+    if not readers:
+        raise ValueError(f"No NFC reader found matching filter: '{reader}'")
+    elif len(readers) > 1:
+        names = [r.fingerprint for r in readers]
+        raise ValueError(f"Multiple NFC readers matching filter: '{reader}' {names}")
+    return readers[0]
+
+
+def single_nfc(reader="", *, prompt=True) -> ScriptingDevice:
+    device = _get_reader(reader)
+    while True:
+        try:
+            with device.open_connection(SmartCardConnection) as connection:
+                info = read_info(connection)
+            return ScriptingDevice(device, info)
+        except NoCardException:
+            if prompt:
+                print("Place YubiKey on NFC reader...")
+                prompt = False
+            sleep(1.0)
+
+
+def multi_nfc(
+    reader="", *, ignore_duplicates=True, allow_initial=False, prompt=True
+) -> Generator[ScriptingDevice, None, None]:
+    device = _get_reader(reader)
+    prompted = False
+
+    try:
+        with device.open_connection(SmartCardConnection) as connection:
+            if not allow_initial:
+                raise ValueError("YubiKey must not be present initially.")
+    except NoCardException:
+        if prompt:
+            print("Place YubiKey on NFC reader...")
+            prompted = True
+        sleep(1.0)
+
+    handled_serials: Set[Optional[int]] = set()
+    current: Optional[int] = -1
+    while True:  # Run this until we stop the script with Ctrl+C
+        try:
+            with device.open_connection(SmartCardConnection) as connection:
+                info = read_info(connection)
+            if info.serial in handled_serials or current == info.serial:
+                if prompt and not prompted:
+                    print("Remove YubiKey from NFC reader.")
+                    prompted = True
+            else:
+                current = info.serial
+                if ignore_duplicates:
+                    handled_serials.add(current)
+                yield ScriptingDevice(device, info)
+                prompted = False
+        except NoCardException:
+            if None in handled_serials:
+                handled_serials.remove(None)  # Allow one key without serial at a time
+            current = -1
+            if prompt and not prompted:
+                print("Place YubiKey on NFC reader...")
+                prompted = True
+        except CardConnectionException:
+            pass
+        try:
+            sleep(1.0)  # No change, sleep for 1 second.
+        except KeyboardInterrupt:
+            return  # Stop waiting
```

### Comparing `yubikey_manager-5.1.0/ykman/settings.py` & `yubikey_manager-5.1.1/ykman/settings.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,114 +1,114 @@
-# Copyright (c) 2017 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-import os
-import json
-import keyring
-from pathlib import Path
-from cryptography.fernet import Fernet, InvalidToken
-
-
-XDG_DATA_HOME = os.environ.get("XDG_DATA_HOME", "~/.local/share") + "/ykman"
-XDG_CONFIG_HOME = os.environ.get("XDG_CONFIG_HOME", "~/.config") + "/ykman"
-
-KEYRING_SERVICE = os.environ.get("YKMAN_KEYRING_SERVICE", "ykman")
-KEYRING_KEY = os.environ.get("YKMAN_KEYRING_KEY", "wrap_key")
-
-
-class Settings(dict):
-    _config_dir = XDG_CONFIG_HOME
-
-    def __init__(self, name):
-        self.fname = Path(self._config_dir).expanduser().resolve() / (name + ".json")
-        if self.fname.is_file():
-            with self.fname.open("r") as fd:
-                self.update(json.load(fd))
-
-    def __eq__(self, other):
-        return other is not None and self.fname == other.fname
-
-    def __ne__(self, other):
-        return other is None or self.fname != other.fname
-
-    def write(self):
-        conf_dir = self.fname.parent
-        if not conf_dir.is_dir():
-            conf_dir.mkdir(0o700, parents=True)
-        with self.fname.open("w") as fd:
-            json.dump(self, fd, indent=2)
-
-    __hash__ = None
-
-
-class Configuration(Settings):
-    _config_dir = XDG_CONFIG_HOME
-
-
-class KeystoreError(Exception):
-    """Error accessing the OS keystore"""
-
-
-class UnwrapValueError(Exception):
-    """Error unwrapping a particular secret value"""
-
-
-class AppData(Settings):
-    _config_dir = XDG_DATA_HOME
-
-    def __init__(self, name, keyring_service=KEYRING_SERVICE, keyring_key=KEYRING_KEY):
-        super().__init__(name)
-        self._service = keyring_service
-        self._username = keyring_key
-
-    @property
-    def keyring_unlocked(self) -> bool:
-        return hasattr(self, "_fernet")
-
-    def ensure_unlocked(self):
-        if not self.keyring_unlocked:
-            try:
-                wrap_key = keyring.get_password(self._service, self._username)
-            except keyring.errors.KeyringError:
-                raise KeystoreError("Keyring locked or unavailable")
-
-            if wrap_key is None:
-                key = Fernet.generate_key()
-                keyring.set_password(self._service, self._username, key.decode())
-                self._fernet = Fernet(key)
-            else:
-                self._fernet = Fernet(wrap_key)
-
-    def get_secret(self, key: str):
-        self.ensure_unlocked()
-        try:
-            return json.loads(self._fernet.decrypt(self[key].encode()))
-        except InvalidToken:
-            raise UnwrapValueError("Undecryptable value")
-
-    def put_secret(self, key: str, value) -> None:
-        self.ensure_unlocked()
-        self[key] = self._fernet.encrypt(json.dumps(value).encode()).decode()
+# Copyright (c) 2017 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+import os
+import json
+import keyring
+from pathlib import Path
+from cryptography.fernet import Fernet, InvalidToken
+
+
+XDG_DATA_HOME = os.environ.get("XDG_DATA_HOME", "~/.local/share") + "/ykman"
+XDG_CONFIG_HOME = os.environ.get("XDG_CONFIG_HOME", "~/.config") + "/ykman"
+
+KEYRING_SERVICE = os.environ.get("YKMAN_KEYRING_SERVICE", "ykman")
+KEYRING_KEY = os.environ.get("YKMAN_KEYRING_KEY", "wrap_key")
+
+
+class Settings(dict):
+    _config_dir = XDG_CONFIG_HOME
+
+    def __init__(self, name):
+        self.fname = Path(self._config_dir).expanduser().resolve() / (name + ".json")
+        if self.fname.is_file():
+            with self.fname.open("r") as fd:
+                self.update(json.load(fd))
+
+    def __eq__(self, other):
+        return other is not None and self.fname == other.fname
+
+    def __ne__(self, other):
+        return other is None or self.fname != other.fname
+
+    def write(self):
+        conf_dir = self.fname.parent
+        if not conf_dir.is_dir():
+            conf_dir.mkdir(0o700, parents=True)
+        with self.fname.open("w") as fd:
+            json.dump(self, fd, indent=2)
+
+    __hash__ = None
+
+
+class Configuration(Settings):
+    _config_dir = XDG_CONFIG_HOME
+
+
+class KeystoreError(Exception):
+    """Error accessing the OS keystore"""
+
+
+class UnwrapValueError(Exception):
+    """Error unwrapping a particular secret value"""
+
+
+class AppData(Settings):
+    _config_dir = XDG_DATA_HOME
+
+    def __init__(self, name, keyring_service=KEYRING_SERVICE, keyring_key=KEYRING_KEY):
+        super().__init__(name)
+        self._service = keyring_service
+        self._username = keyring_key
+
+    @property
+    def keyring_unlocked(self) -> bool:
+        return hasattr(self, "_fernet")
+
+    def ensure_unlocked(self):
+        if not self.keyring_unlocked:
+            try:
+                wrap_key = keyring.get_password(self._service, self._username)
+            except keyring.errors.KeyringError:
+                raise KeystoreError("Keyring locked or unavailable")
+
+            if wrap_key is None:
+                key = Fernet.generate_key()
+                keyring.set_password(self._service, self._username, key.decode())
+                self._fernet = Fernet(key)
+            else:
+                self._fernet = Fernet(wrap_key)
+
+    def get_secret(self, key: str):
+        self.ensure_unlocked()
+        try:
+            return json.loads(self._fernet.decrypt(self[key].encode()))
+        except InvalidToken:
+            raise UnwrapValueError("Undecryptable value")
+
+    def put_secret(self, key: str, value) -> None:
+        self.ensure_unlocked()
+        self[key] = self._fernet.encrypt(json.dumps(value).encode()).decode()
```

### Comparing `yubikey_manager-5.1.0/ykman/util.py` & `yubikey_manager-5.1.1/ykman/util.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,185 +1,185 @@
-# Copyright (c) 2015 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from yubikit.core import Tlv
-from cryptography.hazmat.primitives.serialization import pkcs12
-from cryptography.hazmat.primitives import serialization
-from cryptography.hazmat.backends import default_backend
-from cryptography import x509
-from typing import Tuple
-import ctypes
-
-import logging
-
-
-logger = logging.getLogger(__name__)
-
-
-PEM_IDENTIFIER = b"-----BEGIN"
-
-
-class InvalidPasswordError(Exception):
-    """Raised when parsing key/certificate and the password might be wrong/missing."""
-
-
-def _parse_pkcs12(data, password):
-    try:
-        key, cert, cas = pkcs12.load_key_and_certificates(
-            data, password, default_backend()
-        )
-        if cert:
-            cas.insert(0, cert)
-        return key, cas
-    except ValueError as e:  # cryptography raises ValueError on wrong password
-        raise InvalidPasswordError(e)
-
-
-def parse_private_key(data, password):
-    """
-    Identifies, decrypts and returns a cryptography private key object.
-    """
-    # PEM
-    if is_pem(data):
-        if b"ENCRYPTED" in data:
-            if password is None:
-                raise InvalidPasswordError("No password provided for encrypted key.")
-        try:
-            return serialization.load_pem_private_key(
-                data, password, backend=default_backend()
-            )
-        except ValueError as e:
-            # Cryptography raises ValueError if decryption fails.
-            raise InvalidPasswordError(e)
-        except Exception:
-            logger.debug("Failed to parse PEM private key ", exc_info=True)
-
-    # PKCS12
-    if is_pkcs12(data):
-        return _parse_pkcs12(data, password)[0]
-
-    # DER
-    try:
-        return serialization.load_der_private_key(
-            data, password, backend=default_backend()
-        )
-    except Exception:
-        logger.debug("Failed to parse private key as DER", exc_info=True)
-
-    # All parsing failed
-    raise ValueError("Could not parse private key.")
-
-
-def parse_certificates(data, password):
-    """
-    Identifies, decrypts and returns list of cryptography x509 certificates.
-    """
-
-    # PEM
-    if is_pem(data):
-        certs = []
-        for cert in data.split(PEM_IDENTIFIER):
-            if cert:
-                try:
-                    certs.append(
-                        x509.load_pem_x509_certificate(
-                            PEM_IDENTIFIER + cert, default_backend()
-                        )
-                    )
-                except Exception:
-                    logger.debug("Failed to parse PEM certificate", exc_info=True)
-        # Could be valid PEM but not certificates.
-        if not certs:
-            raise ValueError("PEM file does not contain any certificate(s)")
-        return certs
-
-    # PKCS12
-    if is_pkcs12(data):
-        return _parse_pkcs12(data, password)[1]
-
-    # DER
-    try:
-        return [x509.load_der_x509_certificate(data, default_backend())]
-    except Exception:
-        logger.debug("Failed to parse certificate as DER", exc_info=True)
-
-    raise ValueError("Could not parse certificate.")
-
-
-def get_leaf_certificates(certs):
-    """
-    Extracts the leaf certificates from a list of certificates. Leaf
-    certificates are ones whose subject does not appear as issuer among the
-    others.
-    """
-    issuers = [
-        cert.issuer.get_attributes_for_oid(x509.NameOID.COMMON_NAME) for cert in certs
-    ]
-    leafs = [
-        cert
-        for cert in certs
-        if (
-            cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME) not in issuers
-        )
-    ]
-    return leafs
-
-
-def is_pem(data):
-    return data and PEM_IDENTIFIER in data
-
-
-def is_pkcs12(data):
-    """
-    Tries to identify a PKCS12 container.
-    The PFX PDU version is assumed to be v3.
-    See: https://tools.ietf.org/html/rfc7292.
-    """
-    try:
-        header = Tlv.parse_from(Tlv.unpack(0x30, data))[0]
-        return header.tag == 0x02 and header.value == b"\x03"
-    except ValueError:
-        logger.debug("Unable to parse TLV", exc_info=True)
-    return False
-
-
-class OSVERSIONINFOW(ctypes.Structure):
-    _fields_ = [
-        ("dwOSVersionInfoSize", ctypes.c_ulong),
-        ("dwMajorVersion", ctypes.c_ulong),
-        ("dwMinorVersion", ctypes.c_ulong),
-        ("dwBuildNumber", ctypes.c_ulong),
-        ("dwPlatformId", ctypes.c_ulong),
-        ("szCSDVersion", ctypes.c_wchar * 128),
-    ]
-
-
-def get_windows_version() -> Tuple[int, int, int]:
-    """Get the true Windows version, since sys.getwindowsversion lies."""
-    osvi = OSVERSIONINFOW()
-    osvi.dwOSVersionInfoSize = ctypes.sizeof(osvi)
-    ctypes.windll.Ntdll.RtlGetVersion(ctypes.byref(osvi))  # type: ignore
-    return osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber
+# Copyright (c) 2015 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from yubikit.core import Tlv
+from cryptography.hazmat.primitives.serialization import pkcs12
+from cryptography.hazmat.primitives import serialization
+from cryptography.hazmat.backends import default_backend
+from cryptography import x509
+from typing import Tuple
+import ctypes
+
+import logging
+
+
+logger = logging.getLogger(__name__)
+
+
+PEM_IDENTIFIER = b"-----BEGIN"
+
+
+class InvalidPasswordError(Exception):
+    """Raised when parsing key/certificate and the password might be wrong/missing."""
+
+
+def _parse_pkcs12(data, password):
+    try:
+        key, cert, cas = pkcs12.load_key_and_certificates(
+            data, password, default_backend()
+        )
+        if cert:
+            cas.insert(0, cert)
+        return key, cas
+    except ValueError as e:  # cryptography raises ValueError on wrong password
+        raise InvalidPasswordError(e)
+
+
+def parse_private_key(data, password):
+    """
+    Identifies, decrypts and returns a cryptography private key object.
+    """
+    # PEM
+    if is_pem(data):
+        if b"ENCRYPTED" in data:
+            if password is None:
+                raise InvalidPasswordError("No password provided for encrypted key.")
+        try:
+            return serialization.load_pem_private_key(
+                data, password, backend=default_backend()
+            )
+        except ValueError as e:
+            # Cryptography raises ValueError if decryption fails.
+            raise InvalidPasswordError(e)
+        except Exception:
+            logger.debug("Failed to parse PEM private key ", exc_info=True)
+
+    # PKCS12
+    if is_pkcs12(data):
+        return _parse_pkcs12(data, password)[0]
+
+    # DER
+    try:
+        return serialization.load_der_private_key(
+            data, password, backend=default_backend()
+        )
+    except Exception:
+        logger.debug("Failed to parse private key as DER", exc_info=True)
+
+    # All parsing failed
+    raise ValueError("Could not parse private key.")
+
+
+def parse_certificates(data, password):
+    """
+    Identifies, decrypts and returns list of cryptography x509 certificates.
+    """
+
+    # PEM
+    if is_pem(data):
+        certs = []
+        for cert in data.split(PEM_IDENTIFIER):
+            if cert:
+                try:
+                    certs.append(
+                        x509.load_pem_x509_certificate(
+                            PEM_IDENTIFIER + cert, default_backend()
+                        )
+                    )
+                except Exception:
+                    logger.debug("Failed to parse PEM certificate", exc_info=True)
+        # Could be valid PEM but not certificates.
+        if not certs:
+            raise ValueError("PEM file does not contain any certificate(s)")
+        return certs
+
+    # PKCS12
+    if is_pkcs12(data):
+        return _parse_pkcs12(data, password)[1]
+
+    # DER
+    try:
+        return [x509.load_der_x509_certificate(data, default_backend())]
+    except Exception:
+        logger.debug("Failed to parse certificate as DER", exc_info=True)
+
+    raise ValueError("Could not parse certificate.")
+
+
+def get_leaf_certificates(certs):
+    """
+    Extracts the leaf certificates from a list of certificates. Leaf
+    certificates are ones whose subject does not appear as issuer among the
+    others.
+    """
+    issuers = [
+        cert.issuer.get_attributes_for_oid(x509.NameOID.COMMON_NAME) for cert in certs
+    ]
+    leafs = [
+        cert
+        for cert in certs
+        if (
+            cert.subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME) not in issuers
+        )
+    ]
+    return leafs
+
+
+def is_pem(data):
+    return data and PEM_IDENTIFIER in data
+
+
+def is_pkcs12(data):
+    """
+    Tries to identify a PKCS12 container.
+    The PFX PDU version is assumed to be v3.
+    See: https://tools.ietf.org/html/rfc7292.
+    """
+    try:
+        header = Tlv.parse_from(Tlv.unpack(0x30, data))[0]
+        return header.tag == 0x02 and header.value == b"\x03"
+    except ValueError:
+        logger.debug("Unable to parse TLV", exc_info=True)
+    return False
+
+
+class OSVERSIONINFOW(ctypes.Structure):
+    _fields_ = [
+        ("dwOSVersionInfoSize", ctypes.c_ulong),
+        ("dwMajorVersion", ctypes.c_ulong),
+        ("dwMinorVersion", ctypes.c_ulong),
+        ("dwBuildNumber", ctypes.c_ulong),
+        ("dwPlatformId", ctypes.c_ulong),
+        ("szCSDVersion", ctypes.c_wchar * 128),
+    ]
+
+
+def get_windows_version() -> Tuple[int, int, int]:
+    """Get the true Windows version, since sys.getwindowsversion lies."""
+    osvi = OSVERSIONINFOW()
+    osvi.dwOSVersionInfoSize = ctypes.sizeof(osvi)
+    ctypes.windll.Ntdll.RtlGetVersion(ctypes.byref(osvi))  # type: ignore
+    return osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber
```

### Comparing `yubikey_manager-5.1.0/yubikit/__init__.py` & `yubikey_manager-5.1.1/yubikit/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,26 +1,26 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
```

### Comparing `yubikey_manager-5.1.0/yubikit/core/__init__.py` & `yubikey_manager-5.1.1/yubikit/core/__init__.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,348 +1,348 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from enum import Enum, IntEnum, IntFlag, unique
-from typing import (
-    Type,
-    List,
-    Dict,
-    Tuple,
-    TypeVar,
-    Union,
-    Optional,
-    Hashable,
-    NamedTuple,
-    Callable,
-    ClassVar,
-)
-import re
-import abc
-
-
-_VERSION_STRING_PATTERN = re.compile(r"\b(?P<major>\d+).(?P<minor>\d).(?P<patch>\d)\b")
-
-
-class Version(NamedTuple):
-    """3-digit version tuple."""
-
-    major: int
-    minor: int
-    patch: int
-
-    def __str__(self):
-        return "%d.%d.%d" % self
-
-    @classmethod
-    def from_bytes(cls, data: bytes) -> "Version":
-        return cls(*data)
-
-    @classmethod
-    def from_string(cls, data: str) -> "Version":
-        m = _VERSION_STRING_PATTERN.search(data)
-        if m:
-            return cls(
-                int(m.group("major")), int(m.group("minor")), int(m.group("patch"))
-            )
-        raise ValueError("No version found in string")
-
-
-@unique
-class TRANSPORT(str, Enum):
-    """YubiKey physical connection transports."""
-
-    USB = "usb"
-    NFC = "nfc"
-
-    def __str__(self):
-        return super().__str__().upper()
-
-
-@unique
-class USB_INTERFACE(IntFlag):
-    """YubiKey USB interface identifiers."""
-
-    OTP = 0x01
-    FIDO = 0x02
-    CCID = 0x04
-
-
-@unique
-class YUBIKEY(Enum):
-    """YubiKey hardware platforms."""
-
-    YKS = "YubiKey Standard"
-    NEO = "YubiKey NEO"
-    SKY = "Security Key by Yubico"
-    YKP = "YubiKey Plus"
-    YK4 = "YubiKey"  # This includes YubiKey 5
-
-
-class Connection(abc.ABC):
-    """A connection to a YubiKey"""
-
-    usb_interface: ClassVar[USB_INTERFACE] = USB_INTERFACE(0)
-
-    def close(self) -> None:
-        """Close the device, releasing any held resources."""
-
-    def __enter__(self):
-        return self
-
-    def __exit__(self, typ, value, traceback):
-        self.close()
-
-
-@unique
-class PID(IntEnum):
-    """USB Product ID values for YubiKey devices."""
-
-    YKS_OTP = 0x0010
-    NEO_OTP = 0x0110
-    NEO_OTP_CCID = 0x0111
-    NEO_CCID = 0x0112
-    NEO_FIDO = 0x0113
-    NEO_OTP_FIDO = 0x0114
-    NEO_FIDO_CCID = 0x0115
-    NEO_OTP_FIDO_CCID = 0x0116
-    SKY_FIDO = 0x0120
-    YK4_OTP = 0x0401
-    YK4_FIDO = 0x0402
-    YK4_OTP_FIDO = 0x0403
-    YK4_CCID = 0x0404
-    YK4_OTP_CCID = 0x0405
-    YK4_FIDO_CCID = 0x0406
-    YK4_OTP_FIDO_CCID = 0x0407
-    YKP_OTP_FIDO = 0x0410
-
-    @property
-    def yubikey_type(self) -> YUBIKEY:
-        return YUBIKEY[self.name.split("_", 1)[0]]
-
-    @property
-    def usb_interfaces(self) -> USB_INTERFACE:
-        return USB_INTERFACE(sum(USB_INTERFACE[x] for x in self.name.split("_")[1:]))
-
-    @classmethod
-    def of(cls, key_type: YUBIKEY, interfaces: USB_INTERFACE) -> "PID":
-        suffix = "_".join(t.name or str(t) for t in USB_INTERFACE if t in interfaces)
-        return cls[key_type.name + "_" + suffix]
-
-    def supports_connection(self, connection_type: Type[Connection]) -> bool:
-        return connection_type.usb_interface in self.usb_interfaces
-
-
-T_Connection = TypeVar("T_Connection", bound=Connection)
-
-
-class YubiKeyDevice(abc.ABC):
-    """YubiKey device reference"""
-
-    def __init__(self, transport: TRANSPORT, fingerprint: Hashable):
-        self._transport = transport
-        self._fingerprint = fingerprint
-
-    @property
-    def transport(self) -> TRANSPORT:
-        """Get the transport used to communicate with this YubiKey"""
-        return self._transport
-
-    def supports_connection(self, connection_type: Type[Connection]) -> bool:
-        """Check if a YubiKeyDevice supports a specific Connection type"""
-        return False
-
-    # mypy will not accept abstract types in Type[T_Connection]
-    def open_connection(
-        self, connection_type: Union[Type[T_Connection], Callable[..., T_Connection]]
-    ) -> T_Connection:
-        """Opens a connection to the YubiKey"""
-        raise ValueError("Unsupported Connection type")
-
-    @property
-    def fingerprint(self) -> Hashable:
-        """Used to identify that device references from different enumerations represent
-        the same physical YubiKey. This fingerprint is not stable between sessions, or
-        after un-plugging, and re-plugging a device."""
-        return self._fingerprint
-
-    def __eq__(self, other):
-        return isinstance(other, type(self)) and self.fingerprint == other.fingerprint
-
-    def __hash__(self):
-        return hash(self.fingerprint)
-
-    def __repr__(self):
-        return f"{type(self).__name__}(fingerprint={self.fingerprint!r})"
-
-
-class CommandError(Exception):
-    """An error response from a YubiKey"""
-
-
-class BadResponseError(CommandError):
-    """Invalid response data from the YubiKey"""
-
-
-class TimeoutError(CommandError):
-    """An operation timed out waiting for something"""
-
-
-class ApplicationNotAvailableError(CommandError):
-    """The application is either disabled or not supported on this YubiKey"""
-
-
-class NotSupportedError(ValueError):
-    """Attempting an action that is not supported on this YubiKey"""
-
-
-def require_version(
-    my_version: Version, min_version: Tuple[int, int, int], message=None
-):
-    """Ensure a version is at least min_version."""
-    # Skip version checks for major == 0, used for development builds.
-    if my_version < min_version and my_version[0] != 0:
-        if not message:
-            message = "This action requires YubiKey %d.%d.%d or later" % min_version
-        raise NotSupportedError(message)
-
-
-def int2bytes(value: int, min_len: int = 0) -> bytes:
-    buf = []
-    while value > 0xFF:
-        buf.append(value & 0xFF)
-        value >>= 8
-    buf.append(value)
-    return bytes(reversed(buf)).rjust(min_len, b"\0")
-
-
-def bytes2int(data: bytes) -> int:
-    return int.from_bytes(data, "big")
-
-
-def _tlv_parse(data, offset=0):
-    try:
-        tag = data[offset]
-        offset += 1
-        if tag & 0x1F == 0x1F:  # Long form
-            tag = tag << 8 | data[offset]
-            offset += 1
-            while tag & 0x80 == 0x80:  # Additional bytes
-                tag = tag << 8 | data[offset]
-                offset += 1
-
-        ln = data[offset]
-        offset += 1
-        if ln == 0x80:  # Indefinite length
-            end = offset
-            while data[end] or data[end + 1]:  # Run until 0x0000
-                end = _tlv_parse(data, end)[3]  # Skip over TLV
-            ln = end - offset
-            end += 2  # End after 0x0000
-        else:
-            if ln > 0x80:  # Length spans multiple bytes
-                n_bytes = ln - 0x80
-                ln = bytes2int(data[offset : offset + n_bytes])
-                offset += n_bytes
-            end = offset + ln
-
-        return tag, offset, ln, end
-    except IndexError:
-        raise ValueError("Invalid encoding of tag/length")
-
-
-T_Tlv = TypeVar("T_Tlv", bound="Tlv")
-
-
-class Tlv(bytes):
-    @property
-    def tag(self) -> int:
-        return self._tag
-
-    @property
-    def length(self) -> int:
-        return self._value_ln
-
-    @property
-    def value(self) -> bytes:
-        return self[self._value_offset : self._value_offset + self._value_ln]
-
-    def __new__(cls, tag_or_data: Union[int, bytes], value: Optional[bytes] = None):
-        """This allows creation by passing either binary data, or tag and value."""
-        if isinstance(tag_or_data, int):  # Tag and (optional) value
-            tag = tag_or_data
-
-            # Pack into Tlv
-            buf = bytearray()
-            buf.extend(int2bytes(tag))
-            value = value or b""
-            length = len(value)
-            if length < 0x80:
-                buf.append(length)
-            else:
-                ln_bytes = int2bytes(length)
-                buf.append(0x80 | len(ln_bytes))
-                buf.extend(ln_bytes)
-            buf.extend(value)
-            data = bytes(buf)
-        else:  # Binary TLV data
-            if value is not None:
-                raise ValueError("value can only be provided if tag_or_data is a tag")
-            data = tag_or_data
-
-        # mypy thinks this is wrong
-        return super(Tlv, cls).__new__(cls, data)  # type: ignore
-
-    def __init__(self, tag_or_data: Union[int, bytes], value: Optional[bytes] = None):
-        self._tag, self._value_offset, self._value_ln, end = _tlv_parse(self)
-        if len(self) != end:
-            raise ValueError("Incorrect TLV length")
-
-    def __repr__(self):
-        return f"Tlv(tag=0x{self.tag:02x}, value={self.value.hex()})"
-
-    @classmethod
-    def parse_from(cls: Type[T_Tlv], data: bytes) -> Tuple[T_Tlv, bytes]:
-        tag, offs, ln, end = _tlv_parse(data)
-        return cls(data[:end]), data[end:]
-
-    @classmethod
-    def parse_list(cls: Type[T_Tlv], data: bytes) -> List[T_Tlv]:
-        res = []
-        while data:
-            tlv, data = cls.parse_from(data)
-            res.append(tlv)
-        return res
-
-    @classmethod
-    def parse_dict(cls: Type[T_Tlv], data: bytes) -> Dict[int, bytes]:
-        return dict((tlv.tag, tlv.value) for tlv in cls.parse_list(data))
-
-    @classmethod
-    def unpack(cls: Type[T_Tlv], tag: int, data: bytes) -> bytes:
-        tlv = cls(data)
-        if tlv.tag != tag:
-            raise ValueError(f"Wrong tag, got 0x{tlv.tag:02x} expected 0x{tag:02x}")
-        return tlv.value
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from enum import Enum, IntEnum, IntFlag, unique
+from typing import (
+    Type,
+    List,
+    Dict,
+    Tuple,
+    TypeVar,
+    Union,
+    Optional,
+    Hashable,
+    NamedTuple,
+    Callable,
+    ClassVar,
+)
+import re
+import abc
+
+
+_VERSION_STRING_PATTERN = re.compile(r"\b(?P<major>\d+).(?P<minor>\d).(?P<patch>\d)\b")
+
+
+class Version(NamedTuple):
+    """3-digit version tuple."""
+
+    major: int
+    minor: int
+    patch: int
+
+    def __str__(self):
+        return "%d.%d.%d" % self
+
+    @classmethod
+    def from_bytes(cls, data: bytes) -> "Version":
+        return cls(*data)
+
+    @classmethod
+    def from_string(cls, data: str) -> "Version":
+        m = _VERSION_STRING_PATTERN.search(data)
+        if m:
+            return cls(
+                int(m.group("major")), int(m.group("minor")), int(m.group("patch"))
+            )
+        raise ValueError("No version found in string")
+
+
+@unique
+class TRANSPORT(str, Enum):
+    """YubiKey physical connection transports."""
+
+    USB = "usb"
+    NFC = "nfc"
+
+    def __str__(self):
+        return super().__str__().upper()
+
+
+@unique
+class USB_INTERFACE(IntFlag):
+    """YubiKey USB interface identifiers."""
+
+    OTP = 0x01
+    FIDO = 0x02
+    CCID = 0x04
+
+
+@unique
+class YUBIKEY(Enum):
+    """YubiKey hardware platforms."""
+
+    YKS = "YubiKey Standard"
+    NEO = "YubiKey NEO"
+    SKY = "Security Key by Yubico"
+    YKP = "YubiKey Plus"
+    YK4 = "YubiKey"  # This includes YubiKey 5
+
+
+class Connection(abc.ABC):
+    """A connection to a YubiKey"""
+
+    usb_interface: ClassVar[USB_INTERFACE] = USB_INTERFACE(0)
+
+    def close(self) -> None:
+        """Close the device, releasing any held resources."""
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, typ, value, traceback):
+        self.close()
+
+
+@unique
+class PID(IntEnum):
+    """USB Product ID values for YubiKey devices."""
+
+    YKS_OTP = 0x0010
+    NEO_OTP = 0x0110
+    NEO_OTP_CCID = 0x0111
+    NEO_CCID = 0x0112
+    NEO_FIDO = 0x0113
+    NEO_OTP_FIDO = 0x0114
+    NEO_FIDO_CCID = 0x0115
+    NEO_OTP_FIDO_CCID = 0x0116
+    SKY_FIDO = 0x0120
+    YK4_OTP = 0x0401
+    YK4_FIDO = 0x0402
+    YK4_OTP_FIDO = 0x0403
+    YK4_CCID = 0x0404
+    YK4_OTP_CCID = 0x0405
+    YK4_FIDO_CCID = 0x0406
+    YK4_OTP_FIDO_CCID = 0x0407
+    YKP_OTP_FIDO = 0x0410
+
+    @property
+    def yubikey_type(self) -> YUBIKEY:
+        return YUBIKEY[self.name.split("_", 1)[0]]
+
+    @property
+    def usb_interfaces(self) -> USB_INTERFACE:
+        return USB_INTERFACE(sum(USB_INTERFACE[x] for x in self.name.split("_")[1:]))
+
+    @classmethod
+    def of(cls, key_type: YUBIKEY, interfaces: USB_INTERFACE) -> "PID":
+        suffix = "_".join(t.name or str(t) for t in USB_INTERFACE if t in interfaces)
+        return cls[key_type.name + "_" + suffix]
+
+    def supports_connection(self, connection_type: Type[Connection]) -> bool:
+        return connection_type.usb_interface in self.usb_interfaces
+
+
+T_Connection = TypeVar("T_Connection", bound=Connection)
+
+
+class YubiKeyDevice(abc.ABC):
+    """YubiKey device reference"""
+
+    def __init__(self, transport: TRANSPORT, fingerprint: Hashable):
+        self._transport = transport
+        self._fingerprint = fingerprint
+
+    @property
+    def transport(self) -> TRANSPORT:
+        """Get the transport used to communicate with this YubiKey"""
+        return self._transport
+
+    def supports_connection(self, connection_type: Type[Connection]) -> bool:
+        """Check if a YubiKeyDevice supports a specific Connection type"""
+        return False
+
+    # mypy will not accept abstract types in Type[T_Connection]
+    def open_connection(
+        self, connection_type: Union[Type[T_Connection], Callable[..., T_Connection]]
+    ) -> T_Connection:
+        """Opens a connection to the YubiKey"""
+        raise ValueError("Unsupported Connection type")
+
+    @property
+    def fingerprint(self) -> Hashable:
+        """Used to identify that device references from different enumerations represent
+        the same physical YubiKey. This fingerprint is not stable between sessions, or
+        after un-plugging, and re-plugging a device."""
+        return self._fingerprint
+
+    def __eq__(self, other):
+        return isinstance(other, type(self)) and self.fingerprint == other.fingerprint
+
+    def __hash__(self):
+        return hash(self.fingerprint)
+
+    def __repr__(self):
+        return f"{type(self).__name__}(fingerprint={self.fingerprint!r})"
+
+
+class CommandError(Exception):
+    """An error response from a YubiKey"""
+
+
+class BadResponseError(CommandError):
+    """Invalid response data from the YubiKey"""
+
+
+class TimeoutError(CommandError):
+    """An operation timed out waiting for something"""
+
+
+class ApplicationNotAvailableError(CommandError):
+    """The application is either disabled or not supported on this YubiKey"""
+
+
+class NotSupportedError(ValueError):
+    """Attempting an action that is not supported on this YubiKey"""
+
+
+def require_version(
+    my_version: Version, min_version: Tuple[int, int, int], message=None
+):
+    """Ensure a version is at least min_version."""
+    # Skip version checks for major == 0, used for development builds.
+    if my_version < min_version and my_version[0] != 0:
+        if not message:
+            message = "This action requires YubiKey %d.%d.%d or later" % min_version
+        raise NotSupportedError(message)
+
+
+def int2bytes(value: int, min_len: int = 0) -> bytes:
+    buf = []
+    while value > 0xFF:
+        buf.append(value & 0xFF)
+        value >>= 8
+    buf.append(value)
+    return bytes(reversed(buf)).rjust(min_len, b"\0")
+
+
+def bytes2int(data: bytes) -> int:
+    return int.from_bytes(data, "big")
+
+
+def _tlv_parse(data, offset=0):
+    try:
+        tag = data[offset]
+        offset += 1
+        if tag & 0x1F == 0x1F:  # Long form
+            tag = tag << 8 | data[offset]
+            offset += 1
+            while tag & 0x80 == 0x80:  # Additional bytes
+                tag = tag << 8 | data[offset]
+                offset += 1
+
+        ln = data[offset]
+        offset += 1
+        if ln == 0x80:  # Indefinite length
+            end = offset
+            while data[end] or data[end + 1]:  # Run until 0x0000
+                end = _tlv_parse(data, end)[3]  # Skip over TLV
+            ln = end - offset
+            end += 2  # End after 0x0000
+        else:
+            if ln > 0x80:  # Length spans multiple bytes
+                n_bytes = ln - 0x80
+                ln = bytes2int(data[offset : offset + n_bytes])
+                offset += n_bytes
+            end = offset + ln
+
+        return tag, offset, ln, end
+    except IndexError:
+        raise ValueError("Invalid encoding of tag/length")
+
+
+T_Tlv = TypeVar("T_Tlv", bound="Tlv")
+
+
+class Tlv(bytes):
+    @property
+    def tag(self) -> int:
+        return self._tag
+
+    @property
+    def length(self) -> int:
+        return self._value_ln
+
+    @property
+    def value(self) -> bytes:
+        return self[self._value_offset : self._value_offset + self._value_ln]
+
+    def __new__(cls, tag_or_data: Union[int, bytes], value: Optional[bytes] = None):
+        """This allows creation by passing either binary data, or tag and value."""
+        if isinstance(tag_or_data, int):  # Tag and (optional) value
+            tag = tag_or_data
+
+            # Pack into Tlv
+            buf = bytearray()
+            buf.extend(int2bytes(tag))
+            value = value or b""
+            length = len(value)
+            if length < 0x80:
+                buf.append(length)
+            else:
+                ln_bytes = int2bytes(length)
+                buf.append(0x80 | len(ln_bytes))
+                buf.extend(ln_bytes)
+            buf.extend(value)
+            data = bytes(buf)
+        else:  # Binary TLV data
+            if value is not None:
+                raise ValueError("value can only be provided if tag_or_data is a tag")
+            data = tag_or_data
+
+        # mypy thinks this is wrong
+        return super(Tlv, cls).__new__(cls, data)  # type: ignore
+
+    def __init__(self, tag_or_data: Union[int, bytes], value: Optional[bytes] = None):
+        self._tag, self._value_offset, self._value_ln, end = _tlv_parse(self)
+        if len(self) != end:
+            raise ValueError("Incorrect TLV length")
+
+    def __repr__(self):
+        return f"Tlv(tag=0x{self.tag:02x}, value={self.value.hex()})"
+
+    @classmethod
+    def parse_from(cls: Type[T_Tlv], data: bytes) -> Tuple[T_Tlv, bytes]:
+        tag, offs, ln, end = _tlv_parse(data)
+        return cls(data[:end]), data[end:]
+
+    @classmethod
+    def parse_list(cls: Type[T_Tlv], data: bytes) -> List[T_Tlv]:
+        res = []
+        while data:
+            tlv, data = cls.parse_from(data)
+            res.append(tlv)
+        return res
+
+    @classmethod
+    def parse_dict(cls: Type[T_Tlv], data: bytes) -> Dict[int, bytes]:
+        return dict((tlv.tag, tlv.value) for tlv in cls.parse_list(data))
+
+    @classmethod
+    def unpack(cls: Type[T_Tlv], tag: int, data: bytes) -> bytes:
+        tlv = cls(data)
+        if tlv.tag != tag:
+            raise ValueError(f"Wrong tag, got 0x{tlv.tag:02x} expected 0x{tag:02x}")
+        return tlv.value
```

### Comparing `yubikey_manager-5.1.0/yubikit/core/otp.py` & `yubikey_manager-5.1.1/yubikit/core/otp.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,262 +1,265 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from . import Connection, CommandError, TimeoutError, Version, USB_INTERFACE
-from yubikit.logging import LOG_LEVEL
-
-from time import sleep
-from threading import Event
-from typing import Optional, Callable
-import abc
-import struct
-import logging
-
-logger = logging.getLogger(__name__)
-
-
-MODHEX_ALPHABET = "cbdefghijklnrtuv"
-
-
-class CommandRejectedError(CommandError):
-    """The issues command was rejected by the YubiKey"""
-
-
-class OtpConnection(Connection, metaclass=abc.ABCMeta):
-    usb_interface = USB_INTERFACE.OTP
-
-    @abc.abstractmethod
-    def receive(self) -> bytes:
-        """Reads an 8 byte feature report"""
-
-    @abc.abstractmethod
-    def send(self, data: bytes) -> None:
-        """Writes an 8 byte feature report"""
-
-
-CRC_OK_RESIDUAL = 0xF0B8
-
-
-def calculate_crc(data: bytes) -> int:
-    crc = 0xFFFF
-    for index in range(len(data)):
-        crc ^= data[index]
-        for i in range(8):
-            j = crc & 1
-            crc >>= 1
-            if j == 1:
-                crc ^= 0x8408
-    return crc & 0xFFFF
-
-
-def check_crc(data: bytes) -> bool:
-    return calculate_crc(data) == CRC_OK_RESIDUAL
-
-
-def modhex_encode(data: bytes) -> str:
-    """Encode a bytes-like object using Modhex (modified hexadecimal) encoding."""
-    return "".join(MODHEX_ALPHABET[b >> 4] + MODHEX_ALPHABET[b & 0xF] for b in data)
-
-
-def modhex_decode(string: str) -> bytes:
-    """Decode the Modhex (modified hexadecimal) string."""
-    return bytes(
-        MODHEX_ALPHABET.index(string[i]) << 4 | MODHEX_ALPHABET.index(string[i + 1])
-        for i in range(0, len(string), 2)
-    )
-
-
-FEATURE_RPT_SIZE = 8
-FEATURE_RPT_DATA_SIZE = FEATURE_RPT_SIZE - 1
-
-SLOT_DATA_SIZE = 64
-FRAME_SIZE = SLOT_DATA_SIZE + 6
-
-RESP_PENDING_FLAG = 0x40  # Response pending flag
-SLOT_WRITE_FLAG = 0x80  # Write flag - set by app - cleared by device
-RESP_TIMEOUT_WAIT_FLAG = 0x20  # Waiting for timeout operation
-DUMMY_REPORT_WRITE = 0x8F  # Write a dummy report to force update or abort
-
-SEQUENCE_MASK = 0x1F
-
-STATUS_OFFSET_PROG_SEQ = 0x4
-STATUS_OFFSET_TOUCH_LOW = 0x5
-CONFIG_STATUS_MASK = 0x1F
-
-STATUS_PROCESSING = 1
-STATUS_UPNEEDED = 2
-
-
-def _should_send(packet, seq):
-    """All-zero packets are skipped, except for the very first and last packets"""
-    return seq in (0, 9) or any(packet)
-
-
-def _format_frame(slot, payload):
-    return payload + struct.pack("<BH", slot, calculate_crc(payload)) + b"\0\0\0"
-
-
-class OtpProtocol:
-    def __init__(self, otp_connection: OtpConnection):
-        self.connection = otp_connection
-        report = self._receive()
-        self.version = Version.from_bytes(report[1:4])
-        if self.version[0] == 3:  # NEO, may have cached pgmSeq in arbitrator
-            try:  # Force communication with applet to refresh pgmSeq
-                # Write an invalid scan map, does nothing
-                self.send_and_receive(0x12, b"c" * 51)
-            except CommandRejectedError:
-                pass  # This is expected
-
-    def close(self) -> None:
-        self.connection.close()
-
-    def send_and_receive(
-        self,
-        slot: int,
-        data: Optional[bytes] = None,
-        event: Optional[Event] = None,
-        on_keepalive: Optional[Callable[[int], None]] = None,
-    ) -> bytes:
-        """Sends a command to the YubiKey, and reads the response.
-
-        If the command results in a configuration update, the programming sequence
-        number is verified and the updated status bytes are returned.
-
-        @param slot  the slot to send to
-        @param data  the data payload to send
-        @param state optional CommandState for listening for user presence requirement
-            and for cancelling a command.
-        @return response data (including CRC) in the case of data, or an updated status
-            struct
-        """
-        payload = (data or b"").ljust(SLOT_DATA_SIZE, b"\0")
-        if len(payload) > SLOT_DATA_SIZE:
-            raise ValueError("Payload too large for HID frame")
-        if not on_keepalive:
-            on_keepalive = lambda x: None  # noqa
-        frame = _format_frame(slot, payload)
-
-        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", frame.hex())
-        response = self._read_frame(
-            self._send_frame(frame), event or Event(), on_keepalive
-        )
-        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", response.hex())
-        return response
-
-    def _receive(self):
-        report = self.connection.receive()
-        if len(report) != FEATURE_RPT_SIZE:
-            raise Exception(
-                f"Incorrect reature report size (was {len(report)}, "
-                f"expected {FEATURE_RPT_SIZE})"
-            )
-        return report
-
-    def read_status(self) -> bytes:
-        """Receive status bytes from YubiKey
-
-        @return status bytes (first 3 bytes are the firmware version)
-        @throws IOException in case of communication error
-        """
-        return self._receive()[1:-1]
-
-    def _await_ready_to_write(self):
-        """Sleep for up to ~1s waiting for the WRITE flag to be unset"""
-        for _ in range(20):
-            if (self._receive()[FEATURE_RPT_DATA_SIZE] & SLOT_WRITE_FLAG) == 0:
-                return
-            sleep(0.05)
-        raise Exception("Timeout waiting for YubiKey to become ready to receive")
-
-    def _send_frame(self, buf):
-        """Sends a 70 byte frame"""
-        prog_seq = self._receive()[STATUS_OFFSET_PROG_SEQ]
-        seq = 0
-        while buf:
-            report, buf = buf[:FEATURE_RPT_DATA_SIZE], buf[FEATURE_RPT_DATA_SIZE:]
-            if _should_send(report, seq):
-                report += struct.pack(">B", 0x80 | seq)
-                self._await_ready_to_write()
-                self.connection.send(report)
-            seq += 1
-
-        return prog_seq
-
-    def _read_frame(self, prog_seq, event, on_keepalive):
-        """Reads one frame"""
-        response = b""
-        seq = 0
-        needs_touch = False
-
-        try:
-            while True:
-                report = self._receive()
-                status_byte = report[FEATURE_RPT_DATA_SIZE]
-                if (status_byte & RESP_PENDING_FLAG) != 0:  # Response packet
-                    if seq == (status_byte & SEQUENCE_MASK):
-                        # Correct sequence
-                        response += report[:FEATURE_RPT_DATA_SIZE]
-                        seq += 1
-                    elif 0 == (status_byte & SEQUENCE_MASK):
-                        # Transmission complete
-                        self._reset_state()
-                        return response
-                elif status_byte == 0:  # Status response
-                    next_prog_seq = report[STATUS_OFFSET_PROG_SEQ]
-                    if response:
-                        raise Exception("Incomplete transfer")
-                    elif next_prog_seq == prog_seq + 1 or (
-                        prog_seq > 0
-                        and next_prog_seq == 0
-                        and report[STATUS_OFFSET_TOUCH_LOW] & CONFIG_STATUS_MASK == 0
-                    ):  # Note: If no valid configurations exist, prog_seq resets to 0.
-                        # Sequence updated, return status.
-                        return report[1:-1]
-                    elif needs_touch:
-                        raise TimeoutError("Timed out waiting for touch")
-                    else:
-                        raise CommandRejectedError("No data")
-                else:  # Need to wait
-                    if (status_byte & RESP_TIMEOUT_WAIT_FLAG) != 0:
-                        on_keepalive(STATUS_UPNEEDED)
-                        needs_touch = True
-                        timeout = 0.1
-                    else:
-                        on_keepalive(STATUS_PROCESSING)
-                        timeout = 0.02
-                    sleep(timeout)
-                    if event.wait(timeout):
-                        self._reset_state()
-                        raise TimeoutError("Command cancelled by Event")
-        except KeyboardInterrupt:
-            logger.debug("Keyboard interrupt, reset state...")
-            self._reset_state()
-            raise
-
-    def _reset_state(self):
-        """Reset the state of YubiKey from reading"""
-        self.connection.send(b"\xff".rjust(FEATURE_RPT_SIZE, b"\0"))
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from . import Connection, CommandError, TimeoutError, Version, USB_INTERFACE
+from yubikit.logging import LOG_LEVEL
+
+from time import sleep
+from threading import Event
+from typing import Optional, Callable
+import abc
+import struct
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+MODHEX_ALPHABET = "cbdefghijklnrtuv"
+
+
+class CommandRejectedError(CommandError):
+    """The issues command was rejected by the YubiKey"""
+
+
+class OtpConnection(Connection, metaclass=abc.ABCMeta):
+    usb_interface = USB_INTERFACE.OTP
+
+    @abc.abstractmethod
+    def receive(self) -> bytes:
+        """Reads an 8 byte feature report"""
+
+    @abc.abstractmethod
+    def send(self, data: bytes) -> None:
+        """Writes an 8 byte feature report"""
+
+
+CRC_OK_RESIDUAL = 0xF0B8
+
+
+def calculate_crc(data: bytes) -> int:
+    crc = 0xFFFF
+    for index in range(len(data)):
+        crc ^= data[index]
+        for i in range(8):
+            j = crc & 1
+            crc >>= 1
+            if j == 1:
+                crc ^= 0x8408
+    return crc & 0xFFFF
+
+
+def check_crc(data: bytes) -> bool:
+    return calculate_crc(data) == CRC_OK_RESIDUAL
+
+
+def modhex_encode(data: bytes) -> str:
+    """Encode a bytes-like object using Modhex (modified hexadecimal) encoding."""
+    return "".join(MODHEX_ALPHABET[b >> 4] + MODHEX_ALPHABET[b & 0xF] for b in data)
+
+
+def modhex_decode(string: str) -> bytes:
+    """Decode the Modhex (modified hexadecimal) string."""
+    if len(string) % 2:
+        raise ValueError("Length must be a multiple of 2")
+
+    return bytes(
+        MODHEX_ALPHABET.index(string[i]) << 4 | MODHEX_ALPHABET.index(string[i + 1])
+        for i in range(0, len(string), 2)
+    )
+
+
+FEATURE_RPT_SIZE = 8
+FEATURE_RPT_DATA_SIZE = FEATURE_RPT_SIZE - 1
+
+SLOT_DATA_SIZE = 64
+FRAME_SIZE = SLOT_DATA_SIZE + 6
+
+RESP_PENDING_FLAG = 0x40  # Response pending flag
+SLOT_WRITE_FLAG = 0x80  # Write flag - set by app - cleared by device
+RESP_TIMEOUT_WAIT_FLAG = 0x20  # Waiting for timeout operation
+DUMMY_REPORT_WRITE = 0x8F  # Write a dummy report to force update or abort
+
+SEQUENCE_MASK = 0x1F
+
+STATUS_OFFSET_PROG_SEQ = 0x4
+STATUS_OFFSET_TOUCH_LOW = 0x5
+CONFIG_STATUS_MASK = 0x1F
+
+STATUS_PROCESSING = 1
+STATUS_UPNEEDED = 2
+
+
+def _should_send(packet, seq):
+    """All-zero packets are skipped, except for the very first and last packets"""
+    return seq in (0, 9) or any(packet)
+
+
+def _format_frame(slot, payload):
+    return payload + struct.pack("<BH", slot, calculate_crc(payload)) + b"\0\0\0"
+
+
+class OtpProtocol:
+    def __init__(self, otp_connection: OtpConnection):
+        self.connection = otp_connection
+        report = self._receive()
+        self.version = Version.from_bytes(report[1:4])
+        if self.version[0] == 3:  # NEO, may have cached pgmSeq in arbitrator
+            try:  # Force communication with applet to refresh pgmSeq
+                # Write an invalid scan map, does nothing
+                self.send_and_receive(0x12, b"c" * 51)
+            except CommandRejectedError:
+                pass  # This is expected
+
+    def close(self) -> None:
+        self.connection.close()
+
+    def send_and_receive(
+        self,
+        slot: int,
+        data: Optional[bytes] = None,
+        event: Optional[Event] = None,
+        on_keepalive: Optional[Callable[[int], None]] = None,
+    ) -> bytes:
+        """Sends a command to the YubiKey, and reads the response.
+
+        If the command results in a configuration update, the programming sequence
+        number is verified and the updated status bytes are returned.
+
+        @param slot  the slot to send to
+        @param data  the data payload to send
+        @param state optional CommandState for listening for user presence requirement
+            and for cancelling a command.
+        @return response data (including CRC) in the case of data, or an updated status
+            struct
+        """
+        payload = (data or b"").ljust(SLOT_DATA_SIZE, b"\0")
+        if len(payload) > SLOT_DATA_SIZE:
+            raise ValueError("Payload too large for HID frame")
+        if not on_keepalive:
+            on_keepalive = lambda x: None  # noqa
+        frame = _format_frame(slot, payload)
+
+        logger.log(LOG_LEVEL.TRAFFIC, "SEND: %s", frame.hex())
+        response = self._read_frame(
+            self._send_frame(frame), event or Event(), on_keepalive
+        )
+        logger.log(LOG_LEVEL.TRAFFIC, "RECV: %s", response.hex())
+        return response
+
+    def _receive(self):
+        report = self.connection.receive()
+        if len(report) != FEATURE_RPT_SIZE:
+            raise Exception(
+                f"Incorrect reature report size (was {len(report)}, "
+                f"expected {FEATURE_RPT_SIZE})"
+            )
+        return report
+
+    def read_status(self) -> bytes:
+        """Receive status bytes from YubiKey
+
+        @return status bytes (first 3 bytes are the firmware version)
+        @throws IOException in case of communication error
+        """
+        return self._receive()[1:-1]
+
+    def _await_ready_to_write(self):
+        """Sleep for up to ~1s waiting for the WRITE flag to be unset"""
+        for _ in range(20):
+            if (self._receive()[FEATURE_RPT_DATA_SIZE] & SLOT_WRITE_FLAG) == 0:
+                return
+            sleep(0.05)
+        raise Exception("Timeout waiting for YubiKey to become ready to receive")
+
+    def _send_frame(self, buf):
+        """Sends a 70 byte frame"""
+        prog_seq = self._receive()[STATUS_OFFSET_PROG_SEQ]
+        seq = 0
+        while buf:
+            report, buf = buf[:FEATURE_RPT_DATA_SIZE], buf[FEATURE_RPT_DATA_SIZE:]
+            if _should_send(report, seq):
+                report += struct.pack(">B", 0x80 | seq)
+                self._await_ready_to_write()
+                self.connection.send(report)
+            seq += 1
+
+        return prog_seq
+
+    def _read_frame(self, prog_seq, event, on_keepalive):
+        """Reads one frame"""
+        response = b""
+        seq = 0
+        needs_touch = False
+
+        try:
+            while True:
+                report = self._receive()
+                status_byte = report[FEATURE_RPT_DATA_SIZE]
+                if (status_byte & RESP_PENDING_FLAG) != 0:  # Response packet
+                    if seq == (status_byte & SEQUENCE_MASK):
+                        # Correct sequence
+                        response += report[:FEATURE_RPT_DATA_SIZE]
+                        seq += 1
+                    elif 0 == (status_byte & SEQUENCE_MASK):
+                        # Transmission complete
+                        self._reset_state()
+                        return response
+                elif status_byte == 0:  # Status response
+                    next_prog_seq = report[STATUS_OFFSET_PROG_SEQ]
+                    if response:
+                        raise Exception("Incomplete transfer")
+                    elif next_prog_seq == prog_seq + 1 or (
+                        prog_seq > 0
+                        and next_prog_seq == 0
+                        and report[STATUS_OFFSET_TOUCH_LOW] & CONFIG_STATUS_MASK == 0
+                    ):  # Note: If no valid configurations exist, prog_seq resets to 0.
+                        # Sequence updated, return status.
+                        return report[1:-1]
+                    elif needs_touch:
+                        raise TimeoutError("Timed out waiting for touch")
+                    else:
+                        raise CommandRejectedError("No data")
+                else:  # Need to wait
+                    if (status_byte & RESP_TIMEOUT_WAIT_FLAG) != 0:
+                        on_keepalive(STATUS_UPNEEDED)
+                        needs_touch = True
+                        timeout = 0.1
+                    else:
+                        on_keepalive(STATUS_PROCESSING)
+                        timeout = 0.02
+                    sleep(timeout)
+                    if event.wait(timeout):
+                        self._reset_state()
+                        raise TimeoutError("Command cancelled by Event")
+        except KeyboardInterrupt:
+            logger.debug("Keyboard interrupt, reset state...")
+            self._reset_state()
+            raise
+
+    def _reset_state(self):
+        """Reset the state of YubiKey from reading"""
+        self.connection.send(b"\xff".rjust(FEATURE_RPT_SIZE, b"\0"))
```

### Comparing `yubikey_manager-5.1.0/yubikit/core/smartcard.py` & `yubikey_manager-5.1.1/yubikit/core/smartcard.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,220 +1,220 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from . import (
-    Version,
-    TRANSPORT,
-    USB_INTERFACE,
-    Connection,
-    CommandError,
-    ApplicationNotAvailableError,
-)
-from time import time
-from enum import Enum, IntEnum, unique
-from typing import Tuple
-import abc
-import struct
-import logging
-
-logger = logging.getLogger(__name__)
-
-
-class ApduError(CommandError):
-    """Thrown when an APDU response has the wrong SW code"""
-
-    def __init__(self, data: bytes, sw: int):
-        self.data = data
-        self.sw = sw
-
-    def __str__(self):
-        return f"APDU error: SW=0x{self.sw:04x}"
-
-
-@unique
-class ApduFormat(str, Enum):
-    """APDU encoding format"""
-
-    SHORT = "short"
-    EXTENDED = "extended"
-
-
-@unique
-class AID(bytes, Enum):
-    """YubiKey Application smart card AID values."""
-
-    OTP = bytes.fromhex("a0000005272001")
-    MANAGEMENT = bytes.fromhex("a000000527471117")
-    OPENPGP = bytes.fromhex("d27600012401")
-    OATH = bytes.fromhex("a0000005272101")
-    PIV = bytes.fromhex("a000000308")
-    FIDO = bytes.fromhex("a0000006472f0001")
-    HSMAUTH = bytes.fromhex("a000000527210701")
-
-
-@unique
-class SW(IntEnum):
-    NO_INPUT_DATA = 0x6285
-    VERIFY_FAIL_NO_RETRY = 0x63C0
-    WRONG_LENGTH = 0x6700
-    SECURITY_CONDITION_NOT_SATISFIED = 0x6982
-    AUTH_METHOD_BLOCKED = 0x6983
-    DATA_INVALID = 0x6984
-    CONDITIONS_NOT_SATISFIED = 0x6985
-    COMMAND_NOT_ALLOWED = 0x6986
-    INCORRECT_PARAMETERS = 0x6A80
-    FUNCTION_NOT_SUPPORTED = 0x6A81
-    FILE_NOT_FOUND = 0x6A82
-    NO_SPACE = 0x6A84
-    REFERENCE_DATA_NOT_FOUND = 0x6A88
-    APPLET_SELECT_FAILED = 0x6999
-    WRONG_PARAMETERS_P1P2 = 0x6B00
-    INVALID_INSTRUCTION = 0x6D00
-    COMMAND_ABORTED = 0x6F00
-    OK = 0x9000
-
-
-class SmartCardConnection(Connection, metaclass=abc.ABCMeta):
-    usb_interface = USB_INTERFACE.CCID
-
-    @property
-    @abc.abstractmethod
-    def transport(self) -> TRANSPORT:
-        """Get the transport type of the connection (USB or NFC)"""
-
-    @abc.abstractmethod
-    def send_and_receive(self, apdu: bytes) -> Tuple[bytes, int]:
-        """Sends a command APDU and returns the response"""
-
-
-INS_SELECT = 0xA4
-P1_SELECT = 0x04
-P2_SELECT = 0x00
-
-INS_SEND_REMAINING = 0xC0
-SW1_HAS_MORE_DATA = 0x61
-
-SHORT_APDU_MAX_CHUNK = 0xFF
-
-
-def _encode_short_apdu(cla, ins, p1, p2, data, le=0):
-    buf = struct.pack(">BBBBB", cla, ins, p1, p2, len(data)) + data
-    if le:
-        buf += struct.pack(">B", le)
-    return buf
-
-
-def _encode_extended_apdu(cla, ins, p1, p2, data, le=0):
-    buf = struct.pack(">BBBBBH", cla, ins, p1, p2, 0, len(data)) + data
-    if le:
-        buf += struct.pack(">H", le)
-    return buf
-
-
-class SmartCardProtocol:
-    def __init__(
-        self,
-        smartcard_connection: SmartCardConnection,
-        ins_send_remaining: int = INS_SEND_REMAINING,
-    ):
-        self.apdu_format = ApduFormat.SHORT
-        self.connection = smartcard_connection
-        self._ins_send_remaining = ins_send_remaining
-        self._touch_workaround = False
-        self._last_long_resp = 0.0
-
-    def close(self) -> None:
-        self.connection.close()
-
-    def enable_touch_workaround(self, version: Version) -> None:
-        self._touch_workaround = self.connection.transport == TRANSPORT.USB and (
-            (4, 2, 0) <= version <= (4, 2, 6)
-        )
-        logger.debug(f"Touch workaround enabled={self._touch_workaround}")
-
-    def select(self, aid: bytes) -> bytes:
-        try:
-            return self.send_apdu(0, INS_SELECT, P1_SELECT, P2_SELECT, aid)
-        except ApduError as e:
-            if e.sw in (
-                SW.FILE_NOT_FOUND,
-                SW.APPLET_SELECT_FAILED,
-                SW.INVALID_INSTRUCTION,
-                SW.WRONG_PARAMETERS_P1P2,
-            ):
-                raise ApplicationNotAvailableError()
-            raise
-
-    def send_apdu(
-        self, cla: int, ins: int, p1: int, p2: int, data: bytes = b"", le: int = 0
-    ) -> bytes:
-        if (
-            self._touch_workaround
-            and self._last_long_resp > 0
-            and time() - self._last_long_resp < 2
-        ):
-            logger.debug("Sending dummy APDU as touch workaround")
-            self.connection.send_and_receive(
-                _encode_short_apdu(0, 0, 0, 0, b"")
-            )  # Dummy APDU, returns error
-            self._last_long_resp = 0
-
-        if self.apdu_format is ApduFormat.SHORT:
-            while len(data) > SHORT_APDU_MAX_CHUNK:
-                chunk, data = data[:SHORT_APDU_MAX_CHUNK], data[SHORT_APDU_MAX_CHUNK:]
-                response, sw = self.connection.send_and_receive(
-                    _encode_short_apdu(0x10 | cla, ins, p1, p2, chunk, le)
-                )
-                if sw != SW.OK:
-                    raise ApduError(response, sw)
-            response, sw = self.connection.send_and_receive(
-                _encode_short_apdu(cla, ins, p1, p2, data, le)
-            )
-            get_data = _encode_short_apdu(0, self._ins_send_remaining, 0, 0, b"")
-        elif self.apdu_format is ApduFormat.EXTENDED:
-            response, sw = self.connection.send_and_receive(
-                _encode_extended_apdu(cla, ins, p1, p2, data, le)
-            )
-            get_data = _encode_extended_apdu(0, self._ins_send_remaining, 0, 0, b"")
-        else:
-            raise TypeError("Invalid ApduFormat set")
-
-        # Read chained response
-        buf = b""
-        while sw >> 8 == SW1_HAS_MORE_DATA:
-            buf += response
-            response, sw = self.connection.send_and_receive(get_data)
-
-        if sw != SW.OK:
-            raise ApduError(response, sw)
-        buf += response
-
-        if self._touch_workaround and len(buf) > 54:
-            self._last_long_resp = time()
-        else:
-            self._last_long_resp = 0
-
-        return buf
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from . import (
+    Version,
+    TRANSPORT,
+    USB_INTERFACE,
+    Connection,
+    CommandError,
+    ApplicationNotAvailableError,
+)
+from time import time
+from enum import Enum, IntEnum, unique
+from typing import Tuple
+import abc
+import struct
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+class ApduError(CommandError):
+    """Thrown when an APDU response has the wrong SW code"""
+
+    def __init__(self, data: bytes, sw: int):
+        self.data = data
+        self.sw = sw
+
+    def __str__(self):
+        return f"APDU error: SW=0x{self.sw:04x}"
+
+
+@unique
+class ApduFormat(str, Enum):
+    """APDU encoding format"""
+
+    SHORT = "short"
+    EXTENDED = "extended"
+
+
+@unique
+class AID(bytes, Enum):
+    """YubiKey Application smart card AID values."""
+
+    OTP = bytes.fromhex("a0000005272001")
+    MANAGEMENT = bytes.fromhex("a000000527471117")
+    OPENPGP = bytes.fromhex("d27600012401")
+    OATH = bytes.fromhex("a0000005272101")
+    PIV = bytes.fromhex("a000000308")
+    FIDO = bytes.fromhex("a0000006472f0001")
+    HSMAUTH = bytes.fromhex("a000000527210701")
+
+
+@unique
+class SW(IntEnum):
+    NO_INPUT_DATA = 0x6285
+    VERIFY_FAIL_NO_RETRY = 0x63C0
+    WRONG_LENGTH = 0x6700
+    SECURITY_CONDITION_NOT_SATISFIED = 0x6982
+    AUTH_METHOD_BLOCKED = 0x6983
+    DATA_INVALID = 0x6984
+    CONDITIONS_NOT_SATISFIED = 0x6985
+    COMMAND_NOT_ALLOWED = 0x6986
+    INCORRECT_PARAMETERS = 0x6A80
+    FUNCTION_NOT_SUPPORTED = 0x6A81
+    FILE_NOT_FOUND = 0x6A82
+    NO_SPACE = 0x6A84
+    REFERENCE_DATA_NOT_FOUND = 0x6A88
+    APPLET_SELECT_FAILED = 0x6999
+    WRONG_PARAMETERS_P1P2 = 0x6B00
+    INVALID_INSTRUCTION = 0x6D00
+    COMMAND_ABORTED = 0x6F00
+    OK = 0x9000
+
+
+class SmartCardConnection(Connection, metaclass=abc.ABCMeta):
+    usb_interface = USB_INTERFACE.CCID
+
+    @property
+    @abc.abstractmethod
+    def transport(self) -> TRANSPORT:
+        """Get the transport type of the connection (USB or NFC)"""
+
+    @abc.abstractmethod
+    def send_and_receive(self, apdu: bytes) -> Tuple[bytes, int]:
+        """Sends a command APDU and returns the response"""
+
+
+INS_SELECT = 0xA4
+P1_SELECT = 0x04
+P2_SELECT = 0x00
+
+INS_SEND_REMAINING = 0xC0
+SW1_HAS_MORE_DATA = 0x61
+
+SHORT_APDU_MAX_CHUNK = 0xFF
+
+
+def _encode_short_apdu(cla, ins, p1, p2, data, le=0):
+    buf = struct.pack(">BBBBB", cla, ins, p1, p2, len(data)) + data
+    if le:
+        buf += struct.pack(">B", le)
+    return buf
+
+
+def _encode_extended_apdu(cla, ins, p1, p2, data, le=0):
+    buf = struct.pack(">BBBBBH", cla, ins, p1, p2, 0, len(data)) + data
+    if le:
+        buf += struct.pack(">H", le)
+    return buf
+
+
+class SmartCardProtocol:
+    def __init__(
+        self,
+        smartcard_connection: SmartCardConnection,
+        ins_send_remaining: int = INS_SEND_REMAINING,
+    ):
+        self.apdu_format = ApduFormat.SHORT
+        self.connection = smartcard_connection
+        self._ins_send_remaining = ins_send_remaining
+        self._touch_workaround = False
+        self._last_long_resp = 0.0
+
+    def close(self) -> None:
+        self.connection.close()
+
+    def enable_touch_workaround(self, version: Version) -> None:
+        self._touch_workaround = self.connection.transport == TRANSPORT.USB and (
+            (4, 2, 0) <= version <= (4, 2, 6)
+        )
+        logger.debug(f"Touch workaround enabled={self._touch_workaround}")
+
+    def select(self, aid: bytes) -> bytes:
+        try:
+            return self.send_apdu(0, INS_SELECT, P1_SELECT, P2_SELECT, aid)
+        except ApduError as e:
+            if e.sw in (
+                SW.FILE_NOT_FOUND,
+                SW.APPLET_SELECT_FAILED,
+                SW.INVALID_INSTRUCTION,
+                SW.WRONG_PARAMETERS_P1P2,
+            ):
+                raise ApplicationNotAvailableError()
+            raise
+
+    def send_apdu(
+        self, cla: int, ins: int, p1: int, p2: int, data: bytes = b"", le: int = 0
+    ) -> bytes:
+        if (
+            self._touch_workaround
+            and self._last_long_resp > 0
+            and time() - self._last_long_resp < 2
+        ):
+            logger.debug("Sending dummy APDU as touch workaround")
+            self.connection.send_and_receive(
+                _encode_short_apdu(0, 0, 0, 0, b"")
+            )  # Dummy APDU, returns error
+            self._last_long_resp = 0
+
+        if self.apdu_format is ApduFormat.SHORT:
+            while len(data) > SHORT_APDU_MAX_CHUNK:
+                chunk, data = data[:SHORT_APDU_MAX_CHUNK], data[SHORT_APDU_MAX_CHUNK:]
+                response, sw = self.connection.send_and_receive(
+                    _encode_short_apdu(0x10 | cla, ins, p1, p2, chunk, le)
+                )
+                if sw != SW.OK:
+                    raise ApduError(response, sw)
+            response, sw = self.connection.send_and_receive(
+                _encode_short_apdu(cla, ins, p1, p2, data, le)
+            )
+            get_data = _encode_short_apdu(0, self._ins_send_remaining, 0, 0, b"")
+        elif self.apdu_format is ApduFormat.EXTENDED:
+            response, sw = self.connection.send_and_receive(
+                _encode_extended_apdu(cla, ins, p1, p2, data, le)
+            )
+            get_data = _encode_extended_apdu(0, self._ins_send_remaining, 0, 0, b"")
+        else:
+            raise TypeError("Invalid ApduFormat set")
+
+        # Read chained response
+        buf = b""
+        while sw >> 8 == SW1_HAS_MORE_DATA:
+            buf += response
+            response, sw = self.connection.send_and_receive(get_data)
+
+        if sw != SW.OK:
+            raise ApduError(response, sw)
+        buf += response
+
+        if self._touch_workaround and len(buf) > 54:
+            self._last_long_resp = time()
+        else:
+            self._last_long_resp = 0
+
+        return buf
```

### Comparing `yubikey_manager-5.1.0/yubikit/logging.py` & `yubikey_manager-5.1.1/yubikit/logging.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-# Copyright (c) 2022 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from enum import IntEnum, unique
-import logging
-
-
-@unique
-class LOG_LEVEL(IntEnum):
-    ERROR = logging.ERROR
-    WARNING = logging.WARNING
-    INFO = logging.INFO
-    DEBUG = logging.DEBUG
-    TRAFFIC = 5  # Used for logging YubiKey traffic
-    NOTSET = logging.NOTSET
+# Copyright (c) 2022 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from enum import IntEnum, unique
+import logging
+
+
+@unique
+class LOG_LEVEL(IntEnum):
+    ERROR = logging.ERROR
+    WARNING = logging.WARNING
+    INFO = logging.INFO
+    DEBUG = logging.DEBUG
+    TRAFFIC = 5  # Used for logging YubiKey traffic
+    NOTSET = logging.NOTSET
```

### Comparing `yubikey_manager-5.1.0/yubikit/management.py` & `yubikey_manager-5.1.1/yubikit/management.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,522 +1,522 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from .core import (
-    bytes2int,
-    int2bytes,
-    require_version,
-    Version,
-    Tlv,
-    TRANSPORT,
-    USB_INTERFACE,
-    NotSupportedError,
-    BadResponseError,
-    ApplicationNotAvailableError,
-)
-from .core.otp import (
-    check_crc,
-    OtpConnection,
-    OtpProtocol,
-    STATUS_OFFSET_PROG_SEQ,
-    CommandRejectedError,
-)
-from .core.fido import FidoConnection
-from .core.smartcard import AID, SmartCardConnection, SmartCardProtocol
-from fido2.hid import CAPABILITY as CTAP_CAPABILITY
-
-from enum import IntEnum, IntFlag, unique
-from dataclasses import dataclass
-from typing import Optional, Union, Mapping
-import abc
-import struct
-import logging
-
-logger = logging.getLogger(__name__)
-
-
-@unique
-class CAPABILITY(IntFlag):
-    """YubiKey Application identifiers."""
-
-    OTP = 0x01
-    U2F = 0x02
-    FIDO2 = 0x200
-    OATH = 0x20
-    PIV = 0x10
-    OPENPGP = 0x08
-    HSMAUTH = 0x100
-
-    def __str__(self):
-        name = "|".join(c.name or str(c) for c in CAPABILITY if c in self)
-        return f"{name}: {hex(self)}"
-
-    @property
-    def display_name(self):
-        if self == CAPABILITY.U2F:
-            return "FIDO U2F"
-        elif self == CAPABILITY.OPENPGP:
-            return "OpenPGP"
-        elif self == CAPABILITY.HSMAUTH:
-            return "YubiHSM Auth"
-        return self.name or ", ".join(c.display_name for c in CAPABILITY if c in self)
-
-    @property
-    def usb_interfaces(self) -> USB_INTERFACE:
-        ifaces = USB_INTERFACE(0)
-        if self & CAPABILITY.OTP:
-            ifaces |= USB_INTERFACE.OTP
-        if self & (CAPABILITY.U2F | CAPABILITY.FIDO2):
-            ifaces |= USB_INTERFACE.FIDO
-        if self & (
-            CAPABILITY.OATH | CAPABILITY.PIV | CAPABILITY.OPENPGP | CAPABILITY.HSMAUTH
-        ):
-            ifaces |= USB_INTERFACE.CCID
-        return ifaces
-
-
-@unique
-class FORM_FACTOR(IntEnum):
-    """YubiKey device form factors."""
-
-    UNKNOWN = 0x00
-    USB_A_KEYCHAIN = 0x01
-    USB_A_NANO = 0x02
-    USB_C_KEYCHAIN = 0x03
-    USB_C_NANO = 0x04
-    USB_C_LIGHTNING = 0x05
-    USB_A_BIO = 0x06
-    USB_C_BIO = 0x07
-
-    def __str__(self):
-        if self == FORM_FACTOR.USB_A_KEYCHAIN:
-            return "Keychain (USB-A)"
-        elif self == FORM_FACTOR.USB_A_NANO:
-            return "Nano (USB-A)"
-        elif self == FORM_FACTOR.USB_C_KEYCHAIN:
-            return "Keychain (USB-C)"
-        elif self == FORM_FACTOR.USB_C_NANO:
-            return "Nano (USB-C)"
-        elif self == FORM_FACTOR.USB_C_LIGHTNING:
-            return "Keychain (USB-C, Lightning)"
-        elif self == FORM_FACTOR.USB_A_BIO:
-            return "Bio (USB-A)"
-        elif self == FORM_FACTOR.USB_C_BIO:
-            return "Bio (USB-C)"
-        else:
-            return "Unknown"
-
-    @classmethod
-    def from_code(cls, code: int) -> "FORM_FACTOR":
-        if code and not isinstance(code, int):
-            raise ValueError(f"Invalid form factor code: {code}")
-        code &= 0xF
-        return cls(code) if code in cls.__members__.values() else cls.UNKNOWN
-
-
-@unique
-class DEVICE_FLAG(IntFlag):
-    """Configuration flags."""
-
-    REMOTE_WAKEUP = 0x40
-    EJECT = 0x80
-
-
-TAG_USB_SUPPORTED = 0x01
-TAG_SERIAL = 0x02
-TAG_USB_ENABLED = 0x03
-TAG_FORM_FACTOR = 0x04
-TAG_VERSION = 0x05
-TAG_AUTO_EJECT_TIMEOUT = 0x06
-TAG_CHALRESP_TIMEOUT = 0x07
-TAG_DEVICE_FLAGS = 0x08
-TAG_APP_VERSIONS = 0x09
-TAG_CONFIG_LOCK = 0x0A
-TAG_UNLOCK = 0x0B
-TAG_REBOOT = 0x0C
-TAG_NFC_SUPPORTED = 0x0D
-TAG_NFC_ENABLED = 0x0E
-
-
-@dataclass
-class DeviceConfig:
-    """Management settings for YubiKey which can be configured by the user."""
-
-    enabled_capabilities: Mapping[TRANSPORT, CAPABILITY]
-    auto_eject_timeout: Optional[int]
-    challenge_response_timeout: Optional[int]
-    device_flags: Optional[DEVICE_FLAG]
-
-    def get_bytes(
-        self,
-        reboot: bool,
-        cur_lock_code: Optional[bytes] = None,
-        new_lock_code: Optional[bytes] = None,
-    ) -> bytes:
-        buf = b""
-        if reboot:
-            buf += Tlv(TAG_REBOOT)
-        if cur_lock_code:
-            buf += Tlv(TAG_UNLOCK, cur_lock_code)
-        usb_enabled = self.enabled_capabilities.get(TRANSPORT.USB)
-        if usb_enabled is not None:
-            buf += Tlv(TAG_USB_ENABLED, int2bytes(usb_enabled, 2))
-        nfc_enabled = self.enabled_capabilities.get(TRANSPORT.NFC)
-        if nfc_enabled is not None:
-            buf += Tlv(TAG_NFC_ENABLED, int2bytes(nfc_enabled, 2))
-        if self.auto_eject_timeout is not None:
-            buf += Tlv(TAG_AUTO_EJECT_TIMEOUT, int2bytes(self.auto_eject_timeout, 2))
-        if self.challenge_response_timeout is not None:
-            buf += Tlv(TAG_CHALRESP_TIMEOUT, int2bytes(self.challenge_response_timeout))
-        if self.device_flags is not None:
-            buf += Tlv(TAG_DEVICE_FLAGS, int2bytes(self.device_flags))
-        if new_lock_code:
-            buf += Tlv(TAG_CONFIG_LOCK, new_lock_code)
-        if len(buf) > 0xFF:
-            raise NotSupportedError("DeviceConfiguration too large")
-        return int2bytes(len(buf)) + buf
-
-
-@dataclass
-class DeviceInfo:
-    """Information about a YubiKey readable using the ManagementSession."""
-
-    config: DeviceConfig
-    serial: Optional[int]
-    version: Version
-    form_factor: FORM_FACTOR
-    supported_capabilities: Mapping[TRANSPORT, CAPABILITY]
-    is_locked: bool
-    is_fips: bool = False
-    is_sky: bool = False
-
-    def has_transport(self, transport: TRANSPORT) -> bool:
-        return transport in self.supported_capabilities
-
-    @classmethod
-    def parse(cls, encoded: bytes, default_version: Version) -> "DeviceInfo":
-        if len(encoded) - 1 != encoded[0]:
-            raise BadResponseError("Invalid length")
-        data = Tlv.parse_dict(encoded[1:])
-        locked = data.get(TAG_CONFIG_LOCK) == b"\1"
-        serial = bytes2int(data.get(TAG_SERIAL, b"\0")) or None
-        ff_value = bytes2int(data.get(TAG_FORM_FACTOR, b"\0"))
-        form_factor = FORM_FACTOR.from_code(ff_value)
-        fips = bool(ff_value & 0x80)
-        sky = bool(ff_value & 0x40)
-        if TAG_VERSION in data:
-            version = Version.from_bytes(data[TAG_VERSION])
-        else:
-            version = default_version
-        auto_eject_to = bytes2int(data.get(TAG_AUTO_EJECT_TIMEOUT, b"\0"))
-        chal_resp_to = bytes2int(data.get(TAG_CHALRESP_TIMEOUT, b"\0"))
-        flags = DEVICE_FLAG(bytes2int(data.get(TAG_DEVICE_FLAGS, b"\0")))
-
-        supported = {}
-        enabled = {}
-
-        if version == (4, 2, 4):  # Doesn't report correctly
-            supported[TRANSPORT.USB] = CAPABILITY(0x3F)
-        else:
-            supported[TRANSPORT.USB] = CAPABILITY(bytes2int(data[TAG_USB_SUPPORTED]))
-        if TAG_USB_ENABLED in data:  # From YK 5.0.0
-            if not ((4, 0, 0) <= version < (5, 0, 0)):  # Broken on YK4
-                enabled[TRANSPORT.USB] = CAPABILITY(bytes2int(data[TAG_USB_ENABLED]))
-        if TAG_NFC_SUPPORTED in data:  # YK with NFC
-            supported[TRANSPORT.NFC] = CAPABILITY(bytes2int(data[TAG_NFC_SUPPORTED]))
-            enabled[TRANSPORT.NFC] = CAPABILITY(bytes2int(data[TAG_NFC_ENABLED]))
-
-        return cls(
-            DeviceConfig(enabled, auto_eject_to, chal_resp_to, flags),
-            serial,
-            version,
-            form_factor,
-            supported,
-            locked,
-            fips,
-            sky,
-        )
-
-
-_MODES = [
-    USB_INTERFACE.OTP,  # 0x00
-    USB_INTERFACE.CCID,  # 0x01
-    USB_INTERFACE.OTP | USB_INTERFACE.CCID,  # 0x02
-    USB_INTERFACE.FIDO,  # 0x03
-    USB_INTERFACE.OTP | USB_INTERFACE.FIDO,  # 0x04
-    USB_INTERFACE.FIDO | USB_INTERFACE.CCID,  # 0x05
-    USB_INTERFACE.OTP | USB_INTERFACE.FIDO | USB_INTERFACE.CCID,  # 0x06
-]
-
-
-@dataclass(init=False, repr=False)
-class Mode:
-    """YubiKey USB Mode configuration for use with YubiKey NEO and 4."""
-
-    code: int
-    interfaces: USB_INTERFACE
-
-    def __init__(self, interfaces: USB_INTERFACE):
-        try:
-            self.code = _MODES.index(interfaces)
-            self.interfaces = USB_INTERFACE(interfaces)
-        except ValueError:
-            raise ValueError("Invalid mode!")
-
-    def __repr__(self):
-        return "+".join(t.name or str(t) for t in USB_INTERFACE if t in self.interfaces)
-
-    @classmethod
-    def from_code(cls, code: int) -> "Mode":
-        # Mode is determined from the lowest 3 bits
-        try:
-            return cls(_MODES[code & 0b00000111])
-        except IndexError:
-            raise ValueError("Invalid mode code")
-
-
-SLOT_DEVICE_CONFIG = 0x11
-SLOT_YK4_CAPABILITIES = 0x13
-SLOT_YK4_SET_DEVICE_INFO = 0x15
-
-
-class _Backend(abc.ABC):
-    version: Version
-
-    @abc.abstractmethod
-    def close(self) -> None:
-        ...
-
-    @abc.abstractmethod
-    def set_mode(self, data: bytes) -> None:
-        ...
-
-    @abc.abstractmethod
-    def read_config(self) -> bytes:
-        ...
-
-    @abc.abstractmethod
-    def write_config(self, config: bytes) -> None:
-        ...
-
-
-class _ManagementOtpBackend(_Backend):
-    def __init__(self, otp_connection):
-        self.protocol = OtpProtocol(otp_connection)
-        self.version = self.protocol.version
-        if (1, 0, 0) <= self.version < (3, 0, 0):
-            raise ApplicationNotAvailableError()
-
-    def close(self):
-        self.protocol.close()
-
-    def set_mode(self, data):
-        empty = self.protocol.read_status()[STATUS_OFFSET_PROG_SEQ] == 0
-        try:
-            self.protocol.send_and_receive(SLOT_DEVICE_CONFIG, data)
-        except CommandRejectedError:
-            if empty:
-                return  # ProgSeq isn't updated by set mode when empty
-            raise
-
-    def read_config(self):
-        response = self.protocol.send_and_receive(SLOT_YK4_CAPABILITIES)
-        r_len = response[0]
-        if check_crc(response[: r_len + 1 + 2]):
-            return response[: r_len + 1]
-        raise BadResponseError("Invalid checksum")
-
-    def write_config(self, config):
-        self.protocol.send_and_receive(SLOT_YK4_SET_DEVICE_INFO, config)
-
-
-INS_READ_CONFIG = 0x1D
-INS_WRITE_CONFIG = 0x1C
-INS_SET_MODE = 0x16
-P1_DEVICE_CONFIG = 0x11
-
-
-class _ManagementSmartCardBackend(_Backend):
-    def __init__(self, smartcard_connection):
-        self.protocol = SmartCardProtocol(smartcard_connection)
-        try:
-            select_bytes = self.protocol.select(AID.MANAGEMENT)
-            if select_bytes[-2:] == b"\x90\x00":
-                # YubiKey Edge incorrectly appends SW twice.
-                select_bytes = select_bytes[:-2]
-            select_str = select_bytes.decode()
-            self.version = Version.from_string(select_str)
-            # For YubiKey NEO, we use the OTP application for further commands
-            if self.version[0] == 3:
-                # Workaround to "de-select" on NEO, otherwise it gets stuck.
-                self.protocol.connection.send_and_receive(b"\xa4\x04\x00\x08")
-                self.protocol.select(AID.OTP)
-        except ApplicationNotAvailableError:
-            if smartcard_connection.transport == TRANSPORT.NFC:
-                # Probably NEO over NFC
-                status = self.protocol.select(AID.OTP)
-                self.version = Version.from_bytes(status[:3])
-            else:
-                raise
-
-    def close(self):
-        self.protocol.close()
-
-    def set_mode(self, data):
-        if self.version[0] == 3:  # Using the OTP application
-            self.protocol.send_apdu(0, 0x01, SLOT_DEVICE_CONFIG, 0, data)
-        else:
-            self.protocol.send_apdu(0, INS_SET_MODE, P1_DEVICE_CONFIG, 0, data)
-
-    def read_config(self):
-        return self.protocol.send_apdu(0, INS_READ_CONFIG, 0, 0)
-
-    def write_config(self, config):
-        self.protocol.send_apdu(0, INS_WRITE_CONFIG, 0, 0, config)
-
-
-CTAP_VENDOR_FIRST = 0x40
-CTAP_YUBIKEY_DEVICE_CONFIG = CTAP_VENDOR_FIRST
-CTAP_READ_CONFIG = CTAP_VENDOR_FIRST + 2
-CTAP_WRITE_CONFIG = CTAP_VENDOR_FIRST + 3
-
-
-class _ManagementCtapBackend(_Backend):
-    def __init__(self, fido_connection):
-        self.ctap = fido_connection
-        version = fido_connection.device_version
-        if version[0] < 4:  # Prior to YK4 this was not firmware version
-            if not (
-                version[0] == 0 and fido_connection.capabilities & CTAP_CAPABILITY.CBOR
-            ):
-                version = (3, 0, 0)  # Guess that it's a NEO
-        self.version = Version(*version)
-
-    def close(self):
-        self.ctap.close()
-
-    def set_mode(self, data):
-        self.ctap.call(CTAP_YUBIKEY_DEVICE_CONFIG, data)
-
-    def read_config(self):
-        return self.ctap.call(CTAP_READ_CONFIG)
-
-    def write_config(self, config):
-        self.ctap.call(CTAP_WRITE_CONFIG, config)
-
-
-class ManagementSession:
-    def __init__(
-        self, connection: Union[OtpConnection, SmartCardConnection, FidoConnection]
-    ):
-        if isinstance(connection, OtpConnection):
-            self.backend: _Backend = _ManagementOtpBackend(connection)
-        elif isinstance(connection, SmartCardConnection):
-            self.backend = _ManagementSmartCardBackend(connection)
-        elif isinstance(connection, FidoConnection):
-            self.backend = _ManagementCtapBackend(connection)
-        else:
-            raise TypeError("Unsupported connection type")
-        logger.debug(
-            "Management session initialized for "
-            f"connection={type(connection).__name__}, version={self.version}"
-        )
-
-    def close(self) -> None:
-        self.backend.close()
-
-    @property
-    def version(self) -> Version:
-        return self.backend.version
-
-    def read_device_info(self) -> DeviceInfo:
-        require_version(self.version, (4, 1, 0))
-        return DeviceInfo.parse(self.backend.read_config(), self.version)
-
-    def write_device_config(
-        self,
-        config: Optional[DeviceConfig] = None,
-        reboot: bool = False,
-        cur_lock_code: Optional[bytes] = None,
-        new_lock_code: Optional[bytes] = None,
-    ) -> None:
-        require_version(self.version, (5, 0, 0))
-        if cur_lock_code is not None and len(cur_lock_code) != 16:
-            raise ValueError("Lock code must be 16 bytes")
-        if new_lock_code is not None and len(new_lock_code) != 16:
-            raise ValueError("Lock code must be 16 bytes")
-        config = config or DeviceConfig({}, None, None, None)
-        logger.debug(
-            f"Writing device config: {config}, reboot: {reboot}, "
-            f"current lock code: {cur_lock_code is not None}, "
-            f"new lock code: {new_lock_code is not None}"
-        )
-        self.backend.write_config(
-            config.get_bytes(reboot, cur_lock_code, new_lock_code)
-        )
-        logger.info("Device config written")
-
-    def set_mode(
-        self,
-        mode: Mode,
-        chalresp_timeout: int = 0,
-        auto_eject_timeout: Optional[int] = None,
-    ) -> None:
-        logger.debug(
-            f"Set mode: {mode}, chalresp_timeout: {chalresp_timeout}, "
-            f"auto_eject_timeout: {auto_eject_timeout}"
-        )
-        if self.version >= (5, 0, 0):
-            # Translate into DeviceConfig
-            usb_enabled = CAPABILITY(0)
-            if USB_INTERFACE.OTP in mode.interfaces:
-                usb_enabled |= CAPABILITY.OTP
-            if USB_INTERFACE.CCID in mode.interfaces:
-                usb_enabled |= CAPABILITY.OATH | CAPABILITY.PIV | CAPABILITY.OPENPGP
-            if USB_INTERFACE.FIDO in mode.interfaces:
-                usb_enabled |= CAPABILITY.U2F | CAPABILITY.FIDO2
-            logger.debug(f"Delegating to DeviceConfig with usb_enabled: {usb_enabled}")
-            # N.B: reboot=False, since we're using the older set_mode command
-            self.write_device_config(
-                DeviceConfig(
-                    {TRANSPORT.USB: usb_enabled},
-                    auto_eject_timeout,
-                    chalresp_timeout,
-                    None,
-                )
-            )
-        else:
-            code = mode.code
-            if auto_eject_timeout is not None:
-                if mode.interfaces == USB_INTERFACE.CCID:
-                    code |= DEVICE_FLAG.EJECT
-                else:
-                    raise ValueError("Touch-eject only applicable for mode: CCID")
-            self.backend.set_mode(
-                # N.B. This is little endian!
-                struct.pack("<BBH", code, chalresp_timeout, auto_eject_timeout or 0)
-            )
-            logger.info("Mode configuration written")
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from .core import (
+    bytes2int,
+    int2bytes,
+    require_version,
+    Version,
+    Tlv,
+    TRANSPORT,
+    USB_INTERFACE,
+    NotSupportedError,
+    BadResponseError,
+    ApplicationNotAvailableError,
+)
+from .core.otp import (
+    check_crc,
+    OtpConnection,
+    OtpProtocol,
+    STATUS_OFFSET_PROG_SEQ,
+    CommandRejectedError,
+)
+from .core.fido import FidoConnection
+from .core.smartcard import AID, SmartCardConnection, SmartCardProtocol
+from fido2.hid import CAPABILITY as CTAP_CAPABILITY
+
+from enum import IntEnum, IntFlag, unique
+from dataclasses import dataclass
+from typing import Optional, Union, Mapping
+import abc
+import struct
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+@unique
+class CAPABILITY(IntFlag):
+    """YubiKey Application identifiers."""
+
+    OTP = 0x01
+    U2F = 0x02
+    FIDO2 = 0x200
+    OATH = 0x20
+    PIV = 0x10
+    OPENPGP = 0x08
+    HSMAUTH = 0x100
+
+    def __str__(self):
+        name = "|".join(c.name or str(c) for c in CAPABILITY if c in self)
+        return f"{name}: {hex(self)}"
+
+    @property
+    def display_name(self):
+        if self == CAPABILITY.U2F:
+            return "FIDO U2F"
+        elif self == CAPABILITY.OPENPGP:
+            return "OpenPGP"
+        elif self == CAPABILITY.HSMAUTH:
+            return "YubiHSM Auth"
+        return self.name or ", ".join(c.display_name for c in CAPABILITY if c in self)
+
+    @property
+    def usb_interfaces(self) -> USB_INTERFACE:
+        ifaces = USB_INTERFACE(0)
+        if self & CAPABILITY.OTP:
+            ifaces |= USB_INTERFACE.OTP
+        if self & (CAPABILITY.U2F | CAPABILITY.FIDO2):
+            ifaces |= USB_INTERFACE.FIDO
+        if self & (
+            CAPABILITY.OATH | CAPABILITY.PIV | CAPABILITY.OPENPGP | CAPABILITY.HSMAUTH
+        ):
+            ifaces |= USB_INTERFACE.CCID
+        return ifaces
+
+
+@unique
+class FORM_FACTOR(IntEnum):
+    """YubiKey device form factors."""
+
+    UNKNOWN = 0x00
+    USB_A_KEYCHAIN = 0x01
+    USB_A_NANO = 0x02
+    USB_C_KEYCHAIN = 0x03
+    USB_C_NANO = 0x04
+    USB_C_LIGHTNING = 0x05
+    USB_A_BIO = 0x06
+    USB_C_BIO = 0x07
+
+    def __str__(self):
+        if self == FORM_FACTOR.USB_A_KEYCHAIN:
+            return "Keychain (USB-A)"
+        elif self == FORM_FACTOR.USB_A_NANO:
+            return "Nano (USB-A)"
+        elif self == FORM_FACTOR.USB_C_KEYCHAIN:
+            return "Keychain (USB-C)"
+        elif self == FORM_FACTOR.USB_C_NANO:
+            return "Nano (USB-C)"
+        elif self == FORM_FACTOR.USB_C_LIGHTNING:
+            return "Keychain (USB-C, Lightning)"
+        elif self == FORM_FACTOR.USB_A_BIO:
+            return "Bio (USB-A)"
+        elif self == FORM_FACTOR.USB_C_BIO:
+            return "Bio (USB-C)"
+        else:
+            return "Unknown"
+
+    @classmethod
+    def from_code(cls, code: int) -> "FORM_FACTOR":
+        if code and not isinstance(code, int):
+            raise ValueError(f"Invalid form factor code: {code}")
+        code &= 0xF
+        return cls(code) if code in cls.__members__.values() else cls.UNKNOWN
+
+
+@unique
+class DEVICE_FLAG(IntFlag):
+    """Configuration flags."""
+
+    REMOTE_WAKEUP = 0x40
+    EJECT = 0x80
+
+
+TAG_USB_SUPPORTED = 0x01
+TAG_SERIAL = 0x02
+TAG_USB_ENABLED = 0x03
+TAG_FORM_FACTOR = 0x04
+TAG_VERSION = 0x05
+TAG_AUTO_EJECT_TIMEOUT = 0x06
+TAG_CHALRESP_TIMEOUT = 0x07
+TAG_DEVICE_FLAGS = 0x08
+TAG_APP_VERSIONS = 0x09
+TAG_CONFIG_LOCK = 0x0A
+TAG_UNLOCK = 0x0B
+TAG_REBOOT = 0x0C
+TAG_NFC_SUPPORTED = 0x0D
+TAG_NFC_ENABLED = 0x0E
+
+
+@dataclass
+class DeviceConfig:
+    """Management settings for YubiKey which can be configured by the user."""
+
+    enabled_capabilities: Mapping[TRANSPORT, CAPABILITY]
+    auto_eject_timeout: Optional[int]
+    challenge_response_timeout: Optional[int]
+    device_flags: Optional[DEVICE_FLAG]
+
+    def get_bytes(
+        self,
+        reboot: bool,
+        cur_lock_code: Optional[bytes] = None,
+        new_lock_code: Optional[bytes] = None,
+    ) -> bytes:
+        buf = b""
+        if reboot:
+            buf += Tlv(TAG_REBOOT)
+        if cur_lock_code:
+            buf += Tlv(TAG_UNLOCK, cur_lock_code)
+        usb_enabled = self.enabled_capabilities.get(TRANSPORT.USB)
+        if usb_enabled is not None:
+            buf += Tlv(TAG_USB_ENABLED, int2bytes(usb_enabled, 2))
+        nfc_enabled = self.enabled_capabilities.get(TRANSPORT.NFC)
+        if nfc_enabled is not None:
+            buf += Tlv(TAG_NFC_ENABLED, int2bytes(nfc_enabled, 2))
+        if self.auto_eject_timeout is not None:
+            buf += Tlv(TAG_AUTO_EJECT_TIMEOUT, int2bytes(self.auto_eject_timeout, 2))
+        if self.challenge_response_timeout is not None:
+            buf += Tlv(TAG_CHALRESP_TIMEOUT, int2bytes(self.challenge_response_timeout))
+        if self.device_flags is not None:
+            buf += Tlv(TAG_DEVICE_FLAGS, int2bytes(self.device_flags))
+        if new_lock_code:
+            buf += Tlv(TAG_CONFIG_LOCK, new_lock_code)
+        if len(buf) > 0xFF:
+            raise NotSupportedError("DeviceConfiguration too large")
+        return int2bytes(len(buf)) + buf
+
+
+@dataclass
+class DeviceInfo:
+    """Information about a YubiKey readable using the ManagementSession."""
+
+    config: DeviceConfig
+    serial: Optional[int]
+    version: Version
+    form_factor: FORM_FACTOR
+    supported_capabilities: Mapping[TRANSPORT, CAPABILITY]
+    is_locked: bool
+    is_fips: bool = False
+    is_sky: bool = False
+
+    def has_transport(self, transport: TRANSPORT) -> bool:
+        return transport in self.supported_capabilities
+
+    @classmethod
+    def parse(cls, encoded: bytes, default_version: Version) -> "DeviceInfo":
+        if len(encoded) - 1 != encoded[0]:
+            raise BadResponseError("Invalid length")
+        data = Tlv.parse_dict(encoded[1:])
+        locked = data.get(TAG_CONFIG_LOCK) == b"\1"
+        serial = bytes2int(data.get(TAG_SERIAL, b"\0")) or None
+        ff_value = bytes2int(data.get(TAG_FORM_FACTOR, b"\0"))
+        form_factor = FORM_FACTOR.from_code(ff_value)
+        fips = bool(ff_value & 0x80)
+        sky = bool(ff_value & 0x40)
+        if TAG_VERSION in data:
+            version = Version.from_bytes(data[TAG_VERSION])
+        else:
+            version = default_version
+        auto_eject_to = bytes2int(data.get(TAG_AUTO_EJECT_TIMEOUT, b"\0"))
+        chal_resp_to = bytes2int(data.get(TAG_CHALRESP_TIMEOUT, b"\0"))
+        flags = DEVICE_FLAG(bytes2int(data.get(TAG_DEVICE_FLAGS, b"\0")))
+
+        supported = {}
+        enabled = {}
+
+        if version == (4, 2, 4):  # Doesn't report correctly
+            supported[TRANSPORT.USB] = CAPABILITY(0x3F)
+        else:
+            supported[TRANSPORT.USB] = CAPABILITY(bytes2int(data[TAG_USB_SUPPORTED]))
+        if TAG_USB_ENABLED in data:  # From YK 5.0.0
+            if not ((4, 0, 0) <= version < (5, 0, 0)):  # Broken on YK4
+                enabled[TRANSPORT.USB] = CAPABILITY(bytes2int(data[TAG_USB_ENABLED]))
+        if TAG_NFC_SUPPORTED in data:  # YK with NFC
+            supported[TRANSPORT.NFC] = CAPABILITY(bytes2int(data[TAG_NFC_SUPPORTED]))
+            enabled[TRANSPORT.NFC] = CAPABILITY(bytes2int(data[TAG_NFC_ENABLED]))
+
+        return cls(
+            DeviceConfig(enabled, auto_eject_to, chal_resp_to, flags),
+            serial,
+            version,
+            form_factor,
+            supported,
+            locked,
+            fips,
+            sky,
+        )
+
+
+_MODES = [
+    USB_INTERFACE.OTP,  # 0x00
+    USB_INTERFACE.CCID,  # 0x01
+    USB_INTERFACE.OTP | USB_INTERFACE.CCID,  # 0x02
+    USB_INTERFACE.FIDO,  # 0x03
+    USB_INTERFACE.OTP | USB_INTERFACE.FIDO,  # 0x04
+    USB_INTERFACE.FIDO | USB_INTERFACE.CCID,  # 0x05
+    USB_INTERFACE.OTP | USB_INTERFACE.FIDO | USB_INTERFACE.CCID,  # 0x06
+]
+
+
+@dataclass(init=False, repr=False)
+class Mode:
+    """YubiKey USB Mode configuration for use with YubiKey NEO and 4."""
+
+    code: int
+    interfaces: USB_INTERFACE
+
+    def __init__(self, interfaces: USB_INTERFACE):
+        try:
+            self.code = _MODES.index(interfaces)
+            self.interfaces = USB_INTERFACE(interfaces)
+        except ValueError:
+            raise ValueError("Invalid mode!")
+
+    def __repr__(self):
+        return "+".join(t.name or str(t) for t in USB_INTERFACE if t in self.interfaces)
+
+    @classmethod
+    def from_code(cls, code: int) -> "Mode":
+        # Mode is determined from the lowest 3 bits
+        try:
+            return cls(_MODES[code & 0b00000111])
+        except IndexError:
+            raise ValueError("Invalid mode code")
+
+
+SLOT_DEVICE_CONFIG = 0x11
+SLOT_YK4_CAPABILITIES = 0x13
+SLOT_YK4_SET_DEVICE_INFO = 0x15
+
+
+class _Backend(abc.ABC):
+    version: Version
+
+    @abc.abstractmethod
+    def close(self) -> None:
+        ...
+
+    @abc.abstractmethod
+    def set_mode(self, data: bytes) -> None:
+        ...
+
+    @abc.abstractmethod
+    def read_config(self) -> bytes:
+        ...
+
+    @abc.abstractmethod
+    def write_config(self, config: bytes) -> None:
+        ...
+
+
+class _ManagementOtpBackend(_Backend):
+    def __init__(self, otp_connection):
+        self.protocol = OtpProtocol(otp_connection)
+        self.version = self.protocol.version
+        if (1, 0, 0) <= self.version < (3, 0, 0):
+            raise ApplicationNotAvailableError()
+
+    def close(self):
+        self.protocol.close()
+
+    def set_mode(self, data):
+        empty = self.protocol.read_status()[STATUS_OFFSET_PROG_SEQ] == 0
+        try:
+            self.protocol.send_and_receive(SLOT_DEVICE_CONFIG, data)
+        except CommandRejectedError:
+            if empty:
+                return  # ProgSeq isn't updated by set mode when empty
+            raise
+
+    def read_config(self):
+        response = self.protocol.send_and_receive(SLOT_YK4_CAPABILITIES)
+        r_len = response[0]
+        if check_crc(response[: r_len + 1 + 2]):
+            return response[: r_len + 1]
+        raise BadResponseError("Invalid checksum")
+
+    def write_config(self, config):
+        self.protocol.send_and_receive(SLOT_YK4_SET_DEVICE_INFO, config)
+
+
+INS_READ_CONFIG = 0x1D
+INS_WRITE_CONFIG = 0x1C
+INS_SET_MODE = 0x16
+P1_DEVICE_CONFIG = 0x11
+
+
+class _ManagementSmartCardBackend(_Backend):
+    def __init__(self, smartcard_connection):
+        self.protocol = SmartCardProtocol(smartcard_connection)
+        try:
+            select_bytes = self.protocol.select(AID.MANAGEMENT)
+            if select_bytes[-2:] == b"\x90\x00":
+                # YubiKey Edge incorrectly appends SW twice.
+                select_bytes = select_bytes[:-2]
+            select_str = select_bytes.decode()
+            self.version = Version.from_string(select_str)
+            # For YubiKey NEO, we use the OTP application for further commands
+            if self.version[0] == 3:
+                # Workaround to "de-select" on NEO, otherwise it gets stuck.
+                self.protocol.connection.send_and_receive(b"\xa4\x04\x00\x08")
+                self.protocol.select(AID.OTP)
+        except ApplicationNotAvailableError:
+            if smartcard_connection.transport == TRANSPORT.NFC:
+                # Probably NEO over NFC
+                status = self.protocol.select(AID.OTP)
+                self.version = Version.from_bytes(status[:3])
+            else:
+                raise
+
+    def close(self):
+        self.protocol.close()
+
+    def set_mode(self, data):
+        if self.version[0] == 3:  # Using the OTP application
+            self.protocol.send_apdu(0, 0x01, SLOT_DEVICE_CONFIG, 0, data)
+        else:
+            self.protocol.send_apdu(0, INS_SET_MODE, P1_DEVICE_CONFIG, 0, data)
+
+    def read_config(self):
+        return self.protocol.send_apdu(0, INS_READ_CONFIG, 0, 0)
+
+    def write_config(self, config):
+        self.protocol.send_apdu(0, INS_WRITE_CONFIG, 0, 0, config)
+
+
+CTAP_VENDOR_FIRST = 0x40
+CTAP_YUBIKEY_DEVICE_CONFIG = CTAP_VENDOR_FIRST
+CTAP_READ_CONFIG = CTAP_VENDOR_FIRST + 2
+CTAP_WRITE_CONFIG = CTAP_VENDOR_FIRST + 3
+
+
+class _ManagementCtapBackend(_Backend):
+    def __init__(self, fido_connection):
+        self.ctap = fido_connection
+        version = fido_connection.device_version
+        if version[0] < 4:  # Prior to YK4 this was not firmware version
+            if not (
+                version[0] == 0 and fido_connection.capabilities & CTAP_CAPABILITY.CBOR
+            ):
+                version = (3, 0, 0)  # Guess that it's a NEO
+        self.version = Version(*version)
+
+    def close(self):
+        self.ctap.close()
+
+    def set_mode(self, data):
+        self.ctap.call(CTAP_YUBIKEY_DEVICE_CONFIG, data)
+
+    def read_config(self):
+        return self.ctap.call(CTAP_READ_CONFIG)
+
+    def write_config(self, config):
+        self.ctap.call(CTAP_WRITE_CONFIG, config)
+
+
+class ManagementSession:
+    def __init__(
+        self, connection: Union[OtpConnection, SmartCardConnection, FidoConnection]
+    ):
+        if isinstance(connection, OtpConnection):
+            self.backend: _Backend = _ManagementOtpBackend(connection)
+        elif isinstance(connection, SmartCardConnection):
+            self.backend = _ManagementSmartCardBackend(connection)
+        elif isinstance(connection, FidoConnection):
+            self.backend = _ManagementCtapBackend(connection)
+        else:
+            raise TypeError("Unsupported connection type")
+        logger.debug(
+            "Management session initialized for "
+            f"connection={type(connection).__name__}, version={self.version}"
+        )
+
+    def close(self) -> None:
+        self.backend.close()
+
+    @property
+    def version(self) -> Version:
+        return self.backend.version
+
+    def read_device_info(self) -> DeviceInfo:
+        require_version(self.version, (4, 1, 0))
+        return DeviceInfo.parse(self.backend.read_config(), self.version)
+
+    def write_device_config(
+        self,
+        config: Optional[DeviceConfig] = None,
+        reboot: bool = False,
+        cur_lock_code: Optional[bytes] = None,
+        new_lock_code: Optional[bytes] = None,
+    ) -> None:
+        require_version(self.version, (5, 0, 0))
+        if cur_lock_code is not None and len(cur_lock_code) != 16:
+            raise ValueError("Lock code must be 16 bytes")
+        if new_lock_code is not None and len(new_lock_code) != 16:
+            raise ValueError("Lock code must be 16 bytes")
+        config = config or DeviceConfig({}, None, None, None)
+        logger.debug(
+            f"Writing device config: {config}, reboot: {reboot}, "
+            f"current lock code: {cur_lock_code is not None}, "
+            f"new lock code: {new_lock_code is not None}"
+        )
+        self.backend.write_config(
+            config.get_bytes(reboot, cur_lock_code, new_lock_code)
+        )
+        logger.info("Device config written")
+
+    def set_mode(
+        self,
+        mode: Mode,
+        chalresp_timeout: int = 0,
+        auto_eject_timeout: Optional[int] = None,
+    ) -> None:
+        logger.debug(
+            f"Set mode: {mode}, chalresp_timeout: {chalresp_timeout}, "
+            f"auto_eject_timeout: {auto_eject_timeout}"
+        )
+        if self.version >= (5, 0, 0):
+            # Translate into DeviceConfig
+            usb_enabled = CAPABILITY(0)
+            if USB_INTERFACE.OTP in mode.interfaces:
+                usb_enabled |= CAPABILITY.OTP
+            if USB_INTERFACE.CCID in mode.interfaces:
+                usb_enabled |= CAPABILITY.OATH | CAPABILITY.PIV | CAPABILITY.OPENPGP
+            if USB_INTERFACE.FIDO in mode.interfaces:
+                usb_enabled |= CAPABILITY.U2F | CAPABILITY.FIDO2
+            logger.debug(f"Delegating to DeviceConfig with usb_enabled: {usb_enabled}")
+            # N.B: reboot=False, since we're using the older set_mode command
+            self.write_device_config(
+                DeviceConfig(
+                    {TRANSPORT.USB: usb_enabled},
+                    auto_eject_timeout,
+                    chalresp_timeout,
+                    None,
+                )
+            )
+        else:
+            code = mode.code
+            if auto_eject_timeout is not None:
+                if mode.interfaces == USB_INTERFACE.CCID:
+                    code |= DEVICE_FLAG.EJECT
+                else:
+                    raise ValueError("Touch-eject only applicable for mode: CCID")
+            self.backend.set_mode(
+                # N.B. This is little endian!
+                struct.pack("<BBH", code, chalresp_timeout, auto_eject_timeout or 0)
+            )
+            logger.info("Mode configuration written")
```

### Comparing `yubikey_manager-5.1.0/yubikit/openpgp.py` & `yubikey_manager-5.1.1/yubikit/openpgp.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,1611 +1,1611 @@
-from .core import (
-    Tlv,
-    Version,
-    NotSupportedError,
-    require_version,
-    int2bytes,
-    bytes2int,
-)
-from .core.smartcard import (
-    SmartCardConnection,
-    SmartCardProtocol,
-    ApduFormat,
-    ApduError,
-    AID,
-    SW,
-)
-
-from cryptography import x509
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.serialization import (
-    Encoding,
-    PrivateFormat,
-    PublicFormat,
-    NoEncryption,
-)
-from cryptography.hazmat.primitives.asymmetric import rsa, ec, ed25519, x25519
-from cryptography.hazmat.primitives.asymmetric.utils import (
-    Prehashed,
-    encode_dss_signature,
-)
-
-import os
-import abc
-from enum import Enum, IntEnum, IntFlag, unique
-from dataclasses import dataclass
-from typing import (
-    Optional,
-    Tuple,
-    ClassVar,
-    Mapping,
-    Sequence,
-    SupportsBytes,
-    Union,
-    Dict,
-    List,
-)
-import struct
-import logging
-
-logger = logging.getLogger(__name__)
-
-DEFAULT_USER_PIN = "123456"
-DEFAULT_ADMIN_PIN = "12345678"
-
-
-@unique
-class UIF(IntEnum):  # noqa: N801
-    OFF = 0x00
-    ON = 0x01
-    FIXED = 0x02
-    CACHED = 0x03
-    CACHED_FIXED = 0x04
-
-    @classmethod
-    def parse(cls, encoded: bytes):
-        return cls(encoded[0])
-
-    def __bytes__(self) -> bytes:
-        return struct.pack(">BB", self, GENERAL_FEATURE_MANAGEMENT.BUTTON)
-
-    @property
-    def is_fixed(self) -> bool:
-        return self in (UIF.FIXED, UIF.CACHED_FIXED)
-
-    @property
-    def is_cached(self) -> bool:
-        return self in (UIF.CACHED, UIF.CACHED_FIXED)
-
-    def __str__(self):
-        if self == UIF.FIXED:
-            return "On (fixed)"
-        if self == UIF.CACHED_FIXED:
-            return "Cached (fixed)"
-        return self.name[0] + self.name[1:].lower()
-
-
-@unique
-class PIN_POLICY(IntEnum):  # noqa: N801
-    ALWAYS = 0x00
-    ONCE = 0x01
-
-    def __str__(self):
-        return self.name[0] + self.name[1:].lower()
-
-
-@unique
-class INS(IntEnum):  # noqa: N801
-    VERIFY = 0x20
-    CHANGE_PIN = 0x24
-    RESET_RETRY_COUNTER = 0x2C
-    PSO = 0x2A
-    ACTIVATE = 0x44
-    GENERATE_ASYM = 0x47
-    GET_CHALLENGE = 0x84
-    INTERNAL_AUTHENTICATE = 0x88
-    SELECT_DATA = 0xA5
-    GET_DATA = 0xCA
-    PUT_DATA = 0xDA
-    PUT_DATA_ODD = 0xDB
-    TERMINATE = 0xE6
-    GET_VERSION = 0xF1
-    SET_PIN_RETRIES = 0xF2
-    GET_ATTESTATION = 0xFB
-
-
-_INVALID_PIN = b"\0" * 8
-
-
-TAG_DISCRETIONARY = 0x73
-TAG_EXTENDED_CAPABILITIES = 0xC0
-TAG_FINGERPRINTS = 0xC5
-TAG_CA_FINGERPRINTS = 0xC6
-TAG_GENERATION_TIMES = 0xCD
-TAG_SIGNATURE_COUNTER = 0x93
-TAG_KEY_INFORMATION = 0xDE
-TAG_PUBLIC_KEY = 0x7F49
-
-
-@unique
-class PW(IntEnum):
-    USER = 0x81
-    RESET = 0x82
-    ADMIN = 0x83
-
-
-@unique
-class DO(IntEnum):
-    PRIVATE_USE_1 = 0x0101
-    PRIVATE_USE_2 = 0x0102
-    PRIVATE_USE_3 = 0x0103
-    PRIVATE_USE_4 = 0x0104
-    AID = 0x4F
-    NAME = 0x5B
-    LOGIN_DATA = 0x5E
-    LANGUAGE = 0xEF2D
-    SEX = 0x5F35
-    URL = 0x5F50
-    HISTORICAL_BYTES = 0x5F52
-    EXTENDED_LENGTH_INFO = 0x7F66
-    GENERAL_FEATURE_MANAGEMENT = 0x7F74
-    CARDHOLDER_RELATED_DATA = 0x65
-    APPLICATION_RELATED_DATA = 0x6E
-    ALGORITHM_ATTRIBUTES_SIG = 0xC1
-    ALGORITHM_ATTRIBUTES_DEC = 0xC2
-    ALGORITHM_ATTRIBUTES_AUT = 0xC3
-    ALGORITHM_ATTRIBUTES_ATT = 0xDA
-    PW_STATUS_BYTES = 0xC4
-    FINGERPRINT_SIG = 0xC7
-    FINGERPRINT_DEC = 0xC8
-    FINGERPRINT_AUT = 0xC9
-    FINGERPRINT_ATT = 0xDB
-    CA_FINGERPRINT_1 = 0xCA
-    CA_FINGERPRINT_2 = 0xCB
-    CA_FINGERPRINT_3 = 0xCC
-    CA_FINGERPRINT_4 = 0xDC
-    GENERATION_TIME_SIG = 0xCE
-    GENERATION_TIME_DEC = 0xCF
-    GENERATION_TIME_AUT = 0xD0
-    GENERATION_TIME_ATT = 0xDD
-    RESETTING_CODE = 0xD3
-    UIF_SIG = 0xD6
-    UIF_DEC = 0xD7
-    UIF_AUT = 0xD8
-    UIF_ATT = 0xD9
-    SECURITY_SUPPORT_TEMPLATE = 0x7A
-    CARDHOLDER_CERTIFICATE = 0x7F21
-    KDF = 0xF9
-    ALGORITHM_INFORMATION = 0xFA
-    ATT_CERTIFICATE = 0xFC
-
-
-def _bcd(value: int) -> int:
-    return 10 * (value >> 4) + (value & 0xF)
-
-
-class OpenPgpAid(bytes):
-    """OpenPGP Application Identifier (AID)
-
-    The OpenPGP AID is a string of bytes identifying the OpenPGP application.
-    It also embeds some values which are accessible though properties.
-    """
-
-    @property
-    def version(self) -> Tuple[int, int]:
-        """OpenPGP version (tuple of 2 integers: main version, seconday version)."""
-        return (_bcd(self[6]), _bcd(self[7]))
-
-    @property
-    def manufacturer(self) -> int:
-        """16-bit integer value identifying the manufacturer of the device.
-
-        This should be 6 for Yubico devices.
-        """
-        return bytes2int(self[8:10])
-
-    @property
-    def serial(self) -> int:
-        """The serial number of the YubiKey.
-
-        NOTE: This value is encoded in BCD. In the event of an invalid value (hex A-F)
-        the entire 4 byte value will instead be decoded as an unsigned integer,
-        and negated.
-        """
-        try:
-            return int(self[10:14].hex())
-        except ValueError:
-            # Not valid BCD, treat as an unsigned integer, and return a negative value
-            return -struct.unpack(">I", self[10:14])[0]
-
-
-@unique
-class EXTENDED_CAPABILITY_FLAGS(IntFlag):
-    KDF = 1 << 0
-    PSO_DEC_ENC_AES = 1 << 1
-    ALGORITHM_ATTRIBUTES_CHANGEABLE = 1 << 2
-    PRIVATE_USE = 1 << 3
-    PW_STATUS_CHANGEABLE = 1 << 4
-    KEY_IMPORT = 1 << 5
-    GET_CHALLENGE = 1 << 6
-    SECURE_MESSAGING = 1 << 7
-
-
-@dataclass
-class CardholderRelatedData:
-    name: bytes
-    language: bytes
-    sex: int
-
-    @classmethod
-    def parse(cls, encoded) -> "CardholderRelatedData":
-        data = Tlv.parse_dict(Tlv.unpack(DO.CARDHOLDER_RELATED_DATA, encoded))
-        return cls(
-            data[DO.NAME],
-            data[DO.LANGUAGE],
-            data[DO.SEX][0],
-        )
-
-
-@dataclass
-class ExtendedLengthInfo:
-    request_max_bytes: int
-    response_max_bytes: int
-
-    @classmethod
-    def parse(cls, encoded) -> "ExtendedLengthInfo":
-        data = Tlv.parse_list(encoded)
-        return cls(
-            bytes2int(Tlv.unpack(0x02, data[0])),
-            bytes2int(Tlv.unpack(0x02, data[1])),
-        )
-
-
-@unique
-class GENERAL_FEATURE_MANAGEMENT(IntFlag):
-    TOUCHSCREEN = 1 << 0
-    MICROPHONE = 1 << 1
-    LOUDSPEAKER = 1 << 2
-    LED = 1 << 3
-    KEYPAD = 1 << 4
-    BUTTON = 1 << 5
-    BIOMETRIC = 1 << 6
-    DISPLAY = 1 << 7
-
-
-@dataclass
-class ExtendedCapabilities:
-    flags: EXTENDED_CAPABILITY_FLAGS
-    sm_algorithm: int
-    challenge_max_length: int
-    certificate_max_length: int
-    special_do_max_length: int
-    pin_block_2_format: bool
-    mse_command: bool
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "ExtendedCapabilities":
-        return cls(
-            EXTENDED_CAPABILITY_FLAGS(encoded[0]),
-            encoded[1],
-            bytes2int(encoded[2:4]),
-            bytes2int(encoded[4:6]),
-            bytes2int(encoded[6:8]),
-            encoded[8] == 1,
-            encoded[9] == 1,
-        )
-
-
-@dataclass
-class PwStatus:
-    pin_policy_user: PIN_POLICY
-    max_len_user: int
-    max_len_reset: int
-    max_len_admin: int
-    attempts_user: int
-    attempts_reset: int
-    attempts_admin: int
-
-    def get_max_len(self, pw: PW) -> int:
-        return getattr(self, f"max_len_{pw.name.lower()}")
-
-    def get_attempts(self, pw: PW) -> int:
-        return getattr(self, f"attempts_{pw.name.lower()}")
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "PwStatus":
-        try:
-            policy = PIN_POLICY(encoded[0])
-        except ValueError:
-            policy = PIN_POLICY.ONCE
-        return cls(
-            policy,
-            encoded[1],
-            encoded[2],
-            encoded[3],
-            encoded[4],
-            encoded[5],
-            encoded[6],
-        )
-
-
-@unique
-class CRT(bytes, Enum):
-    SIG = Tlv(0xB6)
-    DEC = Tlv(0xB8)
-    AUT = Tlv(0xA4)
-    ATT = Tlv(0xB6, Tlv(0x84, b"\x81"))
-
-
-@unique
-class KEY_REF(IntEnum):  # noqa: N801
-    SIG = 0x01
-    DEC = 0x02
-    AUT = 0x03
-    ATT = 0x81
-
-    @property
-    def algorithm_attributes_do(self) -> DO:
-        return getattr(DO, f"ALGORITHM_ATTRIBUTES_{self.name}")
-
-    @property
-    def uif_do(self) -> DO:
-        return getattr(DO, f"UIF_{self.name}")
-
-    @property
-    def generation_time_do(self) -> DO:
-        return getattr(DO, f"GENERATION_TIME_{self.name}")
-
-    @property
-    def fingerprint_do(self) -> DO:
-        return getattr(DO, f"FINGERPRINT_{self.name}")
-
-    @property
-    def crt(self) -> CRT:
-        return getattr(CRT, self.name)
-
-
-@unique
-class KEY_STATUS(IntEnum):
-    NONE = 0
-    GENERATED = 1
-    IMPORTED = 2
-
-
-KeyInformation = Mapping[KEY_REF, KEY_STATUS]
-Fingerprints = Mapping[KEY_REF, bytes]
-GenerationTimes = Mapping[KEY_REF, int]
-EcPublicKey = Union[
-    ec.EllipticCurvePublicKey,
-    ed25519.Ed25519PublicKey,
-    x25519.X25519PublicKey,
-]
-PublicKey = Union[EcPublicKey, rsa.RSAPublicKey]
-EcPrivateKey = Union[
-    ec.EllipticCurvePrivateKeyWithSerialization,
-    ed25519.Ed25519PrivateKey,
-    x25519.X25519PrivateKey,
-]
-PrivateKey = Union[
-    rsa.RSAPrivateKeyWithSerialization,
-    EcPrivateKey,
-]
-
-
-# mypy doesn't handle abstract dataclasses well
-@dataclass  # type: ignore[misc]
-class AlgorithmAttributes(abc.ABC):
-    _supported_ids: ClassVar[Sequence[int]]
-    algorithm_id: int
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "AlgorithmAttributes":
-        algorithm_id = encoded[0]
-        for sub_cls in cls.__subclasses__():
-            if algorithm_id in sub_cls._supported_ids:
-                return sub_cls._parse_data(algorithm_id, encoded[1:])
-        raise ValueError("Unsupported algorithm ID")
-
-    @abc.abstractmethod
-    def __bytes__(self) -> bytes:
-        raise NotImplementedError()
-
-    @classmethod
-    @abc.abstractmethod
-    def _parse_data(cls, alg: int, encoded: bytes) -> "AlgorithmAttributes":
-        raise NotImplementedError()
-
-
-@unique
-class RSA_SIZE(IntEnum):
-    RSA2048 = 2048
-    RSA3072 = 3072
-    RSA4096 = 4096
-
-
-@unique
-class RSA_IMPORT_FORMAT(IntEnum):
-    STANDARD = 0
-    STANDARD_W_MOD = 1
-    CRT = 2
-    CRT_W_MOD = 3
-
-
-@dataclass
-class RsaAttributes(AlgorithmAttributes):
-    _supported_ids = [0x01]
-
-    n_len: int
-    e_len: int
-    import_format: RSA_IMPORT_FORMAT
-
-    @classmethod
-    def create(
-        cls,
-        n_len: RSA_SIZE,
-        import_format: RSA_IMPORT_FORMAT = RSA_IMPORT_FORMAT.STANDARD,
-    ) -> "RsaAttributes":
-        return cls(0x01, n_len, 17, import_format)
-
-    @classmethod
-    def _parse_data(cls, alg, encoded) -> "RsaAttributes":
-        n, e, f = struct.unpack(">HHB", encoded)
-        return cls(alg, n, e, RSA_IMPORT_FORMAT(f))
-
-    def __bytes__(self) -> bytes:
-        return struct.pack(
-            ">BHHB", self.algorithm_id, self.n_len, self.e_len, self.import_format
-        )
-
-
-class CurveOid(bytes):
-    def _get_name(self) -> str:
-        for oid in OID:
-            if self.startswith(oid):
-                return oid.name
-        return "Unknown Curve"
-
-    def __str__(self) -> str:
-        return self._get_name()
-
-    def __repr__(self) -> str:
-        name = self._get_name()
-        return f"{name}({self.hex()})"
-
-
-class OID(CurveOid, Enum):
-    SECP256R1 = CurveOid(b"\x2a\x86\x48\xce\x3d\x03\x01\x07")
-    SECP256K1 = CurveOid(b"\x2b\x81\x04\x00\x0a")
-    SECP384R1 = CurveOid(b"\x2b\x81\x04\x00\x22")
-    SECP521R1 = CurveOid(b"\x2b\x81\x04\x00\x23")
-    BrainpoolP256R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x07")
-    BrainpoolP384R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x0b")
-    BrainpoolP512R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x0d")
-    X25519 = CurveOid(b"\x2b\x06\x01\x04\x01\x97\x55\x01\x05\x01")
-    Ed25519 = CurveOid(b"\x2b\x06\x01\x04\x01\xda\x47\x0f\x01")
-
-    @classmethod
-    def _from_key(cls, private_key: EcPrivateKey) -> CurveOid:
-        name = ""
-        if isinstance(private_key, ec.EllipticCurvePrivateKey):
-            name = private_key.curve.name.lower()
-        else:
-            if isinstance(private_key, ed25519.Ed25519PrivateKey):
-                name = "ed25519"
-            elif isinstance(private_key, x25519.X25519PrivateKey):
-                name = "x25519"
-        for oid in cls:
-            if oid.name.lower() == name:
-                return oid
-        raise ValueError("Unsupported private key")
-
-    def __repr__(self) -> str:
-        return repr(self.value)
-
-    def __str__(self) -> str:
-        return str(self.value)
-
-
-@unique
-class EC_IMPORT_FORMAT(IntEnum):
-    STANDARD = 0
-    STANDARD_W_PUBKEY = 0xFF
-
-
-@dataclass
-class EcAttributes(AlgorithmAttributes):
-    _supported_ids = [0x12, 0x13, 0x16]
-
-    oid: CurveOid
-    import_format: EC_IMPORT_FORMAT
-
-    @classmethod
-    def create(cls, key_ref: KEY_REF, oid: CurveOid) -> "EcAttributes":
-        if oid == OID.Ed25519:
-            alg = 0x16  # EdDSA
-        elif key_ref == KEY_REF.DEC:
-            alg = 0x12  # ECDH
-        else:
-            alg = 0x13  # ECDSA
-        return cls(alg, oid, EC_IMPORT_FORMAT.STANDARD)
-
-    @classmethod
-    def _parse_data(cls, alg, encoded) -> "EcAttributes":
-        if encoded[-1] == 0xFF:
-            f = EC_IMPORT_FORMAT.STANDARD_W_PUBKEY
-            oid = encoded[:-1]
-        else:  # Standard is defined as "format byte not present"
-            f = EC_IMPORT_FORMAT.STANDARD
-            oid = encoded
-
-        return cls(alg, CurveOid(oid), f)
-
-    def __bytes__(self) -> bytes:
-        buf = struct.pack(">B", self.algorithm_id) + self.oid
-        if self.import_format == EC_IMPORT_FORMAT.STANDARD_W_PUBKEY:
-            buf += struct.pack(">B", self.import_format)
-        return buf
-
-
-def _parse_key_information(encoded: bytes) -> KeyInformation:
-    return {
-        KEY_REF(encoded[i]): KEY_STATUS(encoded[i + 1])
-        for i in range(0, len(encoded), 2)
-    }
-
-
-def _parse_fingerprints(encoded: bytes) -> Fingerprints:
-    slots = list(KEY_REF)
-    return {
-        slots[i]: encoded[o : o + 20] for i, o in enumerate(range(0, len(encoded), 20))
-    }
-
-
-def _parse_timestamps(encoded: bytes) -> GenerationTimes:
-    slots = list(KEY_REF)
-    return {
-        slots[i]: bytes2int(encoded[o : o + 4])
-        for i, o in enumerate(range(0, len(encoded), 4))
-    }
-
-
-@dataclass
-class DiscretionaryDataObjects:
-    extended_capabilities: ExtendedCapabilities
-    attributes_sig: AlgorithmAttributes
-    attributes_dec: AlgorithmAttributes
-    attributes_aut: AlgorithmAttributes
-    attributes_att: Optional[AlgorithmAttributes]
-    pw_status: PwStatus
-    fingerprints: Fingerprints
-    ca_fingerprints: Fingerprints
-    generation_times: GenerationTimes
-    key_information: KeyInformation
-    uif_sig: Optional[UIF]
-    uif_dec: Optional[UIF]
-    uif_aut: Optional[UIF]
-    uif_att: Optional[UIF]
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "DiscretionaryDataObjects":
-        data = Tlv.parse_dict(encoded)
-        return cls(
-            ExtendedCapabilities.parse(data[TAG_EXTENDED_CAPABILITIES]),
-            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_SIG]),
-            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_DEC]),
-            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_AUT]),
-            (
-                AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_ATT])
-                if DO.ALGORITHM_ATTRIBUTES_ATT in data
-                else None
-            ),
-            PwStatus.parse(data[DO.PW_STATUS_BYTES]),
-            _parse_fingerprints(data[TAG_FINGERPRINTS]),
-            _parse_fingerprints(data[TAG_CA_FINGERPRINTS]),
-            _parse_timestamps(data[TAG_GENERATION_TIMES]),
-            _parse_key_information(data.get(TAG_KEY_INFORMATION, b"")),
-            (UIF.parse(data[DO.UIF_SIG]) if DO.UIF_SIG in data else None),
-            (UIF.parse(data[DO.UIF_DEC]) if DO.UIF_DEC in data else None),
-            (UIF.parse(data[DO.UIF_AUT]) if DO.UIF_AUT in data else None),
-            (UIF.parse(data[DO.UIF_ATT]) if DO.UIF_ATT in data else None),
-        )
-
-    def get_algorithm_attributes(self, key_ref: KEY_REF) -> AlgorithmAttributes:
-        return getattr(self, f"attributes_{key_ref.name.lower()}")
-
-
-@dataclass
-class ApplicationRelatedData:
-    aid: OpenPgpAid
-    historical: bytes
-    extended_length_info: Optional[ExtendedLengthInfo]
-    general_feature_management: Optional[GENERAL_FEATURE_MANAGEMENT]
-    discretionary: DiscretionaryDataObjects
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "ApplicationRelatedData":
-        outer = Tlv.unpack(DO.APPLICATION_RELATED_DATA, encoded)
-        data = Tlv.parse_dict(outer)
-        return cls(
-            OpenPgpAid(data[DO.AID]),
-            data[DO.HISTORICAL_BYTES],
-            (
-                ExtendedLengthInfo.parse(data[DO.EXTENDED_LENGTH_INFO])
-                if DO.EXTENDED_LENGTH_INFO in data
-                else None
-            ),
-            (
-                GENERAL_FEATURE_MANAGEMENT(
-                    Tlv.unpack(0x81, data[DO.GENERAL_FEATURE_MANAGEMENT])[0]
-                )
-                if DO.GENERAL_FEATURE_MANAGEMENT in data
-                else None
-            ),
-            # Older keys have data in outer dict
-            DiscretionaryDataObjects.parse(data[TAG_DISCRETIONARY] or outer),
-        )
-
-
-@dataclass
-class SecuritySupportTemplate:
-    signature_counter: int
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "SecuritySupportTemplate":
-        data = Tlv.parse_dict(Tlv.unpack(DO.SECURITY_SUPPORT_TEMPLATE, encoded))
-        return cls(bytes2int(data[TAG_SIGNATURE_COUNTER]))
-
-
-# mypy doesn't handle abstract dataclasses well
-@dataclass  # type: ignore[misc]
-class Kdf(abc.ABC):
-    algorithm: ClassVar[int]
-
-    @abc.abstractmethod
-    def process(self, pin: str, pw: PW) -> bytes:
-        """Runs the KDF on the input PIN."""
-
-    @classmethod
-    @abc.abstractmethod
-    def _parse_data(cls, data: Mapping[int, bytes]) -> "Kdf":
-        raise NotImplementedError()
-
-    @classmethod
-    def parse(cls, encoded: bytes) -> "Kdf":
-        data = Tlv.parse_dict(encoded)
-        try:
-            algorithm = bytes2int(data[0x81])
-            for sub in cls.__subclasses__():
-                if sub.algorithm == algorithm:
-                    return sub._parse_data(data)
-        except KeyError:
-            pass  # Fall though to KdfNone
-        return KdfNone()
-
-    @abc.abstractmethod
-    def __bytes__(self) -> bytes:
-        raise NotImplementedError()
-
-
-@dataclass
-class KdfNone(Kdf):
-    algorithm = 0
-
-    @classmethod
-    def _parse_data(cls, data) -> "KdfNone":
-        return cls()
-
-    def process(self, pw, pin):
-        return pin.encode()
-
-    def __bytes__(self):
-        return Tlv(0x81, struct.pack(">B", self.algorithm))
-
-
-@unique
-class HASH_ALGORITHM(IntEnum):
-    SHA256 = 0x08
-    SHA512 = 0x0A
-
-    def create_digest(self):
-        algorithm = getattr(hashes, self.name)
-        return hashes.Hash(algorithm(), default_backend())
-
-
-@dataclass
-class KdfIterSaltedS2k(Kdf):
-    algorithm = 3
-
-    hash_algorithm: HASH_ALGORITHM
-    iteration_count: int
-    salt_user: bytes
-    salt_reset: bytes
-    salt_admin: bytes
-    initial_hash_user: Optional[bytes]
-    initial_hash_admin: Optional[bytes]
-
-    @staticmethod
-    def _do_process(hash_algorithm, iteration_count, data):
-        # Although the field is called "iteration count", it's actually
-        # the number of bytes to be passed to the hash function, which
-        # is called only once. Go figure!
-        data_count, trailing_bytes = divmod(iteration_count, len(data))
-        digest = hash_algorithm.create_digest()
-        for _ in range(data_count):
-            digest.update(data)
-        digest.update(data[:trailing_bytes])
-        return digest.finalize()
-
-    @classmethod
-    def create(
-        cls,
-        hash_algorithm: HASH_ALGORITHM = HASH_ALGORITHM.SHA256,
-        iteration_count: int = 0x780000,
-    ) -> "KdfIterSaltedS2k":
-        salt_user = os.urandom(8)
-        salt_admin = os.urandom(8)
-        return cls(
-            hash_algorithm,
-            iteration_count,
-            salt_user,
-            os.urandom(8),
-            salt_admin,
-            cls._do_process(
-                hash_algorithm, iteration_count, salt_user + DEFAULT_USER_PIN.encode()
-            ),
-            cls._do_process(
-                hash_algorithm, iteration_count, salt_admin + DEFAULT_ADMIN_PIN.encode()
-            ),
-        )
-
-    @classmethod
-    def _parse_data(cls, data) -> "KdfIterSaltedS2k":
-        return cls(
-            HASH_ALGORITHM(bytes2int(data[0x82])),
-            bytes2int(data[0x83]),
-            data[0x84],
-            data.get(0x85),
-            data.get(0x86),
-            data.get(0x87),
-            data.get(0x88),
-        )
-
-    def get_salt(self, pw: PW) -> bytes:
-        return getattr(self, f"salt_{pw.name.lower()}")
-
-    def process(self, pw, pin):
-        salt = self.get_salt(pw) or self.salt_user
-        data = salt + pin.encode()
-        return self._do_process(self.hash_algorithm, self.iteration_count, data)
-
-    def __bytes__(self):
-        return (
-            Tlv(0x81, struct.pack(">B", self.algorithm))
-            + Tlv(0x82, struct.pack(">B", self.hash_algorithm))
-            + Tlv(0x83, struct.pack(">I", self.iteration_count))
-            + Tlv(0x84, self.salt_user)
-            + (Tlv(0x85, self.salt_reset) if self.salt_reset else b"")
-            + (Tlv(0x86, self.salt_admin) if self.salt_admin else b"")
-            + (Tlv(0x87, self.initial_hash_user) if self.initial_hash_user else b"")
-            + (Tlv(0x88, self.initial_hash_admin) if self.initial_hash_admin else b"")
-        )
-
-
-# mypy doesn't handle abstract dataclasses well
-@dataclass  # type: ignore[misc]
-class PrivateKeyTemplate(abc.ABC):
-    crt: CRT
-
-    def _get_template(self) -> Sequence[Tlv]:
-        raise NotImplementedError()
-
-    def __bytes__(self) -> bytes:
-        tlvs = self._get_template()
-        return Tlv(
-            0x4D,
-            self.crt
-            + Tlv(0x7F48, b"".join(tlv[: -tlv.length] for tlv in tlvs))
-            + Tlv(0x5F48, b"".join(tlv.value for tlv in tlvs)),
-        )
-
-
-@dataclass
-class RsaKeyTemplate(PrivateKeyTemplate):
-    e: bytes
-    p: bytes
-    q: bytes
-
-    def _get_template(self):
-        return (
-            Tlv(0x91, self.e),
-            Tlv(0x92, self.p),
-            Tlv(0x93, self.q),
-        )
-
-
-@dataclass
-class RsaCrtKeyTemplate(RsaKeyTemplate):
-    iqmp: bytes
-    dmp1: bytes
-    dmq1: bytes
-    n: bytes
-
-    def _get_template(self):
-        return (
-            *super()._get_template(),
-            Tlv(0x94, self.iqmp),
-            Tlv(0x95, self.dmp1),
-            Tlv(0x96, self.dmq1),
-            Tlv(0x97, self.n),
-        )
-
-
-@dataclass
-class EcKeyTemplate(PrivateKeyTemplate):
-    private_key: bytes
-    public_key: Optional[bytes]
-
-    def _get_template(self):
-        tlvs: Tuple[Tlv, ...] = (Tlv(0x92, self.private_key),)
-        if self.public_key:
-            tlvs = (*tlvs, Tlv(0x99, self.public_key))
-
-        return tlvs
-
-
-def _get_key_attributes(
-    private_key: PrivateKey, key_ref: KEY_REF, version: Version
-) -> AlgorithmAttributes:
-    if isinstance(private_key, rsa.RSAPrivateKeyWithSerialization):
-        if private_key.private_numbers().public_numbers.e != 65537:
-            raise ValueError("RSA keys with e != 65537 are not supported!")
-        return RsaAttributes.create(
-            RSA_SIZE(private_key.key_size),
-            RSA_IMPORT_FORMAT.CRT_W_MOD
-            if version < (4, 0, 0)
-            else RSA_IMPORT_FORMAT.STANDARD,
-        )
-    return EcAttributes.create(key_ref, OID._from_key(private_key))
-
-
-def _get_key_template(
-    private_key: PrivateKey, key_ref: KEY_REF, use_crt: bool = False
-) -> PrivateKeyTemplate:
-    if isinstance(private_key, rsa.RSAPrivateKeyWithSerialization):
-        rsa_numbers = private_key.private_numbers()
-        ln = (private_key.key_size // 8) // 2
-
-        e = b"\x01\x00\x01"  # e=65537
-        p = int2bytes(rsa_numbers.p, ln)
-        q = int2bytes(rsa_numbers.q, ln)
-        if not use_crt:
-            return RsaKeyTemplate(key_ref.crt, e, p, q)
-        else:
-            dp = int2bytes(rsa_numbers.dmp1, ln)
-            dq = int2bytes(rsa_numbers.dmq1, ln)
-            qinv = int2bytes(rsa_numbers.iqmp, ln)
-            n = int2bytes(rsa_numbers.public_numbers.n, 2 * ln)
-            return RsaCrtKeyTemplate(key_ref.crt, e, p, q, qinv, dp, dq, n)
-
-    elif isinstance(private_key, ec.EllipticCurvePrivateKeyWithSerialization):
-        ec_numbers = private_key.private_numbers()
-        ln = private_key.key_size // 8
-        return EcKeyTemplate(key_ref.crt, int2bytes(ec_numbers.private_value, ln), None)
-
-    elif isinstance(private_key, (ed25519.Ed25519PrivateKey, x25519.X25519PrivateKey)):
-        pkb = private_key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
-        if isinstance(private_key, x25519.X25519PrivateKey):
-            pkb = pkb[::-1]  # byte order needs to be reversed
-        return EcKeyTemplate(
-            key_ref.crt,
-            pkb,
-            None,
-        )
-
-    raise ValueError("Unsupported key type")
-
-
-def _parse_rsa_key(data: Mapping[int, bytes]) -> rsa.RSAPublicKey:
-    numbers = rsa.RSAPublicNumbers(bytes2int(data[0x82]), bytes2int(data[0x81]))
-    return numbers.public_key(default_backend())
-
-
-def _parse_ec_key(oid: CurveOid, data: Mapping[int, bytes]) -> EcPublicKey:
-    pubkey_enc = data[0x86]
-    if oid == OID.X25519:
-        return x25519.X25519PublicKey.from_public_bytes(pubkey_enc)
-    if oid == OID.Ed25519:
-        return ed25519.Ed25519PublicKey.from_public_bytes(pubkey_enc)
-
-    curve = getattr(ec, oid._get_name())
-    return ec.EllipticCurvePublicKey.from_encoded_point(curve(), pubkey_enc)
-
-
-_pkcs1v15_headers = {
-    hashes.MD5: bytes.fromhex("3020300C06082A864886F70D020505000410"),
-    hashes.SHA1: bytes.fromhex("3021300906052B0E03021A05000414"),
-    hashes.SHA224: bytes.fromhex("302D300D06096086480165030402040500041C"),
-    hashes.SHA256: bytes.fromhex("3031300D060960864801650304020105000420"),
-    hashes.SHA384: bytes.fromhex("3041300D060960864801650304020205000430"),
-    hashes.SHA512: bytes.fromhex("3051300D060960864801650304020305000440"),
-    hashes.SHA512_224: bytes.fromhex("302D300D06096086480165030402050500041C"),
-    hashes.SHA512_256: bytes.fromhex("3031300D060960864801650304020605000420"),
-}
-
-
-def _pad_message(attributes, message, hash_algorithm):
-    if attributes.algorithm_id == 0x16:  # EdDSA, never hash
-        return message
-
-    if isinstance(hash_algorithm, Prehashed):
-        hashed = message
-    else:
-        h = hashes.Hash(hash_algorithm, default_backend())
-        h.update(message)
-        hashed = h.finalize()
-
-    if isinstance(attributes, EcAttributes):
-        return hashed
-    if isinstance(attributes, RsaAttributes):
-        try:
-            return _pkcs1v15_headers[type(hash_algorithm)] + hashed
-        except KeyError:
-            raise ValueError(f"Unsupported hash algorithim for RSA: {hash_algorithm}")
-
-
-class OpenPgpSession:
-    def __init__(self, connection: SmartCardConnection):
-        self.protocol = SmartCardProtocol(connection)
-        try:
-            self.protocol.select(AID.OPENPGP)
-        except ApduError as e:
-            if e.sw in (SW.NO_INPUT_DATA, SW.CONDITIONS_NOT_SATISFIED):
-                # Not activated, activate
-                logger.warning("Application not active, sending ACTIVATE")
-                self.protocol.send_apdu(0, INS.ACTIVATE, 0, 0)
-                self.protocol.select(AID.OPENPGP)
-            else:
-                raise
-        self._version = self._read_version()
-
-        self.protocol.enable_touch_workaround(self.version)
-        if self.version >= (4, 0, 0):
-            self.protocol.apdu_format = ApduFormat.EXTENDED
-
-        # Note: This value is cached!
-        # Do not rely on contained information that can change!
-        self._app_data = self.get_application_related_data()
-        logger.debug(f"OpenPGP session initialized (version={self.version})")
-
-    def _read_version(self) -> Version:
-        logger.debug("Getting version number")
-        bcd = self.protocol.send_apdu(0, INS.GET_VERSION, 0, 0)
-        return Version(*(_bcd(x) for x in bcd))
-
-    @property
-    def aid(self) -> OpenPgpAid:
-        """Get the AID used to select the applet."""
-        return self._app_data.aid
-
-    @property
-    def version(self) -> Version:
-        """Get the firmware version of the key.
-
-        For YubiKey NEO this is the PGP applet version.
-        """
-        return self._version
-
-    @property
-    def extended_capabilities(self) -> ExtendedCapabilities:
-        """Get the Extended Capabilities from the YubiKey."""
-        return self._app_data.discretionary.extended_capabilities
-
-    def get_challenge(self, length: int) -> bytes:
-        """Get random data from the YubiKey."""
-        e = self.extended_capabilities
-        if EXTENDED_CAPABILITY_FLAGS.GET_CHALLENGE not in e.flags:
-            raise NotSupportedError("GET_CHALLENGE is not supported")
-        if not 0 < length <= e.challenge_max_length:
-            raise NotSupportedError("Unsupported challenge length")
-
-        logger.debug(f"Getting {length} random bytes")
-        return self.protocol.send_apdu(0, INS.GET_CHALLENGE, 0, 0, le=length)
-
-    def get_data(self, do: DO) -> bytes:
-        """Get a Data Object from the YubiKey."""
-        logger.debug(f"Reading Data Object {do.name} ({do:X})")
-        return self.protocol.send_apdu(0, INS.GET_DATA, do >> 8, do & 0xFF)
-
-    def put_data(self, do: DO, data: Union[bytes, SupportsBytes]) -> None:
-        """Write a Data Object to the YubiKey."""
-        self.protocol.send_apdu(0, INS.PUT_DATA, do >> 8, do & 0xFF, bytes(data))
-        logger.info(f"Wrote Data Object {do.name} ({do:X})")
-
-    def get_pin_status(self) -> PwStatus:
-        """Get the current status of PINS."""
-        return PwStatus.parse(self.get_data(DO.PW_STATUS_BYTES))
-
-    def get_signature_counter(self) -> int:
-        """Get the number of times the signature key has been used."""
-        s = SecuritySupportTemplate.parse(self.get_data(DO.SECURITY_SUPPORT_TEMPLATE))
-        return s.signature_counter
-
-    def get_application_related_data(self) -> ApplicationRelatedData:
-        """Read the Application Related Data."""
-        return ApplicationRelatedData.parse(self.get_data(DO.APPLICATION_RELATED_DATA))
-
-    def set_signature_pin_policy(self, pin_policy: PIN_POLICY) -> None:
-        """Requires Admin PIN verification."""
-        logger.debug(f"Setting Signature PIN policy to {pin_policy}")
-        data = struct.pack(">B", pin_policy)
-        self.put_data(DO.PW_STATUS_BYTES, data)
-        logger.info("Signature PIN policy set")
-
-    def reset(self) -> None:
-        """Performs a factory reset on the OpenPGP application.
-
-        WARNING: This will delete all stored keys, certificates and other data.
-        """
-        require_version(self.version, (1, 0, 6))
-        logger.debug("Preparing OpenPGP reset")
-
-        # Ensure the User and Admin PINs are blocked
-        status = self.get_pin_status()
-        for pw in (PW.USER, PW.ADMIN):
-            logger.debug(f"Verify {pw.name} PIN with invalid attempts until blocked")
-            for _ in range(status.get_attempts(pw)):
-                try:
-                    self.protocol.send_apdu(0, INS.VERIFY, 0, pw, _INVALID_PIN)
-                except ApduError:
-                    pass
-
-        # Reset the application
-        logger.debug("Sending TERMINATE, then ACTIVATE")
-        self.protocol.send_apdu(0, INS.TERMINATE, 0, 0)
-        self.protocol.send_apdu(0, INS.ACTIVATE, 0, 0)
-
-        logger.info("OpenPGP application data reset performed")
-
-    def set_pin_attempts(
-        self, user_attempts: int, reset_attempts: int, admin_attempts: int
-    ) -> None:
-        """Set the number of PIN attempts to allow before blocking.
-
-        WARNING: On YubiKey NEO this will reset the PINs to their default values.
-
-        Requires Admin PIN verification.
-        """
-        if self.version[0] == 1:
-            # YubiKey NEO
-            require_version(self.version, (1, 0, 7))
-        else:
-            require_version(self.version, (4, 3, 1))
-
-        attempts = (user_attempts, reset_attempts, admin_attempts)
-        logger.debug(f"Setting PIN attempts to {attempts}")
-        self.protocol.send_apdu(
-            0,
-            INS.SET_PIN_RETRIES,
-            0,
-            0,
-            struct.pack(">BBB", *attempts),
-        )
-        logger.info("Number of PIN attempts has been changed")
-
-    def get_kdf(self):
-        """Get the Key Derivation Function data object."""
-        if EXTENDED_CAPABILITY_FLAGS.KDF not in self.extended_capabilities.flags:
-            return KdfNone()
-        return Kdf.parse(self.get_data(DO.KDF))
-
-    def set_kdf(self, kdf: Kdf) -> None:
-        """Set up a PIN Key Derivation Function.
-
-        This enables (or disables) the use of a KDF for PIN verification, as well
-        as resetting the User and Admin PINs to their default (initial) values.
-
-        If a Reset Code is present, it will be invalidated.
-
-        This command requires Admin PIN verification.
-        """
-        e = self._app_data.discretionary.extended_capabilities
-        if EXTENDED_CAPABILITY_FLAGS.KDF not in e.flags:
-            raise NotSupportedError("KDF is not supported")
-
-        logger.debug(f"Setting PIN KDF to algorithm: {kdf.algorithm}")
-        self.put_data(DO.KDF, kdf)
-        logger.info("KDF settings changed")
-
-    def _verify(self, pw: PW, pin: str, mode: int = 0) -> None:
-        pin_enc = self.get_kdf().process(pw, pin)
-        try:
-            self.protocol.send_apdu(0, INS.VERIFY, 0, pw + mode, pin_enc)
-        except ApduError:
-            attempts = self.get_pin_status().get_attempts(pw)
-            raise ValueError(f"Invalid PIN, {attempts} tries remaining.")
-
-    def verify_pin(self, pin, extended: bool = False):
-        """Verify the User PIN.
-
-        This will unlock functionality that requires User PIN verification.
-        Note that with `extended=False` (default) only sign operations are allowed.
-        Inversely, with `extended=False` sign operations are NOT allowed.
-        """
-        logger.debug(f"Verifying User PIN in mode {'82' if extended else '81'}")
-        self._verify(PW.USER, pin, 1 if extended else 0)
-
-    def verify_admin(self, admin_pin):
-        """Verify the Admin PIN.
-
-        This will unlock functionality that requires Admin PIN verification.
-        """
-        logger.debug("Verifying Admin PIN")
-        self._verify(PW.ADMIN, admin_pin)
-
-    def unverify_pin(self, pw: PW) -> None:
-        require_version(self.version, (5, 6, 0))
-        logger.debug(f"Resetting verification for {pw.name} PIN")
-        self.protocol.send_apdu(0, INS.VERIFY, 0xFF, pw)
-
-    def _change(self, pw: PW, pin: str, new_pin: str) -> None:
-        logger.debug(f"Changing {pw.name} PIN")
-        kdf = self.get_kdf()
-        try:
-            self.protocol.send_apdu(
-                0,
-                INS.CHANGE_PIN,
-                0,
-                pw,
-                kdf.process(pw, pin) + kdf.process(pw, new_pin),
-            )
-        except ApduError as e:
-            if e.sw == SW.CONDITIONS_NOT_SATISFIED:
-                raise ValueError("Conditions of use not satisfied.")
-            else:
-                remaining = self.get_pin_status().get_attempts(pw)
-                raise ValueError(f"Invalid PIN, {remaining} tries remaining.")
-        logger.info(f"New {pw.name} PIN set")
-
-    def change_pin(self, pin: str, new_pin: str) -> None:
-        """Change the User PIN."""
-        self._change(PW.USER, pin, new_pin)
-
-    def change_admin(self, admin_pin: str, new_admin_pin: str) -> None:
-        """Change the Admin PIN."""
-        self._change(PW.ADMIN, admin_pin, new_admin_pin)
-
-    def set_reset_code(self, reset_code: str) -> None:
-        """Set the Reset Code for User PIN.
-
-        The Reset Code can be used to set a new User PIN if it is lost or becomes
-        blocked, using the reset_pin method.
-
-        This command requires Admin PIN verification.
-        """
-        logger.debug("Setting a new PIN Reset Code")
-        data = self.get_kdf().process(PW.RESET, reset_code)
-        self.put_data(DO.RESETTING_CODE, data)
-        logger.info("New Reset Code has been set")
-
-    def reset_pin(self, new_pin: str, reset_code: Optional[str] = None) -> None:
-        """Resets the User PIN to a new value.
-
-        This command requires Admin PIN verification, or the Reset Code.
-        """
-        logger.debug("Resetting User PIN")
-        p1 = 2
-        kdf = self.get_kdf()
-        data = kdf.process(PW.USER, new_pin)
-        if reset_code:
-            logger.debug("Using Reset Code")
-            data = kdf.process(PW.RESET, reset_code) + data
-            p1 = 0
-
-        try:
-            self.protocol.send_apdu(0, INS.RESET_RETRY_COUNTER, p1, PW.USER, data)
-        except ApduError as e:
-            if e.sw == SW.CONDITIONS_NOT_SATISFIED:
-                raise ValueError("Conditions of use not satisfied.")
-            else:
-                reset_remaining = self.get_pin_status().attempts_reset
-                raise ValueError(
-                    f"Invalid Reset Code, {reset_remaining} tries remaining."
-                )
-        logger.info("New User PIN has been set")
-
-    def get_algorithm_attributes(self, key_ref: KEY_REF) -> AlgorithmAttributes:
-        """Get the algorithm attributes for one of the key slots."""
-        logger.debug(f"Getting Algorithm Attributes for {key_ref.name}")
-        data = self.get_application_related_data()
-        return data.discretionary.get_algorithm_attributes(key_ref)
-
-    def get_algorithm_information(
-        self,
-    ) -> Mapping[KEY_REF, Sequence[AlgorithmAttributes]]:
-        """Get the list of supported algorithm attributes for each key.
-
-        The return value is a mapping of KEY_REF to a list of supported algorithm
-        attributes, which can be set using set_algorithm_attributes.
-        """
-        if (
-            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
-            not in self.extended_capabilities.flags
-        ):
-            raise NotSupportedError("Writing Algorithm Attributes is not supported")
-
-        if self.version < (5, 2, 0):
-            sizes = [RSA_SIZE.RSA2048]
-            if self.version < (4, 0, 0):  # Neo needs CRT
-                fmt = RSA_IMPORT_FORMAT.CRT_W_MOD
-            else:
-                fmt = RSA_IMPORT_FORMAT.STANDARD
-                if self.version[:2] != (4, 4):  # Non-FIPS
-                    sizes.extend([RSA_SIZE.RSA3072, RSA_SIZE.RSA4096])
-            return {
-                KEY_REF.SIG: [RsaAttributes.create(size, fmt) for size in sizes],
-                KEY_REF.DEC: [RsaAttributes.create(size, fmt) for size in sizes],
-                KEY_REF.AUT: [RsaAttributes.create(size, fmt) for size in sizes],
-            }
-
-        logger.debug("Getting supported Algorithm Information")
-        buf = self.get_data(DO.ALGORITHM_INFORMATION)
-        try:
-            buf = Tlv.unpack(DO.ALGORITHM_INFORMATION, buf)
-        except ValueError:
-            buf = Tlv.unpack(DO.ALGORITHM_INFORMATION, buf + b"\0\0")[:-2]
-
-        slots = {slot.algorithm_attributes_do: slot for slot in KEY_REF}
-        data: Dict[KEY_REF, List[AlgorithmAttributes]] = {}
-        for tlv in Tlv.parse_list(buf):
-            data.setdefault(slots[DO(tlv.tag)], []).append(
-                AlgorithmAttributes.parse(tlv.value)
-            )
-
-        if self.version < (5, 6, 1):
-            # Fix for invalid Curve25519 entries:
-            # Remove X25519 with EdDSA from all keys
-            invalid_x25519 = EcAttributes(0x16, OID.X25519, EC_IMPORT_FORMAT.STANDARD)
-            for values in data.values():
-                values.remove(invalid_x25519)
-            x25519 = EcAttributes(0x12, OID.X25519, EC_IMPORT_FORMAT.STANDARD)
-            # Add X25519 ECDH for DEC
-            if x25519 not in data[KEY_REF.DEC]:
-                data[KEY_REF.DEC].append(x25519)
-            # Remove EdDSA from DEC, ATT
-            ed25519_attr = EcAttributes(0x16, OID.Ed25519, EC_IMPORT_FORMAT.STANDARD)
-            data[KEY_REF.DEC].remove(ed25519_attr)
-            data[KEY_REF.ATT].remove(ed25519_attr)
-
-        return data
-
-    def set_algorithm_attributes(
-        self, key_ref: KEY_REF, attributes: AlgorithmAttributes
-    ) -> None:
-        """Sets the algorithm attributes for a key slot.
-
-        WARNING: This will delete any key already stored in the slot if the attributes
-        are changed!
-
-        This command requires Admin PIN verification.
-        """
-        logger.debug("Setting Algorithm Attributes for {key_ref.name}")
-        supported = self.get_algorithm_information()
-        if key_ref not in supported:
-            raise NotSupportedError("Key slot not supported")
-        if attributes not in supported[key_ref]:
-            raise NotSupportedError("Algorithm attributes not supported")
-
-        self.put_data(key_ref.algorithm_attributes_do, attributes)
-        logger.info("Algorithm Attributes have been changed")
-
-    def get_uif(self, key_ref: KEY_REF) -> UIF:
-        """Get the User Interaction Flag (touch requirement) for a key."""
-        try:
-            return UIF.parse(self.get_data(key_ref.uif_do))
-        except ApduError as e:
-            if e.sw == SW.WRONG_PARAMETERS_P1P2:
-                # Not supported
-                return UIF.OFF
-            raise
-
-    def set_uif(self, key_ref: KEY_REF, uif: UIF) -> None:
-        """Set the User Interaction Flag (touch requirement) for a key.
-
-        Requires Admin PIN verification.
-        """
-        require_version(self.version, (4, 2, 0))
-        if key_ref == KEY_REF.ATT:
-            require_version(
-                self.version,
-                (5, 2, 1),
-                "Attestation key requires YubiKey 5.2.1 or later.",
-            )
-        if uif.is_cached:
-            require_version(
-                self.version,
-                (5, 2, 1),
-                "Cached UIF values require YubiKey 5.2.1 or later.",
-            )
-
-        logger.debug(f"Setting UIF for {key_ref.name} to {uif.name}")
-        if self.get_uif(key_ref).is_fixed:
-            raise ValueError("Cannot change UIF when set to FIXED.")
-
-        self.put_data(key_ref.uif_do, uif)
-        logger.info(f"UIF changed for {key_ref.name}")
-
-    def get_key_information(self) -> KeyInformation:
-        """Get the status of the keys."""
-        logger.debug("Getting Key Information")
-        return self.get_application_related_data().discretionary.key_information
-
-    def get_generation_times(self) -> GenerationTimes:
-        """Get timestamps for when keys were generated."""
-        logger.debug("Getting key generation timestamps")
-        return self.get_application_related_data().discretionary.generation_times
-
-    def set_generation_time(self, key_ref: KEY_REF, timestamp: int) -> None:
-        """Set the generation timestamp for a key.
-
-        Requires Admin PIN verification.
-        """
-        logger.debug(f"Setting key generation timestamp for {key_ref.name}")
-        self.put_data(key_ref.generation_time_do, struct.pack(">I", timestamp))
-        logger.info(f"Key generation timestamp set for {key_ref.name}")
-
-    def get_fingerprints(self) -> Fingerprints:
-        """Get key fingerprints."""
-        logger.debug("Getting key fingerprints")
-        return self.get_application_related_data().discretionary.fingerprints
-
-    def set_fingerprint(self, key_ref: KEY_REF, fingerprint: bytes) -> None:
-        """Set the fingerprint for a key.
-
-        Requires Admin PIN verification.
-        """
-        logger.debug(f"Setting key fingerprint for {key_ref.name}")
-        self.put_data(key_ref.fingerprint_do, fingerprint)
-        logger.info("Key fingerprint set for {key_ref.name}")
-
-    def get_public_key(self, key_ref: KEY_REF) -> PublicKey:
-        """Get the public key from a slot."""
-        logger.debug(f"Getting public key for {key_ref.name}")
-        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x81, 0x00, key_ref.crt)
-        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
-        attributes = self.get_algorithm_attributes(key_ref)
-        if isinstance(attributes, EcAttributes):
-            return _parse_ec_key(attributes.oid, data)
-        else:  # RSA
-            return _parse_rsa_key(data)
-
-    def generate_rsa_key(
-        self, key_ref: KEY_REF, key_size: RSA_SIZE
-    ) -> rsa.RSAPublicKey:
-        """Generate an RSA key in the given slot.
-
-        Requires Admin PIN verification.
-        """
-        if (4, 2, 0) <= self.version < (4, 3, 5):
-            raise NotSupportedError("RSA key generation not supported on this YubiKey")
-
-        logger.debug(f"Generating RSA private key for {key_ref.name}")
-        if (
-            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
-            in self.extended_capabilities.flags
-        ):
-            attributes = RsaAttributes.create(key_size)
-            self.set_algorithm_attributes(key_ref, attributes)
-        elif key_size != RSA_SIZE.RSA2048:
-            raise NotSupportedError("Algorithm attributes not supported")
-
-        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x80, 0x00, key_ref.crt)
-        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
-        logger.info(f"RSA key generated for {key_ref.name}")
-        return _parse_rsa_key(data)
-
-    def generate_ec_key(self, key_ref: KEY_REF, curve_oid: CurveOid) -> EcPublicKey:
-        """Generate an EC key in the given slot.
-
-        Requires Admin PIN verification.
-        """
-
-        require_version(self.version, (5, 2, 0))
-
-        if curve_oid not in OID:
-            raise ValueError("Curve OID is not recognized")
-
-        logger.debug(f"Generating EC private key for {key_ref.name}")
-        attributes = EcAttributes.create(key_ref, curve_oid)
-        self.set_algorithm_attributes(key_ref, attributes)
-
-        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x80, 0x00, key_ref.crt)
-        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
-        logger.info(f"EC key generated for {key_ref.name}")
-        return _parse_ec_key(curve_oid, data)
-
-    def put_key(self, key_ref: KEY_REF, private_key: PrivateKey) -> None:
-        """Import a private key into the give slot.
-
-        Requires Admin PIN verification.
-        """
-
-        logger.debug(f"Importing a private key for {key_ref.name}")
-        attributes = _get_key_attributes(private_key, key_ref, self.version)
-        if (
-            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
-            in self.extended_capabilities.flags
-        ):
-            self.set_algorithm_attributes(key_ref, attributes)
-        else:
-            if not (
-                isinstance(attributes, RsaAttributes)
-                and attributes.n_len == RSA_SIZE.RSA2048
-            ):
-                raise NotSupportedError("This YubiKey only supports RSA 2048 keys")
-
-        template = _get_key_template(private_key, key_ref, self.version < (4, 0, 0))
-        self.protocol.send_apdu(0, INS.PUT_DATA_ODD, 0x3F, 0xFF, bytes(template))
-        logger.info(f"Private key imported for {key_ref.name}")
-
-    def delete_key(self, key_ref: KEY_REF) -> None:
-        """Deletes the contents of a key slot.
-
-        Requires Admin PIN verification.
-        """
-        if self.version < (4, 0, 0):
-            # Import over the key
-            self.put_key(
-                key_ref, rsa.generate_private_key(65537, 2048, default_backend())
-            )
-        else:
-            # Delete key by changing the key attributes twice.
-            self.put_data(  # Use put_data to avoid checking for RSA 4096 support
-                key_ref.algorithm_attributes_do, RsaAttributes.create(RSA_SIZE.RSA4096)
-            )
-            self.set_algorithm_attributes(
-                key_ref, RsaAttributes.create(RSA_SIZE.RSA2048)
-            )
-
-    def _select_certificate(self, key_ref: KEY_REF) -> None:
-        logger.debug(f"Selecting certificate for key {key_ref.name}")
-        try:
-            require_version(self.version, (5, 2, 0))
-            data: bytes = Tlv(0x60, Tlv(0x5C, int2bytes(DO.CARDHOLDER_CERTIFICATE)))
-            if self.version <= (5, 4, 3):
-                # These use a non-standard byte in the command.
-                data = b"\x06" + data  # 6 is the length of the data.
-            self.protocol.send_apdu(
-                0,
-                INS.SELECT_DATA,
-                3 - key_ref,
-                0x04,
-                data,
-            )
-        except NotSupportedError:
-            if key_ref == KEY_REF.AUT:
-                return  # Older version still support AUT, which is the default slot.
-            raise
-
-    def get_certificate(self, key_ref: KEY_REF) -> x509.Certificate:
-        """Get a certificate from a slot."""
-        logger.debug(f"Getting certificate for key {key_ref.name}")
-        if key_ref == KEY_REF.ATT:
-            require_version(self.version, (5, 2, 0))
-            data = self.get_data(DO.ATT_CERTIFICATE)
-        else:
-            self._select_certificate(key_ref)
-            data = self.get_data(DO.CARDHOLDER_CERTIFICATE)
-        if not data:
-            raise ValueError("No certificate found!")
-        return x509.load_der_x509_certificate(data, default_backend())
-
-    def put_certificate(self, key_ref: KEY_REF, certificate: x509.Certificate) -> None:
-        """Imports a certificate into a slot.
-
-        Requires Admin PIN verification.
-        """
-        cert_data = certificate.public_bytes(Encoding.DER)
-        logger.debug(f"Importing certificate for key {key_ref.name}")
-        if key_ref == KEY_REF.ATT:
-            require_version(self.version, (5, 2, 0))
-            self.put_data(DO.ATT_CERTIFICATE, cert_data)
-        else:
-            self._select_certificate(key_ref)
-            self.put_data(DO.CARDHOLDER_CERTIFICATE, cert_data)
-        logger.info(f"Certificate imported for key {key_ref.name}")
-
-    def delete_certificate(self, key_ref: KEY_REF) -> None:
-        """Deletes a certificate in a slot.
-
-        Requires Admin PIN verification.
-        """
-        logger.debug(f"Deleting certificate for key {key_ref.name}")
-        if key_ref == KEY_REF.ATT:
-            require_version(self.version, (5, 2, 0))
-            self.put_data(DO.ATT_CERTIFICATE, b"")
-        else:
-            self._select_certificate(key_ref)
-            self.put_data(DO.CARDHOLDER_CERTIFICATE, b"")
-        logger.info(f"Certificate deleted for key {key_ref.name}")
-
-    def attest_key(self, key_ref: KEY_REF) -> x509.Certificate:
-        """Creates an attestation certificate for a key.
-
-        The certificte is written to the certificate slot for the key, and its
-        content is returned.
-
-        Requires User PIN verification.
-        """
-        require_version(self.version, (5, 2, 0))
-        logger.debug(f"Attesting key {key_ref.name}")
-        self.protocol.send_apdu(0x80, INS.GET_ATTESTATION, key_ref, 0)
-        logger.info(f"Attestation certificate created for {key_ref.name}")
-        return self.get_certificate(key_ref)
-
-    def sign(self, message: bytes, hash_algorithm: hashes.HashAlgorithm) -> bytes:
-        """Signs a message using the SIG key.
-
-        Requires User PIN verification.
-        """
-        attributes = self.get_algorithm_attributes(KEY_REF.SIG)
-        padded = _pad_message(attributes, message, hash_algorithm)
-        logger.debug(f"Signing a message with {attributes}")
-        response = self.protocol.send_apdu(0, INS.PSO, 0x9E, 0x9A, padded)
-        logger.info("Message signed")
-        if attributes.algorithm_id == 0x13:
-            ln = len(response) // 2
-            return encode_dss_signature(
-                int.from_bytes(response[:ln], "big"),
-                int.from_bytes(response[ln:], "big"),
-            )
-        return response
-
-    def decrypt(self, value: Union[bytes, EcPublicKey]) -> bytes:
-        """Decrypts a value using the DEC key.
-
-        For RSA the `value` should be an encrypted block.
-        For ECDH the `value` should be a peer public-key to perform the key exchange
-        with, and the result will be the derived shared secret.
-
-        Requires (extended) User PIN verification.
-        """
-        attributes = self.get_algorithm_attributes(KEY_REF.DEC)
-        logger.debug(f"Decrypting a value with {attributes}")
-
-        if isinstance(value, ec.EllipticCurvePublicKey):
-            data = value.public_bytes(Encoding.X962, PublicFormat.UncompressedPoint)
-        elif isinstance(value, x25519.X25519PublicKey):
-            data = value.public_bytes(Encoding.Raw, PublicFormat.Raw)
-        elif isinstance(value, bytes):
-            data = value
-
-        if isinstance(attributes, RsaAttributes):
-            data = b"\0" + data
-        elif isinstance(attributes, EcAttributes):
-            data = Tlv(0xA6, Tlv(0x7F49, Tlv(0x86, data)))
-
-        response = self.protocol.send_apdu(0, INS.PSO, 0x80, 0x86, data)
-        logger.info("Value decrypted")
-        return response
-
-    def authenticate(
-        self, message: bytes, hash_algorithm: hashes.HashAlgorithm
-    ) -> bytes:
-        """Authenticates a message using the AUT key.
-
-        Requires User PIN verification.
-        """
-        attributes = self.get_algorithm_attributes(KEY_REF.AUT)
-        padded = _pad_message(attributes, message, hash_algorithm)
-        logger.debug(f"Authenticating a message with {attributes}")
-        response = self.protocol.send_apdu(
-            0, INS.INTERNAL_AUTHENTICATE, 0x0, 0x0, padded
-        )
-        logger.info("Message authenticated")
-        if attributes.algorithm_id == 0x13:
-            ln = len(response) // 2
-            return encode_dss_signature(
-                int.from_bytes(response[:ln], "big"),
-                int.from_bytes(response[ln:], "big"),
-            )
-        return response
+from .core import (
+    Tlv,
+    Version,
+    NotSupportedError,
+    require_version,
+    int2bytes,
+    bytes2int,
+)
+from .core.smartcard import (
+    SmartCardConnection,
+    SmartCardProtocol,
+    ApduFormat,
+    ApduError,
+    AID,
+    SW,
+)
+
+from cryptography import x509
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.serialization import (
+    Encoding,
+    PrivateFormat,
+    PublicFormat,
+    NoEncryption,
+)
+from cryptography.hazmat.primitives.asymmetric import rsa, ec, ed25519, x25519
+from cryptography.hazmat.primitives.asymmetric.utils import (
+    Prehashed,
+    encode_dss_signature,
+)
+
+import os
+import abc
+from enum import Enum, IntEnum, IntFlag, unique
+from dataclasses import dataclass
+from typing import (
+    Optional,
+    Tuple,
+    ClassVar,
+    Mapping,
+    Sequence,
+    SupportsBytes,
+    Union,
+    Dict,
+    List,
+)
+import struct
+import logging
+
+logger = logging.getLogger(__name__)
+
+DEFAULT_USER_PIN = "123456"
+DEFAULT_ADMIN_PIN = "12345678"
+
+
+@unique
+class UIF(IntEnum):  # noqa: N801
+    OFF = 0x00
+    ON = 0x01
+    FIXED = 0x02
+    CACHED = 0x03
+    CACHED_FIXED = 0x04
+
+    @classmethod
+    def parse(cls, encoded: bytes):
+        return cls(encoded[0])
+
+    def __bytes__(self) -> bytes:
+        return struct.pack(">BB", self, GENERAL_FEATURE_MANAGEMENT.BUTTON)
+
+    @property
+    def is_fixed(self) -> bool:
+        return self in (UIF.FIXED, UIF.CACHED_FIXED)
+
+    @property
+    def is_cached(self) -> bool:
+        return self in (UIF.CACHED, UIF.CACHED_FIXED)
+
+    def __str__(self):
+        if self == UIF.FIXED:
+            return "On (fixed)"
+        if self == UIF.CACHED_FIXED:
+            return "Cached (fixed)"
+        return self.name[0] + self.name[1:].lower()
+
+
+@unique
+class PIN_POLICY(IntEnum):  # noqa: N801
+    ALWAYS = 0x00
+    ONCE = 0x01
+
+    def __str__(self):
+        return self.name[0] + self.name[1:].lower()
+
+
+@unique
+class INS(IntEnum):  # noqa: N801
+    VERIFY = 0x20
+    CHANGE_PIN = 0x24
+    RESET_RETRY_COUNTER = 0x2C
+    PSO = 0x2A
+    ACTIVATE = 0x44
+    GENERATE_ASYM = 0x47
+    GET_CHALLENGE = 0x84
+    INTERNAL_AUTHENTICATE = 0x88
+    SELECT_DATA = 0xA5
+    GET_DATA = 0xCA
+    PUT_DATA = 0xDA
+    PUT_DATA_ODD = 0xDB
+    TERMINATE = 0xE6
+    GET_VERSION = 0xF1
+    SET_PIN_RETRIES = 0xF2
+    GET_ATTESTATION = 0xFB
+
+
+_INVALID_PIN = b"\0" * 8
+
+
+TAG_DISCRETIONARY = 0x73
+TAG_EXTENDED_CAPABILITIES = 0xC0
+TAG_FINGERPRINTS = 0xC5
+TAG_CA_FINGERPRINTS = 0xC6
+TAG_GENERATION_TIMES = 0xCD
+TAG_SIGNATURE_COUNTER = 0x93
+TAG_KEY_INFORMATION = 0xDE
+TAG_PUBLIC_KEY = 0x7F49
+
+
+@unique
+class PW(IntEnum):
+    USER = 0x81
+    RESET = 0x82
+    ADMIN = 0x83
+
+
+@unique
+class DO(IntEnum):
+    PRIVATE_USE_1 = 0x0101
+    PRIVATE_USE_2 = 0x0102
+    PRIVATE_USE_3 = 0x0103
+    PRIVATE_USE_4 = 0x0104
+    AID = 0x4F
+    NAME = 0x5B
+    LOGIN_DATA = 0x5E
+    LANGUAGE = 0xEF2D
+    SEX = 0x5F35
+    URL = 0x5F50
+    HISTORICAL_BYTES = 0x5F52
+    EXTENDED_LENGTH_INFO = 0x7F66
+    GENERAL_FEATURE_MANAGEMENT = 0x7F74
+    CARDHOLDER_RELATED_DATA = 0x65
+    APPLICATION_RELATED_DATA = 0x6E
+    ALGORITHM_ATTRIBUTES_SIG = 0xC1
+    ALGORITHM_ATTRIBUTES_DEC = 0xC2
+    ALGORITHM_ATTRIBUTES_AUT = 0xC3
+    ALGORITHM_ATTRIBUTES_ATT = 0xDA
+    PW_STATUS_BYTES = 0xC4
+    FINGERPRINT_SIG = 0xC7
+    FINGERPRINT_DEC = 0xC8
+    FINGERPRINT_AUT = 0xC9
+    FINGERPRINT_ATT = 0xDB
+    CA_FINGERPRINT_1 = 0xCA
+    CA_FINGERPRINT_2 = 0xCB
+    CA_FINGERPRINT_3 = 0xCC
+    CA_FINGERPRINT_4 = 0xDC
+    GENERATION_TIME_SIG = 0xCE
+    GENERATION_TIME_DEC = 0xCF
+    GENERATION_TIME_AUT = 0xD0
+    GENERATION_TIME_ATT = 0xDD
+    RESETTING_CODE = 0xD3
+    UIF_SIG = 0xD6
+    UIF_DEC = 0xD7
+    UIF_AUT = 0xD8
+    UIF_ATT = 0xD9
+    SECURITY_SUPPORT_TEMPLATE = 0x7A
+    CARDHOLDER_CERTIFICATE = 0x7F21
+    KDF = 0xF9
+    ALGORITHM_INFORMATION = 0xFA
+    ATT_CERTIFICATE = 0xFC
+
+
+def _bcd(value: int) -> int:
+    return 10 * (value >> 4) + (value & 0xF)
+
+
+class OpenPgpAid(bytes):
+    """OpenPGP Application Identifier (AID)
+
+    The OpenPGP AID is a string of bytes identifying the OpenPGP application.
+    It also embeds some values which are accessible though properties.
+    """
+
+    @property
+    def version(self) -> Tuple[int, int]:
+        """OpenPGP version (tuple of 2 integers: main version, seconday version)."""
+        return (_bcd(self[6]), _bcd(self[7]))
+
+    @property
+    def manufacturer(self) -> int:
+        """16-bit integer value identifying the manufacturer of the device.
+
+        This should be 6 for Yubico devices.
+        """
+        return bytes2int(self[8:10])
+
+    @property
+    def serial(self) -> int:
+        """The serial number of the YubiKey.
+
+        NOTE: This value is encoded in BCD. In the event of an invalid value (hex A-F)
+        the entire 4 byte value will instead be decoded as an unsigned integer,
+        and negated.
+        """
+        try:
+            return int(self[10:14].hex())
+        except ValueError:
+            # Not valid BCD, treat as an unsigned integer, and return a negative value
+            return -struct.unpack(">I", self[10:14])[0]
+
+
+@unique
+class EXTENDED_CAPABILITY_FLAGS(IntFlag):
+    KDF = 1 << 0
+    PSO_DEC_ENC_AES = 1 << 1
+    ALGORITHM_ATTRIBUTES_CHANGEABLE = 1 << 2
+    PRIVATE_USE = 1 << 3
+    PW_STATUS_CHANGEABLE = 1 << 4
+    KEY_IMPORT = 1 << 5
+    GET_CHALLENGE = 1 << 6
+    SECURE_MESSAGING = 1 << 7
+
+
+@dataclass
+class CardholderRelatedData:
+    name: bytes
+    language: bytes
+    sex: int
+
+    @classmethod
+    def parse(cls, encoded) -> "CardholderRelatedData":
+        data = Tlv.parse_dict(Tlv.unpack(DO.CARDHOLDER_RELATED_DATA, encoded))
+        return cls(
+            data[DO.NAME],
+            data[DO.LANGUAGE],
+            data[DO.SEX][0],
+        )
+
+
+@dataclass
+class ExtendedLengthInfo:
+    request_max_bytes: int
+    response_max_bytes: int
+
+    @classmethod
+    def parse(cls, encoded) -> "ExtendedLengthInfo":
+        data = Tlv.parse_list(encoded)
+        return cls(
+            bytes2int(Tlv.unpack(0x02, data[0])),
+            bytes2int(Tlv.unpack(0x02, data[1])),
+        )
+
+
+@unique
+class GENERAL_FEATURE_MANAGEMENT(IntFlag):
+    TOUCHSCREEN = 1 << 0
+    MICROPHONE = 1 << 1
+    LOUDSPEAKER = 1 << 2
+    LED = 1 << 3
+    KEYPAD = 1 << 4
+    BUTTON = 1 << 5
+    BIOMETRIC = 1 << 6
+    DISPLAY = 1 << 7
+
+
+@dataclass
+class ExtendedCapabilities:
+    flags: EXTENDED_CAPABILITY_FLAGS
+    sm_algorithm: int
+    challenge_max_length: int
+    certificate_max_length: int
+    special_do_max_length: int
+    pin_block_2_format: bool
+    mse_command: bool
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "ExtendedCapabilities":
+        return cls(
+            EXTENDED_CAPABILITY_FLAGS(encoded[0]),
+            encoded[1],
+            bytes2int(encoded[2:4]),
+            bytes2int(encoded[4:6]),
+            bytes2int(encoded[6:8]),
+            encoded[8] == 1,
+            encoded[9] == 1,
+        )
+
+
+@dataclass
+class PwStatus:
+    pin_policy_user: PIN_POLICY
+    max_len_user: int
+    max_len_reset: int
+    max_len_admin: int
+    attempts_user: int
+    attempts_reset: int
+    attempts_admin: int
+
+    def get_max_len(self, pw: PW) -> int:
+        return getattr(self, f"max_len_{pw.name.lower()}")
+
+    def get_attempts(self, pw: PW) -> int:
+        return getattr(self, f"attempts_{pw.name.lower()}")
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "PwStatus":
+        try:
+            policy = PIN_POLICY(encoded[0])
+        except ValueError:
+            policy = PIN_POLICY.ONCE
+        return cls(
+            policy,
+            encoded[1],
+            encoded[2],
+            encoded[3],
+            encoded[4],
+            encoded[5],
+            encoded[6],
+        )
+
+
+@unique
+class CRT(bytes, Enum):
+    SIG = Tlv(0xB6)
+    DEC = Tlv(0xB8)
+    AUT = Tlv(0xA4)
+    ATT = Tlv(0xB6, Tlv(0x84, b"\x81"))
+
+
+@unique
+class KEY_REF(IntEnum):  # noqa: N801
+    SIG = 0x01
+    DEC = 0x02
+    AUT = 0x03
+    ATT = 0x81
+
+    @property
+    def algorithm_attributes_do(self) -> DO:
+        return getattr(DO, f"ALGORITHM_ATTRIBUTES_{self.name}")
+
+    @property
+    def uif_do(self) -> DO:
+        return getattr(DO, f"UIF_{self.name}")
+
+    @property
+    def generation_time_do(self) -> DO:
+        return getattr(DO, f"GENERATION_TIME_{self.name}")
+
+    @property
+    def fingerprint_do(self) -> DO:
+        return getattr(DO, f"FINGERPRINT_{self.name}")
+
+    @property
+    def crt(self) -> CRT:
+        return getattr(CRT, self.name)
+
+
+@unique
+class KEY_STATUS(IntEnum):
+    NONE = 0
+    GENERATED = 1
+    IMPORTED = 2
+
+
+KeyInformation = Mapping[KEY_REF, KEY_STATUS]
+Fingerprints = Mapping[KEY_REF, bytes]
+GenerationTimes = Mapping[KEY_REF, int]
+EcPublicKey = Union[
+    ec.EllipticCurvePublicKey,
+    ed25519.Ed25519PublicKey,
+    x25519.X25519PublicKey,
+]
+PublicKey = Union[EcPublicKey, rsa.RSAPublicKey]
+EcPrivateKey = Union[
+    ec.EllipticCurvePrivateKeyWithSerialization,
+    ed25519.Ed25519PrivateKey,
+    x25519.X25519PrivateKey,
+]
+PrivateKey = Union[
+    rsa.RSAPrivateKeyWithSerialization,
+    EcPrivateKey,
+]
+
+
+# mypy doesn't handle abstract dataclasses well
+@dataclass  # type: ignore[misc]
+class AlgorithmAttributes(abc.ABC):
+    _supported_ids: ClassVar[Sequence[int]]
+    algorithm_id: int
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "AlgorithmAttributes":
+        algorithm_id = encoded[0]
+        for sub_cls in cls.__subclasses__():
+            if algorithm_id in sub_cls._supported_ids:
+                return sub_cls._parse_data(algorithm_id, encoded[1:])
+        raise ValueError("Unsupported algorithm ID")
+
+    @abc.abstractmethod
+    def __bytes__(self) -> bytes:
+        raise NotImplementedError()
+
+    @classmethod
+    @abc.abstractmethod
+    def _parse_data(cls, alg: int, encoded: bytes) -> "AlgorithmAttributes":
+        raise NotImplementedError()
+
+
+@unique
+class RSA_SIZE(IntEnum):
+    RSA2048 = 2048
+    RSA3072 = 3072
+    RSA4096 = 4096
+
+
+@unique
+class RSA_IMPORT_FORMAT(IntEnum):
+    STANDARD = 0
+    STANDARD_W_MOD = 1
+    CRT = 2
+    CRT_W_MOD = 3
+
+
+@dataclass
+class RsaAttributes(AlgorithmAttributes):
+    _supported_ids = [0x01]
+
+    n_len: int
+    e_len: int
+    import_format: RSA_IMPORT_FORMAT
+
+    @classmethod
+    def create(
+        cls,
+        n_len: RSA_SIZE,
+        import_format: RSA_IMPORT_FORMAT = RSA_IMPORT_FORMAT.STANDARD,
+    ) -> "RsaAttributes":
+        return cls(0x01, n_len, 17, import_format)
+
+    @classmethod
+    def _parse_data(cls, alg, encoded) -> "RsaAttributes":
+        n, e, f = struct.unpack(">HHB", encoded)
+        return cls(alg, n, e, RSA_IMPORT_FORMAT(f))
+
+    def __bytes__(self) -> bytes:
+        return struct.pack(
+            ">BHHB", self.algorithm_id, self.n_len, self.e_len, self.import_format
+        )
+
+
+class CurveOid(bytes):
+    def _get_name(self) -> str:
+        for oid in OID:
+            if self.startswith(oid):
+                return oid.name
+        return "Unknown Curve"
+
+    def __str__(self) -> str:
+        return self._get_name()
+
+    def __repr__(self) -> str:
+        name = self._get_name()
+        return f"{name}({self.hex()})"
+
+
+class OID(CurveOid, Enum):
+    SECP256R1 = CurveOid(b"\x2a\x86\x48\xce\x3d\x03\x01\x07")
+    SECP256K1 = CurveOid(b"\x2b\x81\x04\x00\x0a")
+    SECP384R1 = CurveOid(b"\x2b\x81\x04\x00\x22")
+    SECP521R1 = CurveOid(b"\x2b\x81\x04\x00\x23")
+    BrainpoolP256R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x07")
+    BrainpoolP384R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x0b")
+    BrainpoolP512R1 = CurveOid(b"\x2b\x24\x03\x03\x02\x08\x01\x01\x0d")
+    X25519 = CurveOid(b"\x2b\x06\x01\x04\x01\x97\x55\x01\x05\x01")
+    Ed25519 = CurveOid(b"\x2b\x06\x01\x04\x01\xda\x47\x0f\x01")
+
+    @classmethod
+    def _from_key(cls, private_key: EcPrivateKey) -> CurveOid:
+        name = ""
+        if isinstance(private_key, ec.EllipticCurvePrivateKey):
+            name = private_key.curve.name.lower()
+        else:
+            if isinstance(private_key, ed25519.Ed25519PrivateKey):
+                name = "ed25519"
+            elif isinstance(private_key, x25519.X25519PrivateKey):
+                name = "x25519"
+        for oid in cls:
+            if oid.name.lower() == name:
+                return oid
+        raise ValueError("Unsupported private key")
+
+    def __repr__(self) -> str:
+        return repr(self.value)
+
+    def __str__(self) -> str:
+        return str(self.value)
+
+
+@unique
+class EC_IMPORT_FORMAT(IntEnum):
+    STANDARD = 0
+    STANDARD_W_PUBKEY = 0xFF
+
+
+@dataclass
+class EcAttributes(AlgorithmAttributes):
+    _supported_ids = [0x12, 0x13, 0x16]
+
+    oid: CurveOid
+    import_format: EC_IMPORT_FORMAT
+
+    @classmethod
+    def create(cls, key_ref: KEY_REF, oid: CurveOid) -> "EcAttributes":
+        if oid == OID.Ed25519:
+            alg = 0x16  # EdDSA
+        elif key_ref == KEY_REF.DEC:
+            alg = 0x12  # ECDH
+        else:
+            alg = 0x13  # ECDSA
+        return cls(alg, oid, EC_IMPORT_FORMAT.STANDARD)
+
+    @classmethod
+    def _parse_data(cls, alg, encoded) -> "EcAttributes":
+        if encoded[-1] == 0xFF:
+            f = EC_IMPORT_FORMAT.STANDARD_W_PUBKEY
+            oid = encoded[:-1]
+        else:  # Standard is defined as "format byte not present"
+            f = EC_IMPORT_FORMAT.STANDARD
+            oid = encoded
+
+        return cls(alg, CurveOid(oid), f)
+
+    def __bytes__(self) -> bytes:
+        buf = struct.pack(">B", self.algorithm_id) + self.oid
+        if self.import_format == EC_IMPORT_FORMAT.STANDARD_W_PUBKEY:
+            buf += struct.pack(">B", self.import_format)
+        return buf
+
+
+def _parse_key_information(encoded: bytes) -> KeyInformation:
+    return {
+        KEY_REF(encoded[i]): KEY_STATUS(encoded[i + 1])
+        for i in range(0, len(encoded), 2)
+    }
+
+
+def _parse_fingerprints(encoded: bytes) -> Fingerprints:
+    slots = list(KEY_REF)
+    return {
+        slots[i]: encoded[o : o + 20] for i, o in enumerate(range(0, len(encoded), 20))
+    }
+
+
+def _parse_timestamps(encoded: bytes) -> GenerationTimes:
+    slots = list(KEY_REF)
+    return {
+        slots[i]: bytes2int(encoded[o : o + 4])
+        for i, o in enumerate(range(0, len(encoded), 4))
+    }
+
+
+@dataclass
+class DiscretionaryDataObjects:
+    extended_capabilities: ExtendedCapabilities
+    attributes_sig: AlgorithmAttributes
+    attributes_dec: AlgorithmAttributes
+    attributes_aut: AlgorithmAttributes
+    attributes_att: Optional[AlgorithmAttributes]
+    pw_status: PwStatus
+    fingerprints: Fingerprints
+    ca_fingerprints: Fingerprints
+    generation_times: GenerationTimes
+    key_information: KeyInformation
+    uif_sig: Optional[UIF]
+    uif_dec: Optional[UIF]
+    uif_aut: Optional[UIF]
+    uif_att: Optional[UIF]
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "DiscretionaryDataObjects":
+        data = Tlv.parse_dict(encoded)
+        return cls(
+            ExtendedCapabilities.parse(data[TAG_EXTENDED_CAPABILITIES]),
+            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_SIG]),
+            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_DEC]),
+            AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_AUT]),
+            (
+                AlgorithmAttributes.parse(data[DO.ALGORITHM_ATTRIBUTES_ATT])
+                if DO.ALGORITHM_ATTRIBUTES_ATT in data
+                else None
+            ),
+            PwStatus.parse(data[DO.PW_STATUS_BYTES]),
+            _parse_fingerprints(data[TAG_FINGERPRINTS]),
+            _parse_fingerprints(data[TAG_CA_FINGERPRINTS]),
+            _parse_timestamps(data[TAG_GENERATION_TIMES]),
+            _parse_key_information(data.get(TAG_KEY_INFORMATION, b"")),
+            (UIF.parse(data[DO.UIF_SIG]) if DO.UIF_SIG in data else None),
+            (UIF.parse(data[DO.UIF_DEC]) if DO.UIF_DEC in data else None),
+            (UIF.parse(data[DO.UIF_AUT]) if DO.UIF_AUT in data else None),
+            (UIF.parse(data[DO.UIF_ATT]) if DO.UIF_ATT in data else None),
+        )
+
+    def get_algorithm_attributes(self, key_ref: KEY_REF) -> AlgorithmAttributes:
+        return getattr(self, f"attributes_{key_ref.name.lower()}")
+
+
+@dataclass
+class ApplicationRelatedData:
+    aid: OpenPgpAid
+    historical: bytes
+    extended_length_info: Optional[ExtendedLengthInfo]
+    general_feature_management: Optional[GENERAL_FEATURE_MANAGEMENT]
+    discretionary: DiscretionaryDataObjects
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "ApplicationRelatedData":
+        outer = Tlv.unpack(DO.APPLICATION_RELATED_DATA, encoded)
+        data = Tlv.parse_dict(outer)
+        return cls(
+            OpenPgpAid(data[DO.AID]),
+            data[DO.HISTORICAL_BYTES],
+            (
+                ExtendedLengthInfo.parse(data[DO.EXTENDED_LENGTH_INFO])
+                if DO.EXTENDED_LENGTH_INFO in data
+                else None
+            ),
+            (
+                GENERAL_FEATURE_MANAGEMENT(
+                    Tlv.unpack(0x81, data[DO.GENERAL_FEATURE_MANAGEMENT])[0]
+                )
+                if DO.GENERAL_FEATURE_MANAGEMENT in data
+                else None
+            ),
+            # Older keys have data in outer dict
+            DiscretionaryDataObjects.parse(data[TAG_DISCRETIONARY] or outer),
+        )
+
+
+@dataclass
+class SecuritySupportTemplate:
+    signature_counter: int
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "SecuritySupportTemplate":
+        data = Tlv.parse_dict(Tlv.unpack(DO.SECURITY_SUPPORT_TEMPLATE, encoded))
+        return cls(bytes2int(data[TAG_SIGNATURE_COUNTER]))
+
+
+# mypy doesn't handle abstract dataclasses well
+@dataclass  # type: ignore[misc]
+class Kdf(abc.ABC):
+    algorithm: ClassVar[int]
+
+    @abc.abstractmethod
+    def process(self, pin: str, pw: PW) -> bytes:
+        """Runs the KDF on the input PIN."""
+
+    @classmethod
+    @abc.abstractmethod
+    def _parse_data(cls, data: Mapping[int, bytes]) -> "Kdf":
+        raise NotImplementedError()
+
+    @classmethod
+    def parse(cls, encoded: bytes) -> "Kdf":
+        data = Tlv.parse_dict(encoded)
+        try:
+            algorithm = bytes2int(data[0x81])
+            for sub in cls.__subclasses__():
+                if sub.algorithm == algorithm:
+                    return sub._parse_data(data)
+        except KeyError:
+            pass  # Fall though to KdfNone
+        return KdfNone()
+
+    @abc.abstractmethod
+    def __bytes__(self) -> bytes:
+        raise NotImplementedError()
+
+
+@dataclass
+class KdfNone(Kdf):
+    algorithm = 0
+
+    @classmethod
+    def _parse_data(cls, data) -> "KdfNone":
+        return cls()
+
+    def process(self, pw, pin):
+        return pin.encode()
+
+    def __bytes__(self):
+        return Tlv(0x81, struct.pack(">B", self.algorithm))
+
+
+@unique
+class HASH_ALGORITHM(IntEnum):
+    SHA256 = 0x08
+    SHA512 = 0x0A
+
+    def create_digest(self):
+        algorithm = getattr(hashes, self.name)
+        return hashes.Hash(algorithm(), default_backend())
+
+
+@dataclass
+class KdfIterSaltedS2k(Kdf):
+    algorithm = 3
+
+    hash_algorithm: HASH_ALGORITHM
+    iteration_count: int
+    salt_user: bytes
+    salt_reset: bytes
+    salt_admin: bytes
+    initial_hash_user: Optional[bytes]
+    initial_hash_admin: Optional[bytes]
+
+    @staticmethod
+    def _do_process(hash_algorithm, iteration_count, data):
+        # Although the field is called "iteration count", it's actually
+        # the number of bytes to be passed to the hash function, which
+        # is called only once. Go figure!
+        data_count, trailing_bytes = divmod(iteration_count, len(data))
+        digest = hash_algorithm.create_digest()
+        for _ in range(data_count):
+            digest.update(data)
+        digest.update(data[:trailing_bytes])
+        return digest.finalize()
+
+    @classmethod
+    def create(
+        cls,
+        hash_algorithm: HASH_ALGORITHM = HASH_ALGORITHM.SHA256,
+        iteration_count: int = 0x780000,
+    ) -> "KdfIterSaltedS2k":
+        salt_user = os.urandom(8)
+        salt_admin = os.urandom(8)
+        return cls(
+            hash_algorithm,
+            iteration_count,
+            salt_user,
+            os.urandom(8),
+            salt_admin,
+            cls._do_process(
+                hash_algorithm, iteration_count, salt_user + DEFAULT_USER_PIN.encode()
+            ),
+            cls._do_process(
+                hash_algorithm, iteration_count, salt_admin + DEFAULT_ADMIN_PIN.encode()
+            ),
+        )
+
+    @classmethod
+    def _parse_data(cls, data) -> "KdfIterSaltedS2k":
+        return cls(
+            HASH_ALGORITHM(bytes2int(data[0x82])),
+            bytes2int(data[0x83]),
+            data[0x84],
+            data.get(0x85),
+            data.get(0x86),
+            data.get(0x87),
+            data.get(0x88),
+        )
+
+    def get_salt(self, pw: PW) -> bytes:
+        return getattr(self, f"salt_{pw.name.lower()}")
+
+    def process(self, pw, pin):
+        salt = self.get_salt(pw) or self.salt_user
+        data = salt + pin.encode()
+        return self._do_process(self.hash_algorithm, self.iteration_count, data)
+
+    def __bytes__(self):
+        return (
+            Tlv(0x81, struct.pack(">B", self.algorithm))
+            + Tlv(0x82, struct.pack(">B", self.hash_algorithm))
+            + Tlv(0x83, struct.pack(">I", self.iteration_count))
+            + Tlv(0x84, self.salt_user)
+            + (Tlv(0x85, self.salt_reset) if self.salt_reset else b"")
+            + (Tlv(0x86, self.salt_admin) if self.salt_admin else b"")
+            + (Tlv(0x87, self.initial_hash_user) if self.initial_hash_user else b"")
+            + (Tlv(0x88, self.initial_hash_admin) if self.initial_hash_admin else b"")
+        )
+
+
+# mypy doesn't handle abstract dataclasses well
+@dataclass  # type: ignore[misc]
+class PrivateKeyTemplate(abc.ABC):
+    crt: CRT
+
+    def _get_template(self) -> Sequence[Tlv]:
+        raise NotImplementedError()
+
+    def __bytes__(self) -> bytes:
+        tlvs = self._get_template()
+        return Tlv(
+            0x4D,
+            self.crt
+            + Tlv(0x7F48, b"".join(tlv[: -tlv.length] for tlv in tlvs))
+            + Tlv(0x5F48, b"".join(tlv.value for tlv in tlvs)),
+        )
+
+
+@dataclass
+class RsaKeyTemplate(PrivateKeyTemplate):
+    e: bytes
+    p: bytes
+    q: bytes
+
+    def _get_template(self):
+        return (
+            Tlv(0x91, self.e),
+            Tlv(0x92, self.p),
+            Tlv(0x93, self.q),
+        )
+
+
+@dataclass
+class RsaCrtKeyTemplate(RsaKeyTemplate):
+    iqmp: bytes
+    dmp1: bytes
+    dmq1: bytes
+    n: bytes
+
+    def _get_template(self):
+        return (
+            *super()._get_template(),
+            Tlv(0x94, self.iqmp),
+            Tlv(0x95, self.dmp1),
+            Tlv(0x96, self.dmq1),
+            Tlv(0x97, self.n),
+        )
+
+
+@dataclass
+class EcKeyTemplate(PrivateKeyTemplate):
+    private_key: bytes
+    public_key: Optional[bytes]
+
+    def _get_template(self):
+        tlvs: Tuple[Tlv, ...] = (Tlv(0x92, self.private_key),)
+        if self.public_key:
+            tlvs = (*tlvs, Tlv(0x99, self.public_key))
+
+        return tlvs
+
+
+def _get_key_attributes(
+    private_key: PrivateKey, key_ref: KEY_REF, version: Version
+) -> AlgorithmAttributes:
+    if isinstance(private_key, rsa.RSAPrivateKeyWithSerialization):
+        if private_key.private_numbers().public_numbers.e != 65537:
+            raise ValueError("RSA keys with e != 65537 are not supported!")
+        return RsaAttributes.create(
+            RSA_SIZE(private_key.key_size),
+            RSA_IMPORT_FORMAT.CRT_W_MOD
+            if version < (4, 0, 0)
+            else RSA_IMPORT_FORMAT.STANDARD,
+        )
+    return EcAttributes.create(key_ref, OID._from_key(private_key))
+
+
+def _get_key_template(
+    private_key: PrivateKey, key_ref: KEY_REF, use_crt: bool = False
+) -> PrivateKeyTemplate:
+    if isinstance(private_key, rsa.RSAPrivateKeyWithSerialization):
+        rsa_numbers = private_key.private_numbers()
+        ln = (private_key.key_size // 8) // 2
+
+        e = b"\x01\x00\x01"  # e=65537
+        p = int2bytes(rsa_numbers.p, ln)
+        q = int2bytes(rsa_numbers.q, ln)
+        if not use_crt:
+            return RsaKeyTemplate(key_ref.crt, e, p, q)
+        else:
+            dp = int2bytes(rsa_numbers.dmp1, ln)
+            dq = int2bytes(rsa_numbers.dmq1, ln)
+            qinv = int2bytes(rsa_numbers.iqmp, ln)
+            n = int2bytes(rsa_numbers.public_numbers.n, 2 * ln)
+            return RsaCrtKeyTemplate(key_ref.crt, e, p, q, qinv, dp, dq, n)
+
+    elif isinstance(private_key, ec.EllipticCurvePrivateKeyWithSerialization):
+        ec_numbers = private_key.private_numbers()
+        ln = private_key.key_size // 8
+        return EcKeyTemplate(key_ref.crt, int2bytes(ec_numbers.private_value, ln), None)
+
+    elif isinstance(private_key, (ed25519.Ed25519PrivateKey, x25519.X25519PrivateKey)):
+        pkb = private_key.private_bytes(Encoding.Raw, PrivateFormat.Raw, NoEncryption())
+        if isinstance(private_key, x25519.X25519PrivateKey):
+            pkb = pkb[::-1]  # byte order needs to be reversed
+        return EcKeyTemplate(
+            key_ref.crt,
+            pkb,
+            None,
+        )
+
+    raise ValueError("Unsupported key type")
+
+
+def _parse_rsa_key(data: Mapping[int, bytes]) -> rsa.RSAPublicKey:
+    numbers = rsa.RSAPublicNumbers(bytes2int(data[0x82]), bytes2int(data[0x81]))
+    return numbers.public_key(default_backend())
+
+
+def _parse_ec_key(oid: CurveOid, data: Mapping[int, bytes]) -> EcPublicKey:
+    pubkey_enc = data[0x86]
+    if oid == OID.X25519:
+        return x25519.X25519PublicKey.from_public_bytes(pubkey_enc)
+    if oid == OID.Ed25519:
+        return ed25519.Ed25519PublicKey.from_public_bytes(pubkey_enc)
+
+    curve = getattr(ec, oid._get_name())
+    return ec.EllipticCurvePublicKey.from_encoded_point(curve(), pubkey_enc)
+
+
+_pkcs1v15_headers = {
+    hashes.MD5: bytes.fromhex("3020300C06082A864886F70D020505000410"),
+    hashes.SHA1: bytes.fromhex("3021300906052B0E03021A05000414"),
+    hashes.SHA224: bytes.fromhex("302D300D06096086480165030402040500041C"),
+    hashes.SHA256: bytes.fromhex("3031300D060960864801650304020105000420"),
+    hashes.SHA384: bytes.fromhex("3041300D060960864801650304020205000430"),
+    hashes.SHA512: bytes.fromhex("3051300D060960864801650304020305000440"),
+    hashes.SHA512_224: bytes.fromhex("302D300D06096086480165030402050500041C"),
+    hashes.SHA512_256: bytes.fromhex("3031300D060960864801650304020605000420"),
+}
+
+
+def _pad_message(attributes, message, hash_algorithm):
+    if attributes.algorithm_id == 0x16:  # EdDSA, never hash
+        return message
+
+    if isinstance(hash_algorithm, Prehashed):
+        hashed = message
+    else:
+        h = hashes.Hash(hash_algorithm, default_backend())
+        h.update(message)
+        hashed = h.finalize()
+
+    if isinstance(attributes, EcAttributes):
+        return hashed
+    if isinstance(attributes, RsaAttributes):
+        try:
+            return _pkcs1v15_headers[type(hash_algorithm)] + hashed
+        except KeyError:
+            raise ValueError(f"Unsupported hash algorithim for RSA: {hash_algorithm}")
+
+
+class OpenPgpSession:
+    def __init__(self, connection: SmartCardConnection):
+        self.protocol = SmartCardProtocol(connection)
+        try:
+            self.protocol.select(AID.OPENPGP)
+        except ApduError as e:
+            if e.sw in (SW.NO_INPUT_DATA, SW.CONDITIONS_NOT_SATISFIED):
+                # Not activated, activate
+                logger.warning("Application not active, sending ACTIVATE")
+                self.protocol.send_apdu(0, INS.ACTIVATE, 0, 0)
+                self.protocol.select(AID.OPENPGP)
+            else:
+                raise
+        self._version = self._read_version()
+
+        self.protocol.enable_touch_workaround(self.version)
+        if self.version >= (4, 0, 0):
+            self.protocol.apdu_format = ApduFormat.EXTENDED
+
+        # Note: This value is cached!
+        # Do not rely on contained information that can change!
+        self._app_data = self.get_application_related_data()
+        logger.debug(f"OpenPGP session initialized (version={self.version})")
+
+    def _read_version(self) -> Version:
+        logger.debug("Getting version number")
+        bcd = self.protocol.send_apdu(0, INS.GET_VERSION, 0, 0)
+        return Version(*(_bcd(x) for x in bcd))
+
+    @property
+    def aid(self) -> OpenPgpAid:
+        """Get the AID used to select the applet."""
+        return self._app_data.aid
+
+    @property
+    def version(self) -> Version:
+        """Get the firmware version of the key.
+
+        For YubiKey NEO this is the PGP applet version.
+        """
+        return self._version
+
+    @property
+    def extended_capabilities(self) -> ExtendedCapabilities:
+        """Get the Extended Capabilities from the YubiKey."""
+        return self._app_data.discretionary.extended_capabilities
+
+    def get_challenge(self, length: int) -> bytes:
+        """Get random data from the YubiKey."""
+        e = self.extended_capabilities
+        if EXTENDED_CAPABILITY_FLAGS.GET_CHALLENGE not in e.flags:
+            raise NotSupportedError("GET_CHALLENGE is not supported")
+        if not 0 < length <= e.challenge_max_length:
+            raise NotSupportedError("Unsupported challenge length")
+
+        logger.debug(f"Getting {length} random bytes")
+        return self.protocol.send_apdu(0, INS.GET_CHALLENGE, 0, 0, le=length)
+
+    def get_data(self, do: DO) -> bytes:
+        """Get a Data Object from the YubiKey."""
+        logger.debug(f"Reading Data Object {do.name} ({do:X})")
+        return self.protocol.send_apdu(0, INS.GET_DATA, do >> 8, do & 0xFF)
+
+    def put_data(self, do: DO, data: Union[bytes, SupportsBytes]) -> None:
+        """Write a Data Object to the YubiKey."""
+        self.protocol.send_apdu(0, INS.PUT_DATA, do >> 8, do & 0xFF, bytes(data))
+        logger.info(f"Wrote Data Object {do.name} ({do:X})")
+
+    def get_pin_status(self) -> PwStatus:
+        """Get the current status of PINS."""
+        return PwStatus.parse(self.get_data(DO.PW_STATUS_BYTES))
+
+    def get_signature_counter(self) -> int:
+        """Get the number of times the signature key has been used."""
+        s = SecuritySupportTemplate.parse(self.get_data(DO.SECURITY_SUPPORT_TEMPLATE))
+        return s.signature_counter
+
+    def get_application_related_data(self) -> ApplicationRelatedData:
+        """Read the Application Related Data."""
+        return ApplicationRelatedData.parse(self.get_data(DO.APPLICATION_RELATED_DATA))
+
+    def set_signature_pin_policy(self, pin_policy: PIN_POLICY) -> None:
+        """Requires Admin PIN verification."""
+        logger.debug(f"Setting Signature PIN policy to {pin_policy}")
+        data = struct.pack(">B", pin_policy)
+        self.put_data(DO.PW_STATUS_BYTES, data)
+        logger.info("Signature PIN policy set")
+
+    def reset(self) -> None:
+        """Performs a factory reset on the OpenPGP application.
+
+        WARNING: This will delete all stored keys, certificates and other data.
+        """
+        require_version(self.version, (1, 0, 6))
+        logger.debug("Preparing OpenPGP reset")
+
+        # Ensure the User and Admin PINs are blocked
+        status = self.get_pin_status()
+        for pw in (PW.USER, PW.ADMIN):
+            logger.debug(f"Verify {pw.name} PIN with invalid attempts until blocked")
+            for _ in range(status.get_attempts(pw)):
+                try:
+                    self.protocol.send_apdu(0, INS.VERIFY, 0, pw, _INVALID_PIN)
+                except ApduError:
+                    pass
+
+        # Reset the application
+        logger.debug("Sending TERMINATE, then ACTIVATE")
+        self.protocol.send_apdu(0, INS.TERMINATE, 0, 0)
+        self.protocol.send_apdu(0, INS.ACTIVATE, 0, 0)
+
+        logger.info("OpenPGP application data reset performed")
+
+    def set_pin_attempts(
+        self, user_attempts: int, reset_attempts: int, admin_attempts: int
+    ) -> None:
+        """Set the number of PIN attempts to allow before blocking.
+
+        WARNING: On YubiKey NEO this will reset the PINs to their default values.
+
+        Requires Admin PIN verification.
+        """
+        if self.version[0] == 1:
+            # YubiKey NEO
+            require_version(self.version, (1, 0, 7))
+        else:
+            require_version(self.version, (4, 3, 1))
+
+        attempts = (user_attempts, reset_attempts, admin_attempts)
+        logger.debug(f"Setting PIN attempts to {attempts}")
+        self.protocol.send_apdu(
+            0,
+            INS.SET_PIN_RETRIES,
+            0,
+            0,
+            struct.pack(">BBB", *attempts),
+        )
+        logger.info("Number of PIN attempts has been changed")
+
+    def get_kdf(self):
+        """Get the Key Derivation Function data object."""
+        if EXTENDED_CAPABILITY_FLAGS.KDF not in self.extended_capabilities.flags:
+            return KdfNone()
+        return Kdf.parse(self.get_data(DO.KDF))
+
+    def set_kdf(self, kdf: Kdf) -> None:
+        """Set up a PIN Key Derivation Function.
+
+        This enables (or disables) the use of a KDF for PIN verification, as well
+        as resetting the User and Admin PINs to their default (initial) values.
+
+        If a Reset Code is present, it will be invalidated.
+
+        This command requires Admin PIN verification.
+        """
+        e = self._app_data.discretionary.extended_capabilities
+        if EXTENDED_CAPABILITY_FLAGS.KDF not in e.flags:
+            raise NotSupportedError("KDF is not supported")
+
+        logger.debug(f"Setting PIN KDF to algorithm: {kdf.algorithm}")
+        self.put_data(DO.KDF, kdf)
+        logger.info("KDF settings changed")
+
+    def _verify(self, pw: PW, pin: str, mode: int = 0) -> None:
+        pin_enc = self.get_kdf().process(pw, pin)
+        try:
+            self.protocol.send_apdu(0, INS.VERIFY, 0, pw + mode, pin_enc)
+        except ApduError:
+            attempts = self.get_pin_status().get_attempts(pw)
+            raise ValueError(f"Invalid PIN, {attempts} tries remaining.")
+
+    def verify_pin(self, pin, extended: bool = False):
+        """Verify the User PIN.
+
+        This will unlock functionality that requires User PIN verification.
+        Note that with `extended=False` (default) only sign operations are allowed.
+        Inversely, with `extended=False` sign operations are NOT allowed.
+        """
+        logger.debug(f"Verifying User PIN in mode {'82' if extended else '81'}")
+        self._verify(PW.USER, pin, 1 if extended else 0)
+
+    def verify_admin(self, admin_pin):
+        """Verify the Admin PIN.
+
+        This will unlock functionality that requires Admin PIN verification.
+        """
+        logger.debug("Verifying Admin PIN")
+        self._verify(PW.ADMIN, admin_pin)
+
+    def unverify_pin(self, pw: PW) -> None:
+        require_version(self.version, (5, 6, 0))
+        logger.debug(f"Resetting verification for {pw.name} PIN")
+        self.protocol.send_apdu(0, INS.VERIFY, 0xFF, pw)
+
+    def _change(self, pw: PW, pin: str, new_pin: str) -> None:
+        logger.debug(f"Changing {pw.name} PIN")
+        kdf = self.get_kdf()
+        try:
+            self.protocol.send_apdu(
+                0,
+                INS.CHANGE_PIN,
+                0,
+                pw,
+                kdf.process(pw, pin) + kdf.process(pw, new_pin),
+            )
+        except ApduError as e:
+            if e.sw == SW.CONDITIONS_NOT_SATISFIED:
+                raise ValueError("Conditions of use not satisfied.")
+            else:
+                remaining = self.get_pin_status().get_attempts(pw)
+                raise ValueError(f"Invalid PIN, {remaining} tries remaining.")
+        logger.info(f"New {pw.name} PIN set")
+
+    def change_pin(self, pin: str, new_pin: str) -> None:
+        """Change the User PIN."""
+        self._change(PW.USER, pin, new_pin)
+
+    def change_admin(self, admin_pin: str, new_admin_pin: str) -> None:
+        """Change the Admin PIN."""
+        self._change(PW.ADMIN, admin_pin, new_admin_pin)
+
+    def set_reset_code(self, reset_code: str) -> None:
+        """Set the Reset Code for User PIN.
+
+        The Reset Code can be used to set a new User PIN if it is lost or becomes
+        blocked, using the reset_pin method.
+
+        This command requires Admin PIN verification.
+        """
+        logger.debug("Setting a new PIN Reset Code")
+        data = self.get_kdf().process(PW.RESET, reset_code)
+        self.put_data(DO.RESETTING_CODE, data)
+        logger.info("New Reset Code has been set")
+
+    def reset_pin(self, new_pin: str, reset_code: Optional[str] = None) -> None:
+        """Resets the User PIN to a new value.
+
+        This command requires Admin PIN verification, or the Reset Code.
+        """
+        logger.debug("Resetting User PIN")
+        p1 = 2
+        kdf = self.get_kdf()
+        data = kdf.process(PW.USER, new_pin)
+        if reset_code:
+            logger.debug("Using Reset Code")
+            data = kdf.process(PW.RESET, reset_code) + data
+            p1 = 0
+
+        try:
+            self.protocol.send_apdu(0, INS.RESET_RETRY_COUNTER, p1, PW.USER, data)
+        except ApduError as e:
+            if e.sw == SW.CONDITIONS_NOT_SATISFIED:
+                raise ValueError("Conditions of use not satisfied.")
+            else:
+                reset_remaining = self.get_pin_status().attempts_reset
+                raise ValueError(
+                    f"Invalid Reset Code, {reset_remaining} tries remaining."
+                )
+        logger.info("New User PIN has been set")
+
+    def get_algorithm_attributes(self, key_ref: KEY_REF) -> AlgorithmAttributes:
+        """Get the algorithm attributes for one of the key slots."""
+        logger.debug(f"Getting Algorithm Attributes for {key_ref.name}")
+        data = self.get_application_related_data()
+        return data.discretionary.get_algorithm_attributes(key_ref)
+
+    def get_algorithm_information(
+        self,
+    ) -> Mapping[KEY_REF, Sequence[AlgorithmAttributes]]:
+        """Get the list of supported algorithm attributes for each key.
+
+        The return value is a mapping of KEY_REF to a list of supported algorithm
+        attributes, which can be set using set_algorithm_attributes.
+        """
+        if (
+            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
+            not in self.extended_capabilities.flags
+        ):
+            raise NotSupportedError("Writing Algorithm Attributes is not supported")
+
+        if self.version < (5, 2, 0):
+            sizes = [RSA_SIZE.RSA2048]
+            if self.version < (4, 0, 0):  # Neo needs CRT
+                fmt = RSA_IMPORT_FORMAT.CRT_W_MOD
+            else:
+                fmt = RSA_IMPORT_FORMAT.STANDARD
+                if self.version[:2] != (4, 4):  # Non-FIPS
+                    sizes.extend([RSA_SIZE.RSA3072, RSA_SIZE.RSA4096])
+            return {
+                KEY_REF.SIG: [RsaAttributes.create(size, fmt) for size in sizes],
+                KEY_REF.DEC: [RsaAttributes.create(size, fmt) for size in sizes],
+                KEY_REF.AUT: [RsaAttributes.create(size, fmt) for size in sizes],
+            }
+
+        logger.debug("Getting supported Algorithm Information")
+        buf = self.get_data(DO.ALGORITHM_INFORMATION)
+        try:
+            buf = Tlv.unpack(DO.ALGORITHM_INFORMATION, buf)
+        except ValueError:
+            buf = Tlv.unpack(DO.ALGORITHM_INFORMATION, buf + b"\0\0")[:-2]
+
+        slots = {slot.algorithm_attributes_do: slot for slot in KEY_REF}
+        data: Dict[KEY_REF, List[AlgorithmAttributes]] = {}
+        for tlv in Tlv.parse_list(buf):
+            data.setdefault(slots[DO(tlv.tag)], []).append(
+                AlgorithmAttributes.parse(tlv.value)
+            )
+
+        if self.version < (5, 6, 1):
+            # Fix for invalid Curve25519 entries:
+            # Remove X25519 with EdDSA from all keys
+            invalid_x25519 = EcAttributes(0x16, OID.X25519, EC_IMPORT_FORMAT.STANDARD)
+            for values in data.values():
+                values.remove(invalid_x25519)
+            x25519 = EcAttributes(0x12, OID.X25519, EC_IMPORT_FORMAT.STANDARD)
+            # Add X25519 ECDH for DEC
+            if x25519 not in data[KEY_REF.DEC]:
+                data[KEY_REF.DEC].append(x25519)
+            # Remove EdDSA from DEC, ATT
+            ed25519_attr = EcAttributes(0x16, OID.Ed25519, EC_IMPORT_FORMAT.STANDARD)
+            data[KEY_REF.DEC].remove(ed25519_attr)
+            data[KEY_REF.ATT].remove(ed25519_attr)
+
+        return data
+
+    def set_algorithm_attributes(
+        self, key_ref: KEY_REF, attributes: AlgorithmAttributes
+    ) -> None:
+        """Sets the algorithm attributes for a key slot.
+
+        WARNING: This will delete any key already stored in the slot if the attributes
+        are changed!
+
+        This command requires Admin PIN verification.
+        """
+        logger.debug("Setting Algorithm Attributes for {key_ref.name}")
+        supported = self.get_algorithm_information()
+        if key_ref not in supported:
+            raise NotSupportedError("Key slot not supported")
+        if attributes not in supported[key_ref]:
+            raise NotSupportedError("Algorithm attributes not supported")
+
+        self.put_data(key_ref.algorithm_attributes_do, attributes)
+        logger.info("Algorithm Attributes have been changed")
+
+    def get_uif(self, key_ref: KEY_REF) -> UIF:
+        """Get the User Interaction Flag (touch requirement) for a key."""
+        try:
+            return UIF.parse(self.get_data(key_ref.uif_do))
+        except ApduError as e:
+            if e.sw == SW.WRONG_PARAMETERS_P1P2:
+                # Not supported
+                return UIF.OFF
+            raise
+
+    def set_uif(self, key_ref: KEY_REF, uif: UIF) -> None:
+        """Set the User Interaction Flag (touch requirement) for a key.
+
+        Requires Admin PIN verification.
+        """
+        require_version(self.version, (4, 2, 0))
+        if key_ref == KEY_REF.ATT:
+            require_version(
+                self.version,
+                (5, 2, 1),
+                "Attestation key requires YubiKey 5.2.1 or later.",
+            )
+        if uif.is_cached:
+            require_version(
+                self.version,
+                (5, 2, 1),
+                "Cached UIF values require YubiKey 5.2.1 or later.",
+            )
+
+        logger.debug(f"Setting UIF for {key_ref.name} to {uif.name}")
+        if self.get_uif(key_ref).is_fixed:
+            raise ValueError("Cannot change UIF when set to FIXED.")
+
+        self.put_data(key_ref.uif_do, uif)
+        logger.info(f"UIF changed for {key_ref.name}")
+
+    def get_key_information(self) -> KeyInformation:
+        """Get the status of the keys."""
+        logger.debug("Getting Key Information")
+        return self.get_application_related_data().discretionary.key_information
+
+    def get_generation_times(self) -> GenerationTimes:
+        """Get timestamps for when keys were generated."""
+        logger.debug("Getting key generation timestamps")
+        return self.get_application_related_data().discretionary.generation_times
+
+    def set_generation_time(self, key_ref: KEY_REF, timestamp: int) -> None:
+        """Set the generation timestamp for a key.
+
+        Requires Admin PIN verification.
+        """
+        logger.debug(f"Setting key generation timestamp for {key_ref.name}")
+        self.put_data(key_ref.generation_time_do, struct.pack(">I", timestamp))
+        logger.info(f"Key generation timestamp set for {key_ref.name}")
+
+    def get_fingerprints(self) -> Fingerprints:
+        """Get key fingerprints."""
+        logger.debug("Getting key fingerprints")
+        return self.get_application_related_data().discretionary.fingerprints
+
+    def set_fingerprint(self, key_ref: KEY_REF, fingerprint: bytes) -> None:
+        """Set the fingerprint for a key.
+
+        Requires Admin PIN verification.
+        """
+        logger.debug(f"Setting key fingerprint for {key_ref.name}")
+        self.put_data(key_ref.fingerprint_do, fingerprint)
+        logger.info("Key fingerprint set for {key_ref.name}")
+
+    def get_public_key(self, key_ref: KEY_REF) -> PublicKey:
+        """Get the public key from a slot."""
+        logger.debug(f"Getting public key for {key_ref.name}")
+        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x81, 0x00, key_ref.crt)
+        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
+        attributes = self.get_algorithm_attributes(key_ref)
+        if isinstance(attributes, EcAttributes):
+            return _parse_ec_key(attributes.oid, data)
+        else:  # RSA
+            return _parse_rsa_key(data)
+
+    def generate_rsa_key(
+        self, key_ref: KEY_REF, key_size: RSA_SIZE
+    ) -> rsa.RSAPublicKey:
+        """Generate an RSA key in the given slot.
+
+        Requires Admin PIN verification.
+        """
+        if (4, 2, 0) <= self.version < (4, 3, 5):
+            raise NotSupportedError("RSA key generation not supported on this YubiKey")
+
+        logger.debug(f"Generating RSA private key for {key_ref.name}")
+        if (
+            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
+            in self.extended_capabilities.flags
+        ):
+            attributes = RsaAttributes.create(key_size)
+            self.set_algorithm_attributes(key_ref, attributes)
+        elif key_size != RSA_SIZE.RSA2048:
+            raise NotSupportedError("Algorithm attributes not supported")
+
+        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x80, 0x00, key_ref.crt)
+        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
+        logger.info(f"RSA key generated for {key_ref.name}")
+        return _parse_rsa_key(data)
+
+    def generate_ec_key(self, key_ref: KEY_REF, curve_oid: CurveOid) -> EcPublicKey:
+        """Generate an EC key in the given slot.
+
+        Requires Admin PIN verification.
+        """
+
+        require_version(self.version, (5, 2, 0))
+
+        if curve_oid not in OID:
+            raise ValueError("Curve OID is not recognized")
+
+        logger.debug(f"Generating EC private key for {key_ref.name}")
+        attributes = EcAttributes.create(key_ref, curve_oid)
+        self.set_algorithm_attributes(key_ref, attributes)
+
+        resp = self.protocol.send_apdu(0, INS.GENERATE_ASYM, 0x80, 0x00, key_ref.crt)
+        data = Tlv.parse_dict(Tlv.unpack(TAG_PUBLIC_KEY, resp))
+        logger.info(f"EC key generated for {key_ref.name}")
+        return _parse_ec_key(curve_oid, data)
+
+    def put_key(self, key_ref: KEY_REF, private_key: PrivateKey) -> None:
+        """Import a private key into the give slot.
+
+        Requires Admin PIN verification.
+        """
+
+        logger.debug(f"Importing a private key for {key_ref.name}")
+        attributes = _get_key_attributes(private_key, key_ref, self.version)
+        if (
+            EXTENDED_CAPABILITY_FLAGS.ALGORITHM_ATTRIBUTES_CHANGEABLE
+            in self.extended_capabilities.flags
+        ):
+            self.set_algorithm_attributes(key_ref, attributes)
+        else:
+            if not (
+                isinstance(attributes, RsaAttributes)
+                and attributes.n_len == RSA_SIZE.RSA2048
+            ):
+                raise NotSupportedError("This YubiKey only supports RSA 2048 keys")
+
+        template = _get_key_template(private_key, key_ref, self.version < (4, 0, 0))
+        self.protocol.send_apdu(0, INS.PUT_DATA_ODD, 0x3F, 0xFF, bytes(template))
+        logger.info(f"Private key imported for {key_ref.name}")
+
+    def delete_key(self, key_ref: KEY_REF) -> None:
+        """Deletes the contents of a key slot.
+
+        Requires Admin PIN verification.
+        """
+        if self.version < (4, 0, 0):
+            # Import over the key
+            self.put_key(
+                key_ref, rsa.generate_private_key(65537, 2048, default_backend())
+            )
+        else:
+            # Delete key by changing the key attributes twice.
+            self.put_data(  # Use put_data to avoid checking for RSA 4096 support
+                key_ref.algorithm_attributes_do, RsaAttributes.create(RSA_SIZE.RSA4096)
+            )
+            self.set_algorithm_attributes(
+                key_ref, RsaAttributes.create(RSA_SIZE.RSA2048)
+            )
+
+    def _select_certificate(self, key_ref: KEY_REF) -> None:
+        logger.debug(f"Selecting certificate for key {key_ref.name}")
+        try:
+            require_version(self.version, (5, 2, 0))
+            data: bytes = Tlv(0x60, Tlv(0x5C, int2bytes(DO.CARDHOLDER_CERTIFICATE)))
+            if self.version <= (5, 4, 3):
+                # These use a non-standard byte in the command.
+                data = b"\x06" + data  # 6 is the length of the data.
+            self.protocol.send_apdu(
+                0,
+                INS.SELECT_DATA,
+                3 - key_ref,
+                0x04,
+                data,
+            )
+        except NotSupportedError:
+            if key_ref == KEY_REF.AUT:
+                return  # Older version still support AUT, which is the default slot.
+            raise
+
+    def get_certificate(self, key_ref: KEY_REF) -> x509.Certificate:
+        """Get a certificate from a slot."""
+        logger.debug(f"Getting certificate for key {key_ref.name}")
+        if key_ref == KEY_REF.ATT:
+            require_version(self.version, (5, 2, 0))
+            data = self.get_data(DO.ATT_CERTIFICATE)
+        else:
+            self._select_certificate(key_ref)
+            data = self.get_data(DO.CARDHOLDER_CERTIFICATE)
+        if not data:
+            raise ValueError("No certificate found!")
+        return x509.load_der_x509_certificate(data, default_backend())
+
+    def put_certificate(self, key_ref: KEY_REF, certificate: x509.Certificate) -> None:
+        """Imports a certificate into a slot.
+
+        Requires Admin PIN verification.
+        """
+        cert_data = certificate.public_bytes(Encoding.DER)
+        logger.debug(f"Importing certificate for key {key_ref.name}")
+        if key_ref == KEY_REF.ATT:
+            require_version(self.version, (5, 2, 0))
+            self.put_data(DO.ATT_CERTIFICATE, cert_data)
+        else:
+            self._select_certificate(key_ref)
+            self.put_data(DO.CARDHOLDER_CERTIFICATE, cert_data)
+        logger.info(f"Certificate imported for key {key_ref.name}")
+
+    def delete_certificate(self, key_ref: KEY_REF) -> None:
+        """Deletes a certificate in a slot.
+
+        Requires Admin PIN verification.
+        """
+        logger.debug(f"Deleting certificate for key {key_ref.name}")
+        if key_ref == KEY_REF.ATT:
+            require_version(self.version, (5, 2, 0))
+            self.put_data(DO.ATT_CERTIFICATE, b"")
+        else:
+            self._select_certificate(key_ref)
+            self.put_data(DO.CARDHOLDER_CERTIFICATE, b"")
+        logger.info(f"Certificate deleted for key {key_ref.name}")
+
+    def attest_key(self, key_ref: KEY_REF) -> x509.Certificate:
+        """Creates an attestation certificate for a key.
+
+        The certificte is written to the certificate slot for the key, and its
+        content is returned.
+
+        Requires User PIN verification.
+        """
+        require_version(self.version, (5, 2, 0))
+        logger.debug(f"Attesting key {key_ref.name}")
+        self.protocol.send_apdu(0x80, INS.GET_ATTESTATION, key_ref, 0)
+        logger.info(f"Attestation certificate created for {key_ref.name}")
+        return self.get_certificate(key_ref)
+
+    def sign(self, message: bytes, hash_algorithm: hashes.HashAlgorithm) -> bytes:
+        """Signs a message using the SIG key.
+
+        Requires User PIN verification.
+        """
+        attributes = self.get_algorithm_attributes(KEY_REF.SIG)
+        padded = _pad_message(attributes, message, hash_algorithm)
+        logger.debug(f"Signing a message with {attributes}")
+        response = self.protocol.send_apdu(0, INS.PSO, 0x9E, 0x9A, padded)
+        logger.info("Message signed")
+        if attributes.algorithm_id == 0x13:
+            ln = len(response) // 2
+            return encode_dss_signature(
+                int.from_bytes(response[:ln], "big"),
+                int.from_bytes(response[ln:], "big"),
+            )
+        return response
+
+    def decrypt(self, value: Union[bytes, EcPublicKey]) -> bytes:
+        """Decrypts a value using the DEC key.
+
+        For RSA the `value` should be an encrypted block.
+        For ECDH the `value` should be a peer public-key to perform the key exchange
+        with, and the result will be the derived shared secret.
+
+        Requires (extended) User PIN verification.
+        """
+        attributes = self.get_algorithm_attributes(KEY_REF.DEC)
+        logger.debug(f"Decrypting a value with {attributes}")
+
+        if isinstance(value, ec.EllipticCurvePublicKey):
+            data = value.public_bytes(Encoding.X962, PublicFormat.UncompressedPoint)
+        elif isinstance(value, x25519.X25519PublicKey):
+            data = value.public_bytes(Encoding.Raw, PublicFormat.Raw)
+        elif isinstance(value, bytes):
+            data = value
+
+        if isinstance(attributes, RsaAttributes):
+            data = b"\0" + data
+        elif isinstance(attributes, EcAttributes):
+            data = Tlv(0xA6, Tlv(0x7F49, Tlv(0x86, data)))
+
+        response = self.protocol.send_apdu(0, INS.PSO, 0x80, 0x86, data)
+        logger.info("Value decrypted")
+        return response
+
+    def authenticate(
+        self, message: bytes, hash_algorithm: hashes.HashAlgorithm
+    ) -> bytes:
+        """Authenticates a message using the AUT key.
+
+        Requires User PIN verification.
+        """
+        attributes = self.get_algorithm_attributes(KEY_REF.AUT)
+        padded = _pad_message(attributes, message, hash_algorithm)
+        logger.debug(f"Authenticating a message with {attributes}")
+        response = self.protocol.send_apdu(
+            0, INS.INTERNAL_AUTHENTICATE, 0x0, 0x0, padded
+        )
+        logger.info("Message authenticated")
+        if attributes.algorithm_id == 0x13:
+            ln = len(response) // 2
+            return encode_dss_signature(
+                int.from_bytes(response[:ln], "big"),
+                int.from_bytes(response[ln:], "big"),
+            )
+        return response
```

### Comparing `yubikey_manager-5.1.0/yubikit/piv.py` & `yubikey_manager-5.1.1/yubikit/piv.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,875 +1,875 @@
-# Copyright (c) 2020 Yubico AB
-# All rights reserved.
-#
-#   Redistribution and use in source and binary forms, with or
-#   without modification, are permitted provided that the following
-#   conditions are met:
-#
-#    1. Redistributions of source code must retain the above copyright
-#       notice, this list of conditions and the following disclaimer.
-#    2. Redistributions in binary form must reproduce the above
-#       copyright notice, this list of conditions and the following
-#       disclaimer in the documentation and/or other materials provided
-#       with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-
-from .core import (
-    require_version as _require_version,
-    int2bytes,
-    bytes2int,
-    Version,
-    Tlv,
-    CommandError,
-    NotSupportedError,
-    BadResponseError,
-)
-from .core.smartcard import (
-    SW,
-    AID,
-    ApduError,
-    ApduFormat,
-    SmartCardConnection,
-    SmartCardProtocol,
-)
-
-from cryptography import x509
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
-from cryptography.hazmat.primitives.constant_time import bytes_eq
-from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
-from cryptography.hazmat.primitives.asymmetric import rsa, ec
-from cryptography.hazmat.primitives.asymmetric.padding import AsymmetricPadding
-from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
-from cryptography.hazmat.backends import default_backend
-
-from dataclasses import dataclass
-from enum import Enum, IntEnum, unique
-from typing import Optional, Union, Type, cast
-
-import logging
-import os
-import re
-
-
-logger = logging.getLogger(__name__)
-
-
-@unique
-class ALGORITHM(str, Enum):
-    EC = "ec"
-    RSA = "rsa"
-
-
-# Don't treat pre 1.0 versions as "developer builds".
-def require_version(my_version: Version, *args, **kwargs):
-    if my_version <= (0, 1, 4):  # Last pre 1.0 release of ykneo-piv
-        my_version = Version(1, 0, 0)
-    _require_version(my_version, *args, **kwargs)
-
-
-@unique
-class KEY_TYPE(IntEnum):
-    RSA1024 = 0x06
-    RSA2048 = 0x07
-    ECCP256 = 0x11
-    ECCP384 = 0x14
-
-    @property
-    def algorithm(self):
-        return ALGORITHM.EC if self.name.startswith("ECC") else ALGORITHM.RSA
-
-    @property
-    def bit_len(self):
-        match = re.search(r"\d+$", self.name)
-        if match:
-            return int(match.group())
-        raise ValueError("No bit_len")
-
-    @classmethod
-    def from_public_key(cls, key):
-        if isinstance(key, rsa.RSAPublicKey):
-            try:
-                return getattr(cls, "RSA%d" % key.key_size)
-            except AttributeError:
-                raise ValueError("Unsupported RSA key size: %d" % key.key_size)
-                pass  # Fall through to ValueError
-        elif isinstance(key, ec.EllipticCurvePublicKey):
-            curve_name = key.curve.name
-            if curve_name == "secp256r1":
-                return cls.ECCP256
-            elif curve_name == "secp384r1":
-                return cls.ECCP384
-            raise ValueError(f"Unsupported EC curve: {curve_name}")
-        raise ValueError(f"Unsupported key type: {type(key).__name__}")
-
-
-@unique
-class MANAGEMENT_KEY_TYPE(IntEnum):
-    TDES = 0x03
-    AES128 = 0x08
-    AES192 = 0x0A
-    AES256 = 0x0C
-
-    @property
-    def key_len(self):
-        if self.name == "TDES":
-            return 24
-        # AES
-        return int(self.name[3:]) // 8
-
-    @property
-    def challenge_len(self):
-        if self.name == "TDES":
-            return 8
-        return 16
-
-
-def _parse_management_key(key_type, management_key):
-    if key_type == MANAGEMENT_KEY_TYPE.TDES:
-        return algorithms.TripleDES(management_key)
-    else:
-        return algorithms.AES(management_key)
-
-
-# The card management slot is special, we don't include it in SLOT below
-SLOT_CARD_MANAGEMENT = 0x9B
-
-
-@unique
-class SLOT(IntEnum):
-    AUTHENTICATION = 0x9A
-    SIGNATURE = 0x9C
-    KEY_MANAGEMENT = 0x9D
-    CARD_AUTH = 0x9E
-
-    RETIRED1 = 0x82
-    RETIRED2 = 0x83
-    RETIRED3 = 0x84
-    RETIRED4 = 0x85
-    RETIRED5 = 0x86
-    RETIRED6 = 0x87
-    RETIRED7 = 0x88
-    RETIRED8 = 0x89
-    RETIRED9 = 0x8A
-    RETIRED10 = 0x8B
-    RETIRED11 = 0x8C
-    RETIRED12 = 0x8D
-    RETIRED13 = 0x8E
-    RETIRED14 = 0x8F
-    RETIRED15 = 0x90
-    RETIRED16 = 0x91
-    RETIRED17 = 0x92
-    RETIRED18 = 0x93
-    RETIRED19 = 0x94
-    RETIRED20 = 0x95
-
-    ATTESTATION = 0xF9
-
-    def __str__(self) -> str:
-        return f"{self:02X} ({self.name})"
-
-
-@unique
-class OBJECT_ID(IntEnum):
-    CAPABILITY = 0x5FC107
-    CHUID = 0x5FC102
-    AUTHENTICATION = 0x5FC105  # cert for 9a key
-    FINGERPRINTS = 0x5FC103
-    SECURITY = 0x5FC106
-    FACIAL = 0x5FC108
-    PRINTED = 0x5FC109
-    SIGNATURE = 0x5FC10A  # cert for 9c key
-    KEY_MANAGEMENT = 0x5FC10B  # cert for 9d key
-    CARD_AUTH = 0x5FC101  # cert for 9e key
-    DISCOVERY = 0x7E
-    KEY_HISTORY = 0x5FC10C
-    IRIS = 0x5FC121
-
-    RETIRED1 = 0x5FC10D
-    RETIRED2 = 0x5FC10E
-    RETIRED3 = 0x5FC10F
-    RETIRED4 = 0x5FC110
-    RETIRED5 = 0x5FC111
-    RETIRED6 = 0x5FC112
-    RETIRED7 = 0x5FC113
-    RETIRED8 = 0x5FC114
-    RETIRED9 = 0x5FC115
-    RETIRED10 = 0x5FC116
-    RETIRED11 = 0x5FC117
-    RETIRED12 = 0x5FC118
-    RETIRED13 = 0x5FC119
-    RETIRED14 = 0x5FC11A
-    RETIRED15 = 0x5FC11B
-    RETIRED16 = 0x5FC11C
-    RETIRED17 = 0x5FC11D
-    RETIRED18 = 0x5FC11E
-    RETIRED19 = 0x5FC11F
-    RETIRED20 = 0x5FC120
-
-    ATTESTATION = 0x5FFF01
-
-    @classmethod
-    def from_slot(cls, slot):
-        return getattr(cls, SLOT(slot).name)
-
-
-@unique
-class PIN_POLICY(IntEnum):
-    DEFAULT = 0x0
-    NEVER = 0x1
-    ONCE = 0x2
-    ALWAYS = 0x3
-
-
-@unique
-class TOUCH_POLICY(IntEnum):
-    DEFAULT = 0x0
-    NEVER = 0x1
-    ALWAYS = 0x2
-    CACHED = 0x3
-
-
-# 010203040506070801020304050607080102030405060708
-DEFAULT_MANAGEMENT_KEY = (
-    b"\x01\x02\x03\x04\x05\x06\x07\x08"
-    + b"\x01\x02\x03\x04\x05\x06\x07\x08"
-    + b"\x01\x02\x03\x04\x05\x06\x07\x08"
-)
-
-PIN_LEN = 8
-
-# Instruction set
-INS_VERIFY = 0x20
-INS_CHANGE_REFERENCE = 0x24
-INS_RESET_RETRY = 0x2C
-INS_GENERATE_ASYMMETRIC = 0x47
-INS_AUTHENTICATE = 0x87
-INS_GET_DATA = 0xCB
-INS_PUT_DATA = 0xDB
-INS_GET_METADATA = 0xF7
-INS_ATTEST = 0xF9
-INS_SET_PIN_RETRIES = 0xFA
-INS_RESET = 0xFB
-INS_GET_VERSION = 0xFD
-INS_IMPORT_KEY = 0xFE
-INS_SET_MGMKEY = 0xFF
-
-# Tags for parsing responses and preparing requests
-TAG_AUTH_WITNESS = 0x80
-TAG_AUTH_CHALLENGE = 0x81
-TAG_AUTH_RESPONSE = 0x82
-TAG_AUTH_EXPONENTIATION = 0x85
-TAG_GEN_ALGORITHM = 0x80
-TAG_OBJ_DATA = 0x53
-TAG_OBJ_ID = 0x5C
-TAG_CERTIFICATE = 0x70
-TAG_CERT_INFO = 0x71
-TAG_DYN_AUTH = 0x7C
-TAG_LRC = 0xFE
-TAG_PIN_POLICY = 0xAA
-TAG_TOUCH_POLICY = 0xAB
-
-# Metadata tags
-TAG_METADATA_ALGO = 0x01
-TAG_METADATA_POLICY = 0x02
-TAG_METADATA_ORIGIN = 0x03
-TAG_METADATA_PUBLIC_KEY = 0x04
-TAG_METADATA_IS_DEFAULT = 0x05
-TAG_METADATA_RETRIES = 0x06
-
-ORIGIN_GENERATED = 1
-ORIGIN_IMPORTED = 2
-
-INDEX_PIN_POLICY = 0
-INDEX_TOUCH_POLICY = 1
-INDEX_RETRIES_TOTAL = 0
-INDEX_RETRIES_REMAINING = 1
-
-PIN_P2 = 0x80
-PUK_P2 = 0x81
-
-
-class InvalidPinError(CommandError):
-    def __init__(self, attempts_remaining):
-        super(InvalidPinError, self).__init__(
-            "Invalid PIN/PUK. Remaining attempts: %d" % attempts_remaining
-        )
-        self.attempts_remaining = attempts_remaining
-
-
-def _pin_bytes(pin):
-    pin = pin.encode()
-    if len(pin) > PIN_LEN:
-        raise ValueError("PIN/PUK must be no longer than 8 bytes")
-    return pin.ljust(PIN_LEN, b"\xff")
-
-
-def _retries_from_sw(version, sw):
-    if sw == SW.AUTH_METHOD_BLOCKED:
-        return 0
-    if version < (1, 0, 4):
-        if 0x6300 <= sw <= 0x63FF:
-            return sw & 0xFF
-    else:
-        if 0x63C0 <= sw <= 0x63CF:
-            return sw & 0x0F
-    return None
-
-
-@dataclass
-class PinMetadata:
-    default_value: bool
-    total_attempts: int
-    attempts_remaining: int
-
-
-@dataclass
-class ManagementKeyMetadata:
-    key_type: MANAGEMENT_KEY_TYPE
-    default_value: bool
-    touch_policy: TOUCH_POLICY
-
-
-@dataclass
-class SlotMetadata:
-    key_type: KEY_TYPE
-    pin_policy: PIN_POLICY
-    touch_policy: TOUCH_POLICY
-    generated: bool
-    public_key_encoded: bytes
-
-    @property
-    def public_key(self):
-        return _parse_device_public_key(self.key_type, self.public_key_encoded)
-
-
-def _pad_message(key_type, message, hash_algorithm, padding):
-    if key_type.algorithm == ALGORITHM.EC:
-        if isinstance(hash_algorithm, Prehashed):
-            hashed = message
-        else:
-            h = hashes.Hash(hash_algorithm, default_backend())
-            h.update(message)
-            hashed = h.finalize()
-        byte_len = key_type.bit_len // 8
-        if len(hashed) < byte_len:
-            return hashed.rjust(byte_len // 8, b"\0")
-        return hashed[:byte_len]
-    elif key_type.algorithm == ALGORITHM.RSA:
-        # Sign with a dummy key, then encrypt the signature to get the padded message
-        e = 65537
-        dummy = rsa.generate_private_key(e, key_type.bit_len, default_backend())
-        signature = dummy.sign(message, padding, hash_algorithm)
-        # Raw (textbook) RSA encrypt
-        n = dummy.public_key().public_numbers().n
-        return int2bytes(pow(bytes2int(signature), e, n), key_type.bit_len // 8)
-
-
-def _unpad_message(padded, padding):
-    e = 65537
-    dummy = rsa.generate_private_key(e, len(padded) * 8, default_backend())
-    # Raw (textbook) RSA encrypt
-    n = dummy.public_key().public_numbers().n
-    encrypted = int2bytes(pow(bytes2int(padded), e, n), len(padded))
-    return dummy.decrypt(encrypted, padding)
-
-
-def check_key_support(
-    version: Version,
-    key_type: KEY_TYPE,
-    pin_policy: PIN_POLICY,
-    touch_policy: TOUCH_POLICY,
-    generate: bool = True,
-) -> None:
-    """Check if a key type is supported by a specific YubiKey firmware version.
-
-    This method will return None if the key (with PIN and touch policies) is supported,
-    or it will raise a NotSupportedError if it is not.
-    """
-    if version[0] == 0 and version > (0, 1, 3):
-        return  # Development build, skip version checks
-
-    if version < (4, 0, 0):
-        if key_type == KEY_TYPE.ECCP384:
-            raise NotSupportedError("ECCP384 requires YubiKey 4 or later")
-        if touch_policy != TOUCH_POLICY.DEFAULT or pin_policy != PIN_POLICY.DEFAULT:
-            raise NotSupportedError("PIN/Touch policy requires YubiKey 4 or later")
-
-    if version < (4, 3, 0) and touch_policy == TOUCH_POLICY.CACHED:
-        raise NotSupportedError("Cached touch policy requires YubiKey 4.3 or later")
-
-    # ROCA
-    if (4, 2, 0) <= version < (4, 3, 5):
-        if generate and key_type.algorithm == ALGORITHM.RSA:
-            raise NotSupportedError("RSA key generation not supported on this YubiKey")
-
-    # FIPS
-    if (4, 4, 0) <= version < (4, 5, 0):
-        if key_type == KEY_TYPE.RSA1024:
-            raise NotSupportedError("RSA 1024 not supported on YubiKey FIPS")
-        if pin_policy == PIN_POLICY.NEVER:
-            raise NotSupportedError("PIN_POLICY.NEVER not allowed on YubiKey FIPS")
-
-
-def _parse_device_public_key(key_type, encoded):
-    data = Tlv.parse_dict(encoded)
-    if key_type.algorithm == ALGORITHM.RSA:
-        modulus = bytes2int(data[0x81])
-        exponent = bytes2int(data[0x82])
-        return rsa.RSAPublicNumbers(exponent, modulus).public_key(default_backend())
-    else:
-        if key_type == KEY_TYPE.ECCP256:
-            curve: Type[ec.EllipticCurve] = ec.SECP256R1
-        else:
-            curve = ec.SECP384R1
-
-        return ec.EllipticCurvePublicKey.from_encoded_point(curve(), data[0x86])
-
-
-class PivSession:
-    def __init__(self, connection: SmartCardConnection):
-        self.protocol = SmartCardProtocol(connection)
-        self.protocol.select(AID.PIV)
-        self._version = Version.from_bytes(
-            self.protocol.send_apdu(0, INS_GET_VERSION, 0, 0)
-        )
-        self.protocol.enable_touch_workaround(self.version)
-        if self.version >= (4, 0, 0):
-            self.protocol.apdu_format = ApduFormat.EXTENDED
-        self._current_pin_retries = 3
-        self._max_pin_retries = 3
-        logger.debug(f"PIV session initialized (version={self.version})")
-
-    @property
-    def version(self) -> Version:
-        return self._version
-
-    def reset(self) -> None:
-        logger.debug("Preparing PIV reset")
-
-        # Block PIN
-        logger.debug("Verify PIN with invalid attempts until blocked")
-        counter = self.get_pin_attempts()
-        while counter > 0:
-            try:
-                self.verify_pin("")
-            except InvalidPinError as e:
-                counter = e.attempts_remaining
-        logger.debug("PIN is blocked")
-
-        # Block PUK
-        logger.debug("Verify PUK with invalid attempts until blocked")
-        counter = 1
-        while counter > 0:
-            try:
-                self._change_reference(INS_RESET_RETRY, PIN_P2, "", "")
-            except InvalidPinError as e:
-                counter = e.attempts_remaining
-        logger.debug("PUK is blocked")
-
-        # Reset
-        logger.debug("Sending reset")
-        self.protocol.send_apdu(0, INS_RESET, 0, 0)
-        self._current_pin_retries = 3
-        self._max_pin_retries = 3
-
-        logger.info("PIV application data reset performed")
-
-    def authenticate(
-        self, key_type: MANAGEMENT_KEY_TYPE, management_key: bytes
-    ) -> None:
-        key_type = MANAGEMENT_KEY_TYPE(key_type)
-        logger.debug(f"Authenticating with key type: {key_type}")
-        response = self.protocol.send_apdu(
-            0,
-            INS_AUTHENTICATE,
-            key_type,
-            SLOT_CARD_MANAGEMENT,
-            Tlv(TAG_DYN_AUTH, Tlv(TAG_AUTH_WITNESS)),
-        )
-        witness = Tlv.unpack(TAG_AUTH_WITNESS, Tlv.unpack(TAG_DYN_AUTH, response))
-        challenge = os.urandom(key_type.challenge_len)
-
-        backend = default_backend()
-        cipher_key = _parse_management_key(key_type, management_key)
-        cipher = Cipher(cipher_key, modes.ECB(), backend)  # nosec
-        decryptor = cipher.decryptor()
-        decrypted = decryptor.update(witness) + decryptor.finalize()
-
-        response = self.protocol.send_apdu(
-            0,
-            INS_AUTHENTICATE,
-            key_type,
-            SLOT_CARD_MANAGEMENT,
-            Tlv(
-                TAG_DYN_AUTH,
-                Tlv(TAG_AUTH_WITNESS, decrypted) + Tlv(TAG_AUTH_CHALLENGE, challenge),
-            ),
-        )
-        encrypted = Tlv.unpack(TAG_AUTH_RESPONSE, Tlv.unpack(TAG_DYN_AUTH, response))
-        encryptor = cipher.encryptor()
-        expected = encryptor.update(challenge) + encryptor.finalize()
-        if not bytes_eq(expected, encrypted):
-            raise BadResponseError("Device response is incorrect")
-
-    def set_management_key(
-        self,
-        key_type: MANAGEMENT_KEY_TYPE,
-        management_key: bytes,
-        require_touch: bool = False,
-    ) -> None:
-        key_type = MANAGEMENT_KEY_TYPE(key_type)
-        logger.debug(f"Setting management key of type: {key_type}")
-
-        if key_type != MANAGEMENT_KEY_TYPE.TDES:
-            require_version(self.version, (5, 4, 0))
-        if len(management_key) != key_type.key_len:
-            raise ValueError("Management key must be %d bytes" % key_type.key_len)
-
-        self.protocol.send_apdu(
-            0,
-            INS_SET_MGMKEY,
-            0xFF,
-            0xFE if require_touch else 0xFF,
-            int2bytes(key_type) + Tlv(SLOT_CARD_MANAGEMENT, management_key),
-        )
-        logger.info("Management key set")
-
-    def verify_pin(self, pin: str) -> None:
-        logger.debug("Verifying PIN")
-        try:
-            self.protocol.send_apdu(0, INS_VERIFY, 0, PIN_P2, _pin_bytes(pin))
-            self._current_pin_retries = self._max_pin_retries
-        except ApduError as e:
-            retries = _retries_from_sw(self.version, e.sw)
-            if retries is None:
-                raise
-            self._current_pin_retries = retries
-            raise InvalidPinError(retries)
-
-    def get_pin_attempts(self) -> int:
-        logger.debug("Getting PIN attempts")
-        try:
-            return self.get_pin_metadata().attempts_remaining
-        except NotSupportedError:
-            try:
-                self.protocol.send_apdu(0, INS_VERIFY, 0, PIN_P2)
-                # Already verified, no way to know true count
-                logger.debug("Using cached value, may be incorrect.")
-                return self._current_pin_retries
-            except ApduError as e:
-                retries = _retries_from_sw(self.version, e.sw)
-                if retries is None:
-                    raise
-                self._current_pin_retries = retries
-                logger.debug("Using value from empty verify")
-                return retries
-
-    def change_pin(self, old_pin: str, new_pin: str) -> None:
-        logger.debug("Changing PIN")
-        self._change_reference(INS_CHANGE_REFERENCE, PIN_P2, old_pin, new_pin)
-        logger.info("New PIN set")
-
-    def change_puk(self, old_puk: str, new_puk: str) -> None:
-        logger.debug("Changing PUK")
-        self._change_reference(INS_CHANGE_REFERENCE, PUK_P2, old_puk, new_puk)
-        logger.info("New PUK set")
-
-    def unblock_pin(self, puk: str, new_pin: str) -> None:
-        logger.debug("Using PUK to set new PIN")
-        self._change_reference(INS_RESET_RETRY, PIN_P2, puk, new_pin)
-        logger.info("New PIN set")
-
-    def set_pin_attempts(self, pin_attempts: int, puk_attempts: int) -> None:
-        logger.debug(f"Setting PIN/PUK attempts ({pin_attempts}, {puk_attempts})")
-        self.protocol.send_apdu(0, INS_SET_PIN_RETRIES, pin_attempts, puk_attempts)
-        self._max_pin_retries = pin_attempts
-        self._current_pin_retries = pin_attempts
-        logger.info("PIN/PUK attempts set")
-
-    def get_pin_metadata(self) -> PinMetadata:
-        logger.debug("Getting PIN metadata")
-        return self._get_pin_puk_metadata(PIN_P2)
-
-    def get_puk_metadata(self) -> PinMetadata:
-        logger.debug("Getting PUK metadata")
-        return self._get_pin_puk_metadata(PUK_P2)
-
-    def get_management_key_metadata(self) -> ManagementKeyMetadata:
-        logger.debug("Getting management key metadata")
-        require_version(self.version, (5, 3, 0))
-        data = Tlv.parse_dict(
-            self.protocol.send_apdu(0, INS_GET_METADATA, 0, SLOT_CARD_MANAGEMENT)
-        )
-        policy = data[TAG_METADATA_POLICY]
-        return ManagementKeyMetadata(
-            MANAGEMENT_KEY_TYPE(data.get(TAG_METADATA_ALGO, b"\x03")[0]),
-            data[TAG_METADATA_IS_DEFAULT] != b"\0",
-            TOUCH_POLICY(policy[INDEX_TOUCH_POLICY]),
-        )
-
-    def get_slot_metadata(self, slot: SLOT) -> SlotMetadata:
-        slot = SLOT(slot)
-        logger.debug(f"Getting metadata for slot {slot}")
-        require_version(self.version, (5, 3, 0))
-        data = Tlv.parse_dict(self.protocol.send_apdu(0, INS_GET_METADATA, 0, slot))
-        policy = data[TAG_METADATA_POLICY]
-        return SlotMetadata(
-            KEY_TYPE(data[TAG_METADATA_ALGO][0]),
-            PIN_POLICY(policy[INDEX_PIN_POLICY]),
-            TOUCH_POLICY(policy[INDEX_TOUCH_POLICY]),
-            data[TAG_METADATA_ORIGIN][0] == ORIGIN_GENERATED,
-            data[TAG_METADATA_PUBLIC_KEY],
-        )
-
-    def sign(
-        self,
-        slot: SLOT,
-        key_type: KEY_TYPE,
-        message: bytes,
-        hash_algorithm: hashes.HashAlgorithm,
-        padding: Optional[AsymmetricPadding] = None,
-    ) -> bytes:
-        slot = SLOT(slot)
-        key_type = KEY_TYPE(key_type)
-        logger.debug(
-            f"Signing data with key in slot {slot} of type {key_type} using "
-            f"hash={hash_algorithm}, padding={padding}"
-        )
-        padded = _pad_message(key_type, message, hash_algorithm, padding)
-        return self._use_private_key(slot, key_type, padded, False)
-
-    def decrypt(
-        self, slot: SLOT, cipher_text: bytes, padding: AsymmetricPadding
-    ) -> bytes:
-        slot = SLOT(slot)
-        if len(cipher_text) == 1024 // 8:
-            key_type = KEY_TYPE.RSA1024
-        elif len(cipher_text) == 2048 // 8:
-            key_type = KEY_TYPE.RSA2048
-        else:
-            raise ValueError("Invalid length of ciphertext")
-        logger.debug(
-            f"Decrypting data with key in slot {slot} of type {key_type} using ",
-            f"padding={padding}",
-        )
-        padded = self._use_private_key(slot, key_type, cipher_text, False)
-        return _unpad_message(padded, padding)
-
-    def calculate_secret(
-        self, slot: SLOT, peer_public_key: ec.EllipticCurvePublicKey
-    ) -> bytes:
-        slot = SLOT(slot)
-        key_type = KEY_TYPE.from_public_key(peer_public_key)
-        if key_type.algorithm != ALGORITHM.EC:
-            raise ValueError("Unsupported key type")
-        logger.debug(
-            f"Performing key agreement with key in slot {slot} of type {key_type}"
-        )
-        data = peer_public_key.public_bytes(
-            Encoding.X962, PublicFormat.UncompressedPoint
-        )
-        return self._use_private_key(slot, key_type, data, True)
-
-    def get_object(self, object_id: int) -> bytes:
-        logger.debug(f"Reading data from object slot {hex(object_id)}")
-        if object_id == OBJECT_ID.DISCOVERY:
-            expected: int = OBJECT_ID.DISCOVERY
-        else:
-            expected = TAG_OBJ_DATA
-
-        try:
-            return Tlv.unpack(
-                expected,
-                self.protocol.send_apdu(
-                    0,
-                    INS_GET_DATA,
-                    0x3F,
-                    0xFF,
-                    Tlv(TAG_OBJ_ID, int2bytes(object_id)),
-                ),
-            )
-        except ValueError as e:
-            raise BadResponseError("Malformed object data", e)
-
-    def put_object(self, object_id: int, data: Optional[bytes] = None) -> None:
-        self.protocol.send_apdu(
-            0,
-            INS_PUT_DATA,
-            0x3F,
-            0xFF,
-            Tlv(TAG_OBJ_ID, int2bytes(object_id)) + Tlv(TAG_OBJ_DATA, data or b""),
-        )
-        logger.info(f"Data written to object slot {hex(object_id)}")
-
-    def get_certificate(self, slot: SLOT) -> x509.Certificate:
-        slot = SLOT(slot)
-        logger.debug(f"Reading certificate in slot {slot}")
-        try:
-            data = Tlv.parse_dict(self.get_object(OBJECT_ID.from_slot(slot)))
-        except ValueError:
-            raise BadResponseError("Malformed certificate data object")
-
-        cert_info = data.get(TAG_CERT_INFO)
-        if cert_info and cert_info[0] != 0:
-            raise NotSupportedError("Compressed certificates are not supported")
-
-        try:
-            return x509.load_der_x509_certificate(
-                data[TAG_CERTIFICATE], default_backend()
-            )
-        except Exception as e:
-            raise BadResponseError("Invalid certificate", e)
-
-    def put_certificate(self, slot: SLOT, certificate: x509.Certificate) -> None:
-        slot = SLOT(slot)
-        logger.debug(f"Storing certificate in slot {slot}")
-        cert_data = certificate.public_bytes(Encoding.DER)
-        data = (
-            Tlv(TAG_CERTIFICATE, cert_data) + Tlv(TAG_CERT_INFO, b"\0") + Tlv(TAG_LRC)
-        )
-        self.put_object(OBJECT_ID.from_slot(slot), data)
-
-    def delete_certificate(self, slot: SLOT) -> None:
-        slot = SLOT(slot)
-        logger.debug(f"Deleting certificate in slot {slot}")
-        self.put_object(OBJECT_ID.from_slot(slot))
-
-    def put_key(
-        self,
-        slot: SLOT,
-        private_key: Union[
-            rsa.RSAPrivateKeyWithSerialization,
-            ec.EllipticCurvePrivateKeyWithSerialization,
-        ],
-        pin_policy: PIN_POLICY = PIN_POLICY.DEFAULT,
-        touch_policy: TOUCH_POLICY = TOUCH_POLICY.DEFAULT,
-    ) -> None:
-        slot = SLOT(slot)
-        key_type = KEY_TYPE.from_public_key(private_key.public_key())
-        check_key_support(self.version, key_type, pin_policy, touch_policy, False)
-        ln = key_type.bit_len // 8
-        numbers = private_key.private_numbers()
-        if key_type.algorithm == ALGORITHM.RSA:
-            numbers = cast(rsa.RSAPrivateNumbers, numbers)
-            if numbers.public_numbers.e != 65537:
-                raise NotSupportedError("RSA exponent must be 65537")
-            ln //= 2
-            data = (
-                Tlv(0x01, int2bytes(numbers.p, ln))
-                + Tlv(0x02, int2bytes(numbers.q, ln))
-                + Tlv(0x03, int2bytes(numbers.dmp1, ln))
-                + Tlv(0x04, int2bytes(numbers.dmq1, ln))
-                + Tlv(0x05, int2bytes(numbers.iqmp, ln))
-            )
-        else:
-            numbers = cast(ec.EllipticCurvePrivateNumbers, numbers)
-            data = Tlv(0x06, int2bytes(numbers.private_value, ln))
-        if pin_policy:
-            data += Tlv(TAG_PIN_POLICY, int2bytes(pin_policy))
-        if touch_policy:
-            data += Tlv(TAG_TOUCH_POLICY, int2bytes(touch_policy))
-
-        logger.debug(
-            f"Importing key with pin_policy={pin_policy}, touch_policy={touch_policy}"
-        )
-        self.protocol.send_apdu(0, INS_IMPORT_KEY, key_type, slot, data)
-        logger.info(f"Private key imported in slot {slot} of type {key_type}")
-        return key_type
-
-    def generate_key(
-        self,
-        slot: SLOT,
-        key_type: KEY_TYPE,
-        pin_policy: PIN_POLICY = PIN_POLICY.DEFAULT,
-        touch_policy: TOUCH_POLICY = TOUCH_POLICY.DEFAULT,
-    ) -> Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey]:
-        slot = SLOT(slot)
-        key_type = KEY_TYPE(key_type)
-        check_key_support(self.version, key_type, pin_policy, touch_policy, True)
-        data: bytes = Tlv(TAG_GEN_ALGORITHM, int2bytes(key_type))
-        if pin_policy:
-            data += Tlv(TAG_PIN_POLICY, int2bytes(pin_policy))
-        if touch_policy:
-            data += Tlv(TAG_TOUCH_POLICY, int2bytes(touch_policy))
-
-        logger.debug(
-            f"Generating key with pin_policy={pin_policy}, touch_policy={touch_policy}"
-        )
-        response = self.protocol.send_apdu(
-            0, INS_GENERATE_ASYMMETRIC, 0, slot, Tlv(0xAC, data)
-        )
-        logger.info(f"Private key generated in slot {slot} of type {key_type}")
-        return _parse_device_public_key(key_type, Tlv.unpack(0x7F49, response))
-
-    def attest_key(self, slot: SLOT) -> x509.Certificate:
-        require_version(self.version, (4, 3, 0))
-        slot = SLOT(slot)
-        response = self.protocol.send_apdu(0, INS_ATTEST, slot, 0)
-        logger.debug(f"Attested key in slot {slot}")
-        return x509.load_der_x509_certificate(response, default_backend())
-
-    def _change_reference(self, ins, p2, value1, value2):
-        try:
-            self.protocol.send_apdu(
-                0, ins, 0, p2, _pin_bytes(value1) + _pin_bytes(value2)
-            )
-        except ApduError as e:
-            retries = _retries_from_sw(self.version, e.sw)
-            if retries is None:
-                raise
-            if p2 == PIN_P2:
-                self._current_pin_retries = retries
-            raise InvalidPinError(retries)
-
-    def _get_pin_puk_metadata(self, p2):
-        require_version(self.version, (5, 3, 0))
-        data = Tlv.parse_dict(self.protocol.send_apdu(0, INS_GET_METADATA, 0, p2))
-        attempts = data[TAG_METADATA_RETRIES]
-        return PinMetadata(
-            data[TAG_METADATA_IS_DEFAULT] != b"\0",
-            attempts[INDEX_RETRIES_TOTAL],
-            attempts[INDEX_RETRIES_REMAINING],
-        )
-
-    def _use_private_key(self, slot, key_type, message, exponentiation):
-        try:
-            response = self.protocol.send_apdu(
-                0,
-                INS_AUTHENTICATE,
-                key_type,
-                slot,
-                Tlv(
-                    TAG_DYN_AUTH,
-                    Tlv(TAG_AUTH_RESPONSE)
-                    + Tlv(
-                        TAG_AUTH_EXPONENTIATION
-                        if exponentiation
-                        else TAG_AUTH_CHALLENGE,
-                        message,
-                    ),
-                ),
-            )
-            return Tlv.unpack(
-                TAG_AUTH_RESPONSE,
-                Tlv.unpack(
-                    TAG_DYN_AUTH,
-                    response,
-                ),
-            )
-        except ApduError as e:
-            if e.sw == SW.INCORRECT_PARAMETERS:
-                raise e  # TODO: Different error, No key?
-            raise
+# Copyright (c) 2020 Yubico AB
+# All rights reserved.
+#
+#   Redistribution and use in source and binary forms, with or
+#   without modification, are permitted provided that the following
+#   conditions are met:
+#
+#    1. Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#    2. Redistributions in binary form must reproduce the above
+#       copyright notice, this list of conditions and the following
+#       disclaimer in the documentation and/or other materials provided
+#       with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+from .core import (
+    require_version as _require_version,
+    int2bytes,
+    bytes2int,
+    Version,
+    Tlv,
+    CommandError,
+    NotSupportedError,
+    BadResponseError,
+)
+from .core.smartcard import (
+    SW,
+    AID,
+    ApduError,
+    ApduFormat,
+    SmartCardConnection,
+    SmartCardProtocol,
+)
+
+from cryptography import x509
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
+from cryptography.hazmat.primitives.constant_time import bytes_eq
+from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat
+from cryptography.hazmat.primitives.asymmetric import rsa, ec
+from cryptography.hazmat.primitives.asymmetric.padding import AsymmetricPadding
+from cryptography.hazmat.primitives.asymmetric.utils import Prehashed
+from cryptography.hazmat.backends import default_backend
+
+from dataclasses import dataclass
+from enum import Enum, IntEnum, unique
+from typing import Optional, Union, Type, cast
+
+import logging
+import os
+import re
+
+
+logger = logging.getLogger(__name__)
+
+
+@unique
+class ALGORITHM(str, Enum):
+    EC = "ec"
+    RSA = "rsa"
+
+
+# Don't treat pre 1.0 versions as "developer builds".
+def require_version(my_version: Version, *args, **kwargs):
+    if my_version <= (0, 1, 4):  # Last pre 1.0 release of ykneo-piv
+        my_version = Version(1, 0, 0)
+    _require_version(my_version, *args, **kwargs)
+
+
+@unique
+class KEY_TYPE(IntEnum):
+    RSA1024 = 0x06
+    RSA2048 = 0x07
+    ECCP256 = 0x11
+    ECCP384 = 0x14
+
+    @property
+    def algorithm(self):
+        return ALGORITHM.EC if self.name.startswith("ECC") else ALGORITHM.RSA
+
+    @property
+    def bit_len(self):
+        match = re.search(r"\d+$", self.name)
+        if match:
+            return int(match.group())
+        raise ValueError("No bit_len")
+
+    @classmethod
+    def from_public_key(cls, key):
+        if isinstance(key, rsa.RSAPublicKey):
+            try:
+                return getattr(cls, "RSA%d" % key.key_size)
+            except AttributeError:
+                raise ValueError("Unsupported RSA key size: %d" % key.key_size)
+                pass  # Fall through to ValueError
+        elif isinstance(key, ec.EllipticCurvePublicKey):
+            curve_name = key.curve.name
+            if curve_name == "secp256r1":
+                return cls.ECCP256
+            elif curve_name == "secp384r1":
+                return cls.ECCP384
+            raise ValueError(f"Unsupported EC curve: {curve_name}")
+        raise ValueError(f"Unsupported key type: {type(key).__name__}")
+
+
+@unique
+class MANAGEMENT_KEY_TYPE(IntEnum):
+    TDES = 0x03
+    AES128 = 0x08
+    AES192 = 0x0A
+    AES256 = 0x0C
+
+    @property
+    def key_len(self):
+        if self.name == "TDES":
+            return 24
+        # AES
+        return int(self.name[3:]) // 8
+
+    @property
+    def challenge_len(self):
+        if self.name == "TDES":
+            return 8
+        return 16
+
+
+def _parse_management_key(key_type, management_key):
+    if key_type == MANAGEMENT_KEY_TYPE.TDES:
+        return algorithms.TripleDES(management_key)
+    else:
+        return algorithms.AES(management_key)
+
+
+# The card management slot is special, we don't include it in SLOT below
+SLOT_CARD_MANAGEMENT = 0x9B
+
+
+@unique
+class SLOT(IntEnum):
+    AUTHENTICATION = 0x9A
+    SIGNATURE = 0x9C
+    KEY_MANAGEMENT = 0x9D
+    CARD_AUTH = 0x9E
+
+    RETIRED1 = 0x82
+    RETIRED2 = 0x83
+    RETIRED3 = 0x84
+    RETIRED4 = 0x85
+    RETIRED5 = 0x86
+    RETIRED6 = 0x87
+    RETIRED7 = 0x88
+    RETIRED8 = 0x89
+    RETIRED9 = 0x8A
+    RETIRED10 = 0x8B
+    RETIRED11 = 0x8C
+    RETIRED12 = 0x8D
+    RETIRED13 = 0x8E
+    RETIRED14 = 0x8F
+    RETIRED15 = 0x90
+    RETIRED16 = 0x91
+    RETIRED17 = 0x92
+    RETIRED18 = 0x93
+    RETIRED19 = 0x94
+    RETIRED20 = 0x95
+
+    ATTESTATION = 0xF9
+
+    def __str__(self) -> str:
+        return f"{int(self):02X} ({self.name})"
+
+
+@unique
+class OBJECT_ID(IntEnum):
+    CAPABILITY = 0x5FC107
+    CHUID = 0x5FC102
+    AUTHENTICATION = 0x5FC105  # cert for 9a key
+    FINGERPRINTS = 0x5FC103
+    SECURITY = 0x5FC106
+    FACIAL = 0x5FC108
+    PRINTED = 0x5FC109
+    SIGNATURE = 0x5FC10A  # cert for 9c key
+    KEY_MANAGEMENT = 0x5FC10B  # cert for 9d key
+    CARD_AUTH = 0x5FC101  # cert for 9e key
+    DISCOVERY = 0x7E
+    KEY_HISTORY = 0x5FC10C
+    IRIS = 0x5FC121
+
+    RETIRED1 = 0x5FC10D
+    RETIRED2 = 0x5FC10E
+    RETIRED3 = 0x5FC10F
+    RETIRED4 = 0x5FC110
+    RETIRED5 = 0x5FC111
+    RETIRED6 = 0x5FC112
+    RETIRED7 = 0x5FC113
+    RETIRED8 = 0x5FC114
+    RETIRED9 = 0x5FC115
+    RETIRED10 = 0x5FC116
+    RETIRED11 = 0x5FC117
+    RETIRED12 = 0x5FC118
+    RETIRED13 = 0x5FC119
+    RETIRED14 = 0x5FC11A
+    RETIRED15 = 0x5FC11B
+    RETIRED16 = 0x5FC11C
+    RETIRED17 = 0x5FC11D
+    RETIRED18 = 0x5FC11E
+    RETIRED19 = 0x5FC11F
+    RETIRED20 = 0x5FC120
+
+    ATTESTATION = 0x5FFF01
+
+    @classmethod
+    def from_slot(cls, slot):
+        return getattr(cls, SLOT(slot).name)
+
+
+@unique
+class PIN_POLICY(IntEnum):
+    DEFAULT = 0x0
+    NEVER = 0x1
+    ONCE = 0x2
+    ALWAYS = 0x3
+
+
+@unique
+class TOUCH_POLICY(IntEnum):
+    DEFAULT = 0x0
+    NEVER = 0x1
+    ALWAYS = 0x2
+    CACHED = 0x3
+
+
+# 010203040506070801020304050607080102030405060708
+DEFAULT_MANAGEMENT_KEY = (
+    b"\x01\x02\x03\x04\x05\x06\x07\x08"
+    + b"\x01\x02\x03\x04\x05\x06\x07\x08"
+    + b"\x01\x02\x03\x04\x05\x06\x07\x08"
+)
+
+PIN_LEN = 8
+
+# Instruction set
+INS_VERIFY = 0x20
+INS_CHANGE_REFERENCE = 0x24
+INS_RESET_RETRY = 0x2C
+INS_GENERATE_ASYMMETRIC = 0x47
+INS_AUTHENTICATE = 0x87
+INS_GET_DATA = 0xCB
+INS_PUT_DATA = 0xDB
+INS_GET_METADATA = 0xF7
+INS_ATTEST = 0xF9
+INS_SET_PIN_RETRIES = 0xFA
+INS_RESET = 0xFB
+INS_GET_VERSION = 0xFD
+INS_IMPORT_KEY = 0xFE
+INS_SET_MGMKEY = 0xFF
+
+# Tags for parsing responses and preparing requests
+TAG_AUTH_WITNESS = 0x80
+TAG_AUTH_CHALLENGE = 0x81
+TAG_AUTH_RESPONSE = 0x82
+TAG_AUTH_EXPONENTIATION = 0x85
+TAG_GEN_ALGORITHM = 0x80
+TAG_OBJ_DATA = 0x53
+TAG_OBJ_ID = 0x5C
+TAG_CERTIFICATE = 0x70
+TAG_CERT_INFO = 0x71
+TAG_DYN_AUTH = 0x7C
+TAG_LRC = 0xFE
+TAG_PIN_POLICY = 0xAA
+TAG_TOUCH_POLICY = 0xAB
+
+# Metadata tags
+TAG_METADATA_ALGO = 0x01
+TAG_METADATA_POLICY = 0x02
+TAG_METADATA_ORIGIN = 0x03
+TAG_METADATA_PUBLIC_KEY = 0x04
+TAG_METADATA_IS_DEFAULT = 0x05
+TAG_METADATA_RETRIES = 0x06
+
+ORIGIN_GENERATED = 1
+ORIGIN_IMPORTED = 2
+
+INDEX_PIN_POLICY = 0
+INDEX_TOUCH_POLICY = 1
+INDEX_RETRIES_TOTAL = 0
+INDEX_RETRIES_REMAINING = 1
+
+PIN_P2 = 0x80
+PUK_P2 = 0x81
+
+
+class InvalidPinError(CommandError):
+    def __init__(self, attempts_remaining):
+        super(InvalidPinError, self).__init__(
+            "Invalid PIN/PUK. Remaining attempts: %d" % attempts_remaining
+        )
+        self.attempts_remaining = attempts_remaining
+
+
+def _pin_bytes(pin):
+    pin = pin.encode()
+    if len(pin) > PIN_LEN:
+        raise ValueError("PIN/PUK must be no longer than 8 bytes")
+    return pin.ljust(PIN_LEN, b"\xff")
+
+
+def _retries_from_sw(version, sw):
+    if sw == SW.AUTH_METHOD_BLOCKED:
+        return 0
+    if version < (1, 0, 4):
+        if 0x6300 <= sw <= 0x63FF:
+            return sw & 0xFF
+    else:
+        if 0x63C0 <= sw <= 0x63CF:
+            return sw & 0x0F
+    return None
+
+
+@dataclass
+class PinMetadata:
+    default_value: bool
+    total_attempts: int
+    attempts_remaining: int
+
+
+@dataclass
+class ManagementKeyMetadata:
+    key_type: MANAGEMENT_KEY_TYPE
+    default_value: bool
+    touch_policy: TOUCH_POLICY
+
+
+@dataclass
+class SlotMetadata:
+    key_type: KEY_TYPE
+    pin_policy: PIN_POLICY
+    touch_policy: TOUCH_POLICY
+    generated: bool
+    public_key_encoded: bytes
+
+    @property
+    def public_key(self):
+        return _parse_device_public_key(self.key_type, self.public_key_encoded)
+
+
+def _pad_message(key_type, message, hash_algorithm, padding):
+    if key_type.algorithm == ALGORITHM.EC:
+        if isinstance(hash_algorithm, Prehashed):
+            hashed = message
+        else:
+            h = hashes.Hash(hash_algorithm, default_backend())
+            h.update(message)
+            hashed = h.finalize()
+        byte_len = key_type.bit_len // 8
+        if len(hashed) < byte_len:
+            return hashed.rjust(byte_len // 8, b"\0")
+        return hashed[:byte_len]
+    elif key_type.algorithm == ALGORITHM.RSA:
+        # Sign with a dummy key, then encrypt the signature to get the padded message
+        e = 65537
+        dummy = rsa.generate_private_key(e, key_type.bit_len, default_backend())
+        signature = dummy.sign(message, padding, hash_algorithm)
+        # Raw (textbook) RSA encrypt
+        n = dummy.public_key().public_numbers().n
+        return int2bytes(pow(bytes2int(signature), e, n), key_type.bit_len // 8)
+
+
+def _unpad_message(padded, padding):
+    e = 65537
+    dummy = rsa.generate_private_key(e, len(padded) * 8, default_backend())
+    # Raw (textbook) RSA encrypt
+    n = dummy.public_key().public_numbers().n
+    encrypted = int2bytes(pow(bytes2int(padded), e, n), len(padded))
+    return dummy.decrypt(encrypted, padding)
+
+
+def check_key_support(
+    version: Version,
+    key_type: KEY_TYPE,
+    pin_policy: PIN_POLICY,
+    touch_policy: TOUCH_POLICY,
+    generate: bool = True,
+) -> None:
+    """Check if a key type is supported by a specific YubiKey firmware version.
+
+    This method will return None if the key (with PIN and touch policies) is supported,
+    or it will raise a NotSupportedError if it is not.
+    """
+    if version[0] == 0 and version > (0, 1, 3):
+        return  # Development build, skip version checks
+
+    if version < (4, 0, 0):
+        if key_type == KEY_TYPE.ECCP384:
+            raise NotSupportedError("ECCP384 requires YubiKey 4 or later")
+        if touch_policy != TOUCH_POLICY.DEFAULT or pin_policy != PIN_POLICY.DEFAULT:
+            raise NotSupportedError("PIN/Touch policy requires YubiKey 4 or later")
+
+    if version < (4, 3, 0) and touch_policy == TOUCH_POLICY.CACHED:
+        raise NotSupportedError("Cached touch policy requires YubiKey 4.3 or later")
+
+    # ROCA
+    if (4, 2, 0) <= version < (4, 3, 5):
+        if generate and key_type.algorithm == ALGORITHM.RSA:
+            raise NotSupportedError("RSA key generation not supported on this YubiKey")
+
+    # FIPS
+    if (4, 4, 0) <= version < (4, 5, 0):
+        if key_type == KEY_TYPE.RSA1024:
+            raise NotSupportedError("RSA 1024 not supported on YubiKey FIPS")
+        if pin_policy == PIN_POLICY.NEVER:
+            raise NotSupportedError("PIN_POLICY.NEVER not allowed on YubiKey FIPS")
+
+
+def _parse_device_public_key(key_type, encoded):
+    data = Tlv.parse_dict(encoded)
+    if key_type.algorithm == ALGORITHM.RSA:
+        modulus = bytes2int(data[0x81])
+        exponent = bytes2int(data[0x82])
+        return rsa.RSAPublicNumbers(exponent, modulus).public_key(default_backend())
+    else:
+        if key_type == KEY_TYPE.ECCP256:
+            curve: Type[ec.EllipticCurve] = ec.SECP256R1
+        else:
+            curve = ec.SECP384R1
+
+        return ec.EllipticCurvePublicKey.from_encoded_point(curve(), data[0x86])
+
+
+class PivSession:
+    def __init__(self, connection: SmartCardConnection):
+        self.protocol = SmartCardProtocol(connection)
+        self.protocol.select(AID.PIV)
+        self._version = Version.from_bytes(
+            self.protocol.send_apdu(0, INS_GET_VERSION, 0, 0)
+        )
+        self.protocol.enable_touch_workaround(self.version)
+        if self.version >= (4, 0, 0):
+            self.protocol.apdu_format = ApduFormat.EXTENDED
+        self._current_pin_retries = 3
+        self._max_pin_retries = 3
+        logger.debug(f"PIV session initialized (version={self.version})")
+
+    @property
+    def version(self) -> Version:
+        return self._version
+
+    def reset(self) -> None:
+        logger.debug("Preparing PIV reset")
+
+        # Block PIN
+        logger.debug("Verify PIN with invalid attempts until blocked")
+        counter = self.get_pin_attempts()
+        while counter > 0:
+            try:
+                self.verify_pin("")
+            except InvalidPinError as e:
+                counter = e.attempts_remaining
+        logger.debug("PIN is blocked")
+
+        # Block PUK
+        logger.debug("Verify PUK with invalid attempts until blocked")
+        counter = 1
+        while counter > 0:
+            try:
+                self._change_reference(INS_RESET_RETRY, PIN_P2, "", "")
+            except InvalidPinError as e:
+                counter = e.attempts_remaining
+        logger.debug("PUK is blocked")
+
+        # Reset
+        logger.debug("Sending reset")
+        self.protocol.send_apdu(0, INS_RESET, 0, 0)
+        self._current_pin_retries = 3
+        self._max_pin_retries = 3
+
+        logger.info("PIV application data reset performed")
+
+    def authenticate(
+        self, key_type: MANAGEMENT_KEY_TYPE, management_key: bytes
+    ) -> None:
+        key_type = MANAGEMENT_KEY_TYPE(key_type)
+        logger.debug(f"Authenticating with key type: {key_type}")
+        response = self.protocol.send_apdu(
+            0,
+            INS_AUTHENTICATE,
+            key_type,
+            SLOT_CARD_MANAGEMENT,
+            Tlv(TAG_DYN_AUTH, Tlv(TAG_AUTH_WITNESS)),
+        )
+        witness = Tlv.unpack(TAG_AUTH_WITNESS, Tlv.unpack(TAG_DYN_AUTH, response))
+        challenge = os.urandom(key_type.challenge_len)
+
+        backend = default_backend()
+        cipher_key = _parse_management_key(key_type, management_key)
+        cipher = Cipher(cipher_key, modes.ECB(), backend)  # nosec
+        decryptor = cipher.decryptor()
+        decrypted = decryptor.update(witness) + decryptor.finalize()
+
+        response = self.protocol.send_apdu(
+            0,
+            INS_AUTHENTICATE,
+            key_type,
+            SLOT_CARD_MANAGEMENT,
+            Tlv(
+                TAG_DYN_AUTH,
+                Tlv(TAG_AUTH_WITNESS, decrypted) + Tlv(TAG_AUTH_CHALLENGE, challenge),
+            ),
+        )
+        encrypted = Tlv.unpack(TAG_AUTH_RESPONSE, Tlv.unpack(TAG_DYN_AUTH, response))
+        encryptor = cipher.encryptor()
+        expected = encryptor.update(challenge) + encryptor.finalize()
+        if not bytes_eq(expected, encrypted):
+            raise BadResponseError("Device response is incorrect")
+
+    def set_management_key(
+        self,
+        key_type: MANAGEMENT_KEY_TYPE,
+        management_key: bytes,
+        require_touch: bool = False,
+    ) -> None:
+        key_type = MANAGEMENT_KEY_TYPE(key_type)
+        logger.debug(f"Setting management key of type: {key_type}")
+
+        if key_type != MANAGEMENT_KEY_TYPE.TDES:
+            require_version(self.version, (5, 4, 0))
+        if len(management_key) != key_type.key_len:
+            raise ValueError("Management key must be %d bytes" % key_type.key_len)
+
+        self.protocol.send_apdu(
+            0,
+            INS_SET_MGMKEY,
+            0xFF,
+            0xFE if require_touch else 0xFF,
+            int2bytes(key_type) + Tlv(SLOT_CARD_MANAGEMENT, management_key),
+        )
+        logger.info("Management key set")
+
+    def verify_pin(self, pin: str) -> None:
+        logger.debug("Verifying PIN")
+        try:
+            self.protocol.send_apdu(0, INS_VERIFY, 0, PIN_P2, _pin_bytes(pin))
+            self._current_pin_retries = self._max_pin_retries
+        except ApduError as e:
+            retries = _retries_from_sw(self.version, e.sw)
+            if retries is None:
+                raise
+            self._current_pin_retries = retries
+            raise InvalidPinError(retries)
+
+    def get_pin_attempts(self) -> int:
+        logger.debug("Getting PIN attempts")
+        try:
+            return self.get_pin_metadata().attempts_remaining
+        except NotSupportedError:
+            try:
+                self.protocol.send_apdu(0, INS_VERIFY, 0, PIN_P2)
+                # Already verified, no way to know true count
+                logger.debug("Using cached value, may be incorrect.")
+                return self._current_pin_retries
+            except ApduError as e:
+                retries = _retries_from_sw(self.version, e.sw)
+                if retries is None:
+                    raise
+                self._current_pin_retries = retries
+                logger.debug("Using value from empty verify")
+                return retries
+
+    def change_pin(self, old_pin: str, new_pin: str) -> None:
+        logger.debug("Changing PIN")
+        self._change_reference(INS_CHANGE_REFERENCE, PIN_P2, old_pin, new_pin)
+        logger.info("New PIN set")
+
+    def change_puk(self, old_puk: str, new_puk: str) -> None:
+        logger.debug("Changing PUK")
+        self._change_reference(INS_CHANGE_REFERENCE, PUK_P2, old_puk, new_puk)
+        logger.info("New PUK set")
+
+    def unblock_pin(self, puk: str, new_pin: str) -> None:
+        logger.debug("Using PUK to set new PIN")
+        self._change_reference(INS_RESET_RETRY, PIN_P2, puk, new_pin)
+        logger.info("New PIN set")
+
+    def set_pin_attempts(self, pin_attempts: int, puk_attempts: int) -> None:
+        logger.debug(f"Setting PIN/PUK attempts ({pin_attempts}, {puk_attempts})")
+        self.protocol.send_apdu(0, INS_SET_PIN_RETRIES, pin_attempts, puk_attempts)
+        self._max_pin_retries = pin_attempts
+        self._current_pin_retries = pin_attempts
+        logger.info("PIN/PUK attempts set")
+
+    def get_pin_metadata(self) -> PinMetadata:
+        logger.debug("Getting PIN metadata")
+        return self._get_pin_puk_metadata(PIN_P2)
+
+    def get_puk_metadata(self) -> PinMetadata:
+        logger.debug("Getting PUK metadata")
+        return self._get_pin_puk_metadata(PUK_P2)
+
+    def get_management_key_metadata(self) -> ManagementKeyMetadata:
+        logger.debug("Getting management key metadata")
+        require_version(self.version, (5, 3, 0))
+        data = Tlv.parse_dict(
+            self.protocol.send_apdu(0, INS_GET_METADATA, 0, SLOT_CARD_MANAGEMENT)
+        )
+        policy = data[TAG_METADATA_POLICY]
+        return ManagementKeyMetadata(
+            MANAGEMENT_KEY_TYPE(data.get(TAG_METADATA_ALGO, b"\x03")[0]),
+            data[TAG_METADATA_IS_DEFAULT] != b"\0",
+            TOUCH_POLICY(policy[INDEX_TOUCH_POLICY]),
+        )
+
+    def get_slot_metadata(self, slot: SLOT) -> SlotMetadata:
+        slot = SLOT(slot)
+        logger.debug(f"Getting metadata for slot {slot}")
+        require_version(self.version, (5, 3, 0))
+        data = Tlv.parse_dict(self.protocol.send_apdu(0, INS_GET_METADATA, 0, slot))
+        policy = data[TAG_METADATA_POLICY]
+        return SlotMetadata(
+            KEY_TYPE(data[TAG_METADATA_ALGO][0]),
+            PIN_POLICY(policy[INDEX_PIN_POLICY]),
+            TOUCH_POLICY(policy[INDEX_TOUCH_POLICY]),
+            data[TAG_METADATA_ORIGIN][0] == ORIGIN_GENERATED,
+            data[TAG_METADATA_PUBLIC_KEY],
+        )
+
+    def sign(
+        self,
+        slot: SLOT,
+        key_type: KEY_TYPE,
+        message: bytes,
+        hash_algorithm: hashes.HashAlgorithm,
+        padding: Optional[AsymmetricPadding] = None,
+    ) -> bytes:
+        slot = SLOT(slot)
+        key_type = KEY_TYPE(key_type)
+        logger.debug(
+            f"Signing data with key in slot {slot} of type {key_type} using "
+            f"hash={hash_algorithm}, padding={padding}"
+        )
+        padded = _pad_message(key_type, message, hash_algorithm, padding)
+        return self._use_private_key(slot, key_type, padded, False)
+
+    def decrypt(
+        self, slot: SLOT, cipher_text: bytes, padding: AsymmetricPadding
+    ) -> bytes:
+        slot = SLOT(slot)
+        if len(cipher_text) == 1024 // 8:
+            key_type = KEY_TYPE.RSA1024
+        elif len(cipher_text) == 2048 // 8:
+            key_type = KEY_TYPE.RSA2048
+        else:
+            raise ValueError("Invalid length of ciphertext")
+        logger.debug(
+            f"Decrypting data with key in slot {slot} of type {key_type} using ",
+            f"padding={padding}",
+        )
+        padded = self._use_private_key(slot, key_type, cipher_text, False)
+        return _unpad_message(padded, padding)
+
+    def calculate_secret(
+        self, slot: SLOT, peer_public_key: ec.EllipticCurvePublicKey
+    ) -> bytes:
+        slot = SLOT(slot)
+        key_type = KEY_TYPE.from_public_key(peer_public_key)
+        if key_type.algorithm != ALGORITHM.EC:
+            raise ValueError("Unsupported key type")
+        logger.debug(
+            f"Performing key agreement with key in slot {slot} of type {key_type}"
+        )
+        data = peer_public_key.public_bytes(
+            Encoding.X962, PublicFormat.UncompressedPoint
+        )
+        return self._use_private_key(slot, key_type, data, True)
+
+    def get_object(self, object_id: int) -> bytes:
+        logger.debug(f"Reading data from object slot {hex(object_id)}")
+        if object_id == OBJECT_ID.DISCOVERY:
+            expected: int = OBJECT_ID.DISCOVERY
+        else:
+            expected = TAG_OBJ_DATA
+
+        try:
+            return Tlv.unpack(
+                expected,
+                self.protocol.send_apdu(
+                    0,
+                    INS_GET_DATA,
+                    0x3F,
+                    0xFF,
+                    Tlv(TAG_OBJ_ID, int2bytes(object_id)),
+                ),
+            )
+        except ValueError as e:
+            raise BadResponseError("Malformed object data", e)
+
+    def put_object(self, object_id: int, data: Optional[bytes] = None) -> None:
+        self.protocol.send_apdu(
+            0,
+            INS_PUT_DATA,
+            0x3F,
+            0xFF,
+            Tlv(TAG_OBJ_ID, int2bytes(object_id)) + Tlv(TAG_OBJ_DATA, data or b""),
+        )
+        logger.info(f"Data written to object slot {hex(object_id)}")
+
+    def get_certificate(self, slot: SLOT) -> x509.Certificate:
+        slot = SLOT(slot)
+        logger.debug(f"Reading certificate in slot {slot}")
+        try:
+            data = Tlv.parse_dict(self.get_object(OBJECT_ID.from_slot(slot)))
+        except ValueError:
+            raise BadResponseError("Malformed certificate data object")
+
+        cert_info = data.get(TAG_CERT_INFO)
+        if cert_info and cert_info[0] != 0:
+            raise NotSupportedError("Compressed certificates are not supported")
+
+        try:
+            return x509.load_der_x509_certificate(
+                data[TAG_CERTIFICATE], default_backend()
+            )
+        except Exception as e:
+            raise BadResponseError("Invalid certificate", e)
+
+    def put_certificate(self, slot: SLOT, certificate: x509.Certificate) -> None:
+        slot = SLOT(slot)
+        logger.debug(f"Storing certificate in slot {slot}")
+        cert_data = certificate.public_bytes(Encoding.DER)
+        data = (
+            Tlv(TAG_CERTIFICATE, cert_data) + Tlv(TAG_CERT_INFO, b"\0") + Tlv(TAG_LRC)
+        )
+        self.put_object(OBJECT_ID.from_slot(slot), data)
+
+    def delete_certificate(self, slot: SLOT) -> None:
+        slot = SLOT(slot)
+        logger.debug(f"Deleting certificate in slot {slot}")
+        self.put_object(OBJECT_ID.from_slot(slot))
+
+    def put_key(
+        self,
+        slot: SLOT,
+        private_key: Union[
+            rsa.RSAPrivateKeyWithSerialization,
+            ec.EllipticCurvePrivateKeyWithSerialization,
+        ],
+        pin_policy: PIN_POLICY = PIN_POLICY.DEFAULT,
+        touch_policy: TOUCH_POLICY = TOUCH_POLICY.DEFAULT,
+    ) -> None:
+        slot = SLOT(slot)
+        key_type = KEY_TYPE.from_public_key(private_key.public_key())
+        check_key_support(self.version, key_type, pin_policy, touch_policy, False)
+        ln = key_type.bit_len // 8
+        numbers = private_key.private_numbers()
+        if key_type.algorithm == ALGORITHM.RSA:
+            numbers = cast(rsa.RSAPrivateNumbers, numbers)
+            if numbers.public_numbers.e != 65537:
+                raise NotSupportedError("RSA exponent must be 65537")
+            ln //= 2
+            data = (
+                Tlv(0x01, int2bytes(numbers.p, ln))
+                + Tlv(0x02, int2bytes(numbers.q, ln))
+                + Tlv(0x03, int2bytes(numbers.dmp1, ln))
+                + Tlv(0x04, int2bytes(numbers.dmq1, ln))
+                + Tlv(0x05, int2bytes(numbers.iqmp, ln))
+            )
+        else:
+            numbers = cast(ec.EllipticCurvePrivateNumbers, numbers)
+            data = Tlv(0x06, int2bytes(numbers.private_value, ln))
+        if pin_policy:
+            data += Tlv(TAG_PIN_POLICY, int2bytes(pin_policy))
+        if touch_policy:
+            data += Tlv(TAG_TOUCH_POLICY, int2bytes(touch_policy))
+
+        logger.debug(
+            f"Importing key with pin_policy={pin_policy}, touch_policy={touch_policy}"
+        )
+        self.protocol.send_apdu(0, INS_IMPORT_KEY, key_type, slot, data)
+        logger.info(f"Private key imported in slot {slot} of type {key_type}")
+        return key_type
+
+    def generate_key(
+        self,
+        slot: SLOT,
+        key_type: KEY_TYPE,
+        pin_policy: PIN_POLICY = PIN_POLICY.DEFAULT,
+        touch_policy: TOUCH_POLICY = TOUCH_POLICY.DEFAULT,
+    ) -> Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey]:
+        slot = SLOT(slot)
+        key_type = KEY_TYPE(key_type)
+        check_key_support(self.version, key_type, pin_policy, touch_policy, True)
+        data: bytes = Tlv(TAG_GEN_ALGORITHM, int2bytes(key_type))
+        if pin_policy:
+            data += Tlv(TAG_PIN_POLICY, int2bytes(pin_policy))
+        if touch_policy:
+            data += Tlv(TAG_TOUCH_POLICY, int2bytes(touch_policy))
+
+        logger.debug(
+            f"Generating key with pin_policy={pin_policy}, touch_policy={touch_policy}"
+        )
+        response = self.protocol.send_apdu(
+            0, INS_GENERATE_ASYMMETRIC, 0, slot, Tlv(0xAC, data)
+        )
+        logger.info(f"Private key generated in slot {slot} of type {key_type}")
+        return _parse_device_public_key(key_type, Tlv.unpack(0x7F49, response))
+
+    def attest_key(self, slot: SLOT) -> x509.Certificate:
+        require_version(self.version, (4, 3, 0))
+        slot = SLOT(slot)
+        response = self.protocol.send_apdu(0, INS_ATTEST, slot, 0)
+        logger.debug(f"Attested key in slot {slot}")
+        return x509.load_der_x509_certificate(response, default_backend())
+
+    def _change_reference(self, ins, p2, value1, value2):
+        try:
+            self.protocol.send_apdu(
+                0, ins, 0, p2, _pin_bytes(value1) + _pin_bytes(value2)
+            )
+        except ApduError as e:
+            retries = _retries_from_sw(self.version, e.sw)
+            if retries is None:
+                raise
+            if p2 == PIN_P2:
+                self._current_pin_retries = retries
+            raise InvalidPinError(retries)
+
+    def _get_pin_puk_metadata(self, p2):
+        require_version(self.version, (5, 3, 0))
+        data = Tlv.parse_dict(self.protocol.send_apdu(0, INS_GET_METADATA, 0, p2))
+        attempts = data[TAG_METADATA_RETRIES]
+        return PinMetadata(
+            data[TAG_METADATA_IS_DEFAULT] != b"\0",
+            attempts[INDEX_RETRIES_TOTAL],
+            attempts[INDEX_RETRIES_REMAINING],
+        )
+
+    def _use_private_key(self, slot, key_type, message, exponentiation):
+        try:
+            response = self.protocol.send_apdu(
+                0,
+                INS_AUTHENTICATE,
+                key_type,
+                slot,
+                Tlv(
+                    TAG_DYN_AUTH,
+                    Tlv(TAG_AUTH_RESPONSE)
+                    + Tlv(
+                        TAG_AUTH_EXPONENTIATION
+                        if exponentiation
+                        else TAG_AUTH_CHALLENGE,
+                        message,
+                    ),
+                ),
+            )
+            return Tlv.unpack(
+                TAG_AUTH_RESPONSE,
+                Tlv.unpack(
+                    TAG_DYN_AUTH,
+                    response,
+                ),
+            )
+        except ApduError as e:
+            if e.sw == SW.INCORRECT_PARAMETERS:
+                raise e  # TODO: Different error, No key?
+            raise
```

### Comparing `yubikey_manager-5.1.0/PKG-INFO` & `yubikey_manager-5.1.1/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: yubikey-manager
-Version: 5.1.0
+Version: 5.1.1
 Summary: Tool for managing your YubiKey configuration.
 Home-page: https://github.com/Yubico/yubikey-manager
 License: BSD
 Keywords: yubikey,yubiotp,piv,fido
 Author: Dain Nilsson
 Author-email: dain@yubico.com
 Requires-Python: >=3.7,<4.0
```

