# Comparing `tmp/actoolkit-2.6.2-py3-none-any.whl.zip` & `tmp/actoolkit-2.6.3b2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,32 @@
-Zip file size: 75574 bytes, number of entries: 30
--rw-r--r--  2.0 unx    14685 b- defN 23-Mar-08 16:56 tkHelpers.py
--rw-r--r--  2.0 unx    51669 b- defN 23-Mar-08 16:56 tkParser.py
--rw-r--r--  2.0 unx    89637 b- defN 23-Mar-08 16:56 toolkit.py
--rw-r--r--  2.0 unx      456 b- defN 23-Mar-08 16:56 astraSDK/__init__.py
--rw-r--r--  2.0 unx     3659 b- defN 23-Mar-08 16:56 astraSDK/apiresources.py
--rw-r--r--  2.0 unx    16536 b- defN 23-Mar-08 16:56 astraSDK/apps.py
--rw-r--r--  2.0 unx     8248 b- defN 23-Mar-08 16:56 astraSDK/backups.py
--rw-r--r--  2.0 unx     7321 b- defN 23-Mar-08 16:56 astraSDK/buckets.py
--rw-r--r--  2.0 unx     6972 b- defN 23-Mar-08 16:56 astraSDK/clouds.py
--rw-r--r--  2.0 unx     9166 b- defN 23-Mar-08 16:56 astraSDK/clusters.py
--rw-r--r--  2.0 unx     8157 b- defN 23-Mar-08 16:56 astraSDK/common.py
--rw-r--r--  2.0 unx     9143 b- defN 23-Mar-08 16:56 astraSDK/credentials.py
--rw-r--r--  2.0 unx     2663 b- defN 23-Mar-08 16:56 astraSDK/entitlements.py
--rw-r--r--  2.0 unx     7162 b- defN 23-Mar-08 16:56 astraSDK/hooks.py
--rw-r--r--  2.0 unx     5398 b- defN 23-Mar-08 16:56 astraSDK/namespaces.py
--rw-r--r--  2.0 unx     3511 b- defN 23-Mar-08 16:56 astraSDK/notifications.py
--rw-r--r--  2.0 unx     8803 b- defN 23-Mar-08 16:56 astraSDK/protections.py
--rw-r--r--  2.0 unx     9735 b- defN 23-Mar-08 16:56 astraSDK/replications.py
--rw-r--r--  2.0 unx     5758 b- defN 23-Mar-08 16:56 astraSDK/rolebindings.py
--rw-r--r--  2.0 unx     7091 b- defN 23-Mar-08 16:56 astraSDK/scripts.py
--rw-r--r--  2.0 unx     7035 b- defN 23-Mar-08 16:56 astraSDK/snapshots.py
--rw-r--r--  2.0 unx     2342 b- defN 23-Mar-08 16:56 astraSDK/storagebackends.py
--rw-r--r--  2.0 unx     4726 b- defN 23-Mar-08 16:56 astraSDK/storageclasses.py
--rw-r--r--  2.0 unx     4877 b- defN 23-Mar-08 16:56 astraSDK/users.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     9307 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       36 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     2344 b- defN 23-Mar-08 16:56 actoolkit-2.6.2.dist-info/RECORD
-30 files, 317929 bytes uncompressed, 71892 bytes compressed:  77.4%
+Zip file size: 77282 bytes, number of entries: 30
+-rw-r--r--  2.0 unx    18774 b- defN 23-Apr-27 14:57 tkHelpers.py
+-rw-r--r--  2.0 unx    53562 b- defN 23-Apr-27 14:57 tkParser.py
+-rw-r--r--  2.0 unx    91450 b- defN 23-Apr-27 14:57 toolkit.py
+-rw-r--r--  2.0 unx      456 b- defN 23-Apr-27 14:57 astraSDK/__init__.py
+-rw-r--r--  2.0 unx     3659 b- defN 23-Apr-27 14:57 astraSDK/apiresources.py
+-rw-r--r--  2.0 unx    16835 b- defN 23-Apr-27 14:57 astraSDK/apps.py
+-rw-r--r--  2.0 unx     8248 b- defN 23-Apr-27 14:57 astraSDK/backups.py
+-rw-r--r--  2.0 unx     7321 b- defN 23-Apr-27 14:57 astraSDK/buckets.py
+-rw-r--r--  2.0 unx     6972 b- defN 23-Apr-27 14:57 astraSDK/clouds.py
+-rw-r--r--  2.0 unx     9155 b- defN 23-Apr-27 14:57 astraSDK/clusters.py
+-rw-r--r--  2.0 unx     8157 b- defN 23-Apr-27 14:57 astraSDK/common.py
+-rw-r--r--  2.0 unx     9115 b- defN 23-Apr-27 14:57 astraSDK/credentials.py
+-rw-r--r--  2.0 unx     2663 b- defN 23-Apr-27 14:57 astraSDK/entitlements.py
+-rw-r--r--  2.0 unx     7162 b- defN 23-Apr-27 14:57 astraSDK/hooks.py
+-rw-r--r--  2.0 unx     5398 b- defN 23-Apr-27 14:57 astraSDK/namespaces.py
+-rw-r--r--  2.0 unx     3511 b- defN 23-Apr-27 14:57 astraSDK/notifications.py
+-rw-r--r--  2.0 unx     8803 b- defN 23-Apr-27 14:57 astraSDK/protections.py
+-rw-r--r--  2.0 unx     9735 b- defN 23-Apr-27 14:57 astraSDK/replications.py
+-rw-r--r--  2.0 unx     5758 b- defN 23-Apr-27 14:57 astraSDK/rolebindings.py
+-rw-r--r--  2.0 unx     7091 b- defN 23-Apr-27 14:57 astraSDK/scripts.py
+-rw-r--r--  2.0 unx     7035 b- defN 23-Apr-27 14:57 astraSDK/snapshots.py
+-rw-r--r--  2.0 unx     2342 b- defN 23-Apr-27 14:57 astraSDK/storagebackends.py
+-rw-r--r--  2.0 unx     4726 b- defN 23-Apr-27 14:57 astraSDK/storageclasses.py
+-rw-r--r--  2.0 unx     4877 b- defN 23-Apr-27 14:57 astraSDK/users.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9310 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       36 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2356 b- defN 23-Apr-27 14:58 actoolkit-2.6.3b2.dist-info/RECORD
+30 files, 325999 bytes uncompressed, 73576 bytes compressed:  77.4%
```

## zipnote {}

```diff
@@ -66,26 +66,26 @@
 
 Filename: astraSDK/storageclasses.py
 Comment: 
 
 Filename: astraSDK/users.py
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/LICENSE
+Filename: actoolkit-2.6.3b2.dist-info/LICENSE
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/METADATA
+Filename: actoolkit-2.6.3b2.dist-info/METADATA
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/WHEEL
+Filename: actoolkit-2.6.3b2.dist-info/WHEEL
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/entry_points.txt
+Filename: actoolkit-2.6.3b2.dist-info/entry_points.txt
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/top_level.txt
+Filename: actoolkit-2.6.3b2.dist-info/top_level.txt
 Comment: 
 
-Filename: actoolkit-2.6.2.dist-info/RECORD
+Filename: actoolkit-2.6.3b2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tkHelpers.py

```diff
@@ -363,7 +363,107 @@
     else:
         print(
             f"Error: '{string}' must consist of lower case alphanumeric characters or '-', must "
             + "start and end with an alphanumeric character, and must be at most 63 characters "
             + "(for example 'my-name' or '123-abc')."
         )
         sys.exit(15)
+
+
+def dupeKeyError(key):
+    """Print an error message if duplicate keys are used"""
+    print(f"Error: '{key}' should not be specified multiple times within a single --filterSet arg")
+    sys.exit(1)
+
+
+def createSetDict(setDict, filterStr, assets):
+    """Given a filterStr such as:
+        label=app.kubernetes.io/tier=backend,name=mysql,kind=Deployment
+    Return a setDict with the following format:
+        {
+            "labelSelectors": ["app.kubernetes.io/tier=backend"],
+            "names": ["mysql"],
+            "kind": "Deployment",
+        }
+    Also verifies that the GVK choices are valid options for the given app."""
+    for f in filterStr.split(","):
+        key = f.split("=")[0].lower()
+        val = f.split("=", 1)[1]
+        if "namespace" in key:
+            setDict.setdefault("namespaces", []).append(isRFC1123(val))
+        elif "name" in key:
+            setDict.setdefault("names", []).append(isRFC1123(val))
+        elif "label" in key:
+            setDict.setdefault("labelSelectors", []).append(val)
+        elif "group" in key:
+            setDict["group"] = val if not setDict.get("group") else dupeKeyError("group")
+        elif "version" in key:
+            setDict["version"] = val if not setDict.get("version") else dupeKeyError("version")
+        elif "kind" in key:
+            setDict["kind"] = val if not setDict.get("kind") else dupeKeyError("kind")
+        else:
+            print(
+                f"Error: '{key}' not one of ['namespace', 'name', 'label', 'group', 'version', "
+                "'kind']"
+            )
+            sys.exit(1)
+    # Validate the inputs are valid assets for this app
+    for key in ["group", "version", "kind"]:
+        if setDict.get(key) and setDict[key] not in [a["GVK"][key] for a in assets["items"]]:
+            print(
+                f"Error: '{setDict[key]}' is not a valid '{key}' for this application, please run "
+                f"'list assets {assets['metadata']['appID']}' to view possible '{key}' choices"
+            )
+            sys.exit(1)
+    # Validate the inputs are valid GVK combinations
+    for key1 in ["group", "version", "kind"]:
+        for key2 in ["group", "version", "kind"]:
+            if key1 == key2:
+                continue
+            if setDict.get(key1) and setDict.get(key2):
+                if setDict[key1] not in [
+                    a["GVK"][key1] for a in assets["items"] if a["GVK"][key2] == setDict[key2]
+                ]:
+                    print(
+                        f"Error: '{key1}={setDict[key1]}' does not match with "
+                        f"'{key2}={setDict[key2]}', please run 'list assets "
+                        f"{assets['metadata']['appID']}' to view valid GVK combinations"
+                    )
+                    sys.exit(1)
+
+
+def createFilterSet(selection, filters, assets):
+    """createFilterSet takes in a selection string, and a filters array of arrays, for example:
+        [
+            ['group=apps,version=v1,kind=Deployment'],
+            ['label=app.kubernetes.io/tier=backend,name=mysql,namespace=wordpress']
+        ]
+    And returns an object for use in a restore filter, like so:
+        {
+            "GVKN": [
+                {
+                    "group": "apps",
+                    "version": "v1",
+                    "kind": "Deployment",
+                },
+                {
+                    "labelSelectors": ["app.kubernetes.io/tier=backend"],
+                    "names": ["mysql"],
+                    "namespaces": ["wordpress"],
+                },
+            ],
+            "resourceSelectionCriteria": "include",
+        }
+    Also performs validation to ensure that the given appID contains GVK asset type.
+    """
+    if selection is None:
+        return None
+    rFilter = {"GVKN": [], "resourceSelectionCriteria": selection}
+    for fil in filters:
+        setDict = {}
+        if type(fil) == list:
+            for f in fil:
+                createSetDict(setDict, f, assets)
+        else:
+            createSetDict(setDict, fil, assets)
+        rFilter["GVKN"].append(setDict)
+    return rFilter
```

## tkParser.py

```diff
@@ -59,19 +59,19 @@
         )
         self.parserDeploy = self.subparsers.add_parser(
             "deploy",
             help="Deploy a helm chart",
         )
         self.parserClone = self.subparsers.add_parser(
             "clone",
-            help="Clone an app",
+            help="Clone an app from a backup, snapshot, or running app (live clone)",
         )
         self.parserRestore = self.subparsers.add_parser(
             "restore",
-            help="Restore an app from a backup or snapshot",
+            help="In-Place Restore (IPR) an app from a backup or snapshot",
         )
         self.parserList = self.subparsers.add_parser(
             "list",
             aliases=["get"],
             help="List all items in a class",
         )
         self.parserCreate = self.subparsers.add_parser(
@@ -410,23 +410,42 @@
             help="Source snapshot to clone from",
         )
         sourceGroup.add_argument(
             "--sourceAppID",
             choices=(None if self.plaidMode else appList),
             required=False,
             default=None,
-            help="Source app to clone",
+            help="Source app to live clone",
         )
         self.parserClone.add_argument(
             "-t",
             "--pollTimer",
             type=int,
             default=5,
             help="The frequency (seconds) to poll the operation status (default: %(default)s)",
         )
+        filterGroup = self.parserClone.add_argument_group(
+            title="filter group", description="optionally clone a subset of resources via filters"
+        )
+        filterGroup.add_argument(
+            "--filterSelection",
+            choices=["include", "exclude"],
+            default=None,
+            help="How the resource filter(s) select resources",
+        )
+        filterGroup.add_argument(
+            "--filterSet",
+            default=None,
+            action="append",
+            nargs="*",
+            help=r"A comma separated set of key=value filter pairs, where 'key' is one of "
+            "['namespace', 'name', 'label', 'group', 'version', 'kind']. This argument can be "
+            "specified multiple times for multiple filter sets:\n--filterSet version=v1,kind="
+            "PersistentVolumeClaim --filterSet label=app.kubernetes.io/tier=backend,name=mysql",
+        )
 
     def restore_args(self, appList, backupList, snapshotList):
         """restore args and flags"""
         self.parserRestore.add_argument(
             "-b",
             "--background",
             default=False,
@@ -456,14 +475,33 @@
         self.parserRestore.add_argument(
             "-t",
             "--pollTimer",
             type=int,
             default=5,
             help="The frequency (seconds) to poll the operation status (default: %(default)s)",
         )
+        filterGroup = self.parserRestore.add_argument_group(
+            title="filter group", description="optionally restore a subset of resources via filters"
+        )
+        filterGroup.add_argument(
+            "--filterSelection",
+            choices=["include", "exclude"],
+            default=None,
+            help="How the resource filter(s) select resources",
+        )
+        filterGroup.add_argument(
+            "--filterSet",
+            default=None,
+            action="append",
+            nargs="*",
+            help=r"A comma separated set of key=value filter pairs, where 'key' is one of "
+            "['namespace', 'name', 'label', 'group', 'version', 'kind']. This argument can be "
+            "specified multiple times for multiple filter sets:\n--filterSet version=v1,kind="
+            "PersistentVolumeClaim --filterSet label=app.kubernetes.io/tier=backend,name=mysql",
+        )
 
     def list_apiresources_args(self):
         """list api resources args and flags"""
         self.subparserListApiResources.add_argument(
             "-c", "--cluster", default=None, help="Only show api resources from this cluster"
         )
 
@@ -1048,15 +1086,15 @@
             "-c",
             "--clusterScopedResource",
             required=False,
             default=None,
             nargs="*",
             action="append",
             help="Any number of clusterScopedResources (and optional labelSelectors), one set per"
-            + " argument (-a csr-kind1 -a csr-kind2 app=appname)",
+            + " argument (-c csr-kind1 -c csr-kind2 app=appname)",
         )
 
     def manage_bucket_args(self, credentialList):
         """manage bucket args and flags"""
         self.subparserManageBucket.add_argument(
             "provider",
             choices=["aws", "azure", "gcp", "generic-s3", "ontap-s3", "storagegrid-s3"],
```

## toolkit.py

```diff
@@ -73,15 +73,15 @@
                             if i.metadata.name == sc[0]:
                                 pgStorageClass = sc[1]
             if pgStorageClass:
                 setStr += f" --set postgresql.global.storageClass={pgStorageClass}"
                 setStr += f" --set gitlab.gitaly.persistence.storageClass={pgStorageClass}"
 
         tkHelpers.run(f"helm install {appName} {chart}{setStr}{valueStr}")
-        print("Waiting for Astra to discover the namespace.", end="")
+        print("Waiting for Astra to discover the namespace", end="")
         sys.stdout.flush()
 
         appID = ""
         while not appID:
             # It takes Astra some time to realize new apps have been installed
             time.sleep(3)
             print(".", end="")
@@ -125,14 +125,15 @@
                             appID = rc["id"]
                             print("Success!")
                             break
                         else:
                             sys.exit(1)
 
         # Create a protection policy on that namespace (using its appID)
+        time.sleep(5)
         backupRetention = "1"
         snapshotRetention = "1"
         minute = "0"
         cpp = astraSDK.protections.createProtectionpolicy(quiet=True)
         cppData = {
             "hourly": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "*"},
             "daily": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "2"},
@@ -164,15 +165,17 @@
         oApp,
         namespaceMapping,
         backupID,
         snapshotID,
         sourceAppID,
         background,
         pollTimer,
+        resourceFilter,
         verbose,
+        quiet,
     ):
         """Create a clone."""
         # Check to see if cluster-level resources are needed to be manually created
         needsIngressclass = False
         appAssets = astraSDK.apps.getAppAssets(verbose=verbose).main(oApp["id"])
         for asset in appAssets["items"]:
             if (
@@ -307,22 +310,23 @@
             except kubernetes.client.rest.ApiException as e:
                 # If the failure is due to the resource already existing, then we're all set,
                 # otherwise it's more serious and we must raise an exception
                 body = json.loads(e.body)
                 if not (body.get("reason") == "AlreadyExists"):
                     raise SystemExit(f"Error: Kubernetes resource creation failed\n{e}")
 
-        cloneRet = astraSDK.apps.cloneApp(verbose=verbose).main(
+        cloneRet = astraSDK.apps.cloneApp(verbose=verbose, quiet=quiet).main(
             cloneAppName,
             clusterID,
             oApp["clusterID"],
             namespaceMapping=namespaceMapping,
             backupID=backupID,
             snapshotID=snapshotID,
             sourceAppID=sourceAppID,
+            resourceFilter=resourceFilter,
         )
         if cloneRet:
             print("Submitting clone succeeded.")
             if background:
                 print(f"Background clone flag selected, run 'list apps' to get status.")
                 return True
             print("Waiting for clone to become available.", end="")
@@ -333,14 +337,18 @@
                 apps = astraSDK.apps.getApps().main()
                 for app in apps["items"]:
                     if app["id"] == appID:
                         if app["state"] == "ready":
                             state = app["state"]
                             print("Cloning operation complete.")
                             sys.stdout.flush()
+                        elif app["state"] == "failed":
+                            print(f"Error: \"{app['name']}\" in a failed state")
+                            sys.stdout.flush()
+                            sys.exit(1)
                         else:
                             print(".", end="")
                             sys.stdout.flush()
                             time.sleep(pollTimer)
         else:
             print("Submitting clone failed.")
 
@@ -1551,16 +1559,29 @@
                                 sys.exit(1)
                 sys.exit(0)
             else:
                 print("astraSDK.clusters.unmanageCloud() failed")
                 sys.exit(1)
 
     elif args.subcommand == "restore":
+        if (args.filterSelection and not args.filterSet) or (
+            args.filterSet and not args.filterSelection
+        ):
+            print(
+                f"{' '.join(sys.argv[0:verbPosition+1])}: error: either both or none of "
+                "--filterSelection and --filterSet should be specified"
+            )
+            sys.exit(1)
         rc = astraSDK.apps.restoreApp(quiet=args.quiet, verbose=args.verbose).main(
-            args.appID, backupID=args.backupID, snapshotID=args.snapshotID
+            args.appID,
+            backupID=args.backupID,
+            snapshotID=args.snapshotID,
+            resourceFilter=tkHelpers.createFilterSet(
+                args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(args.appID)
+            ),
         )
         if rc:
             if args.background:
                 print("Restore job submitted successfully")
                 print("Background restore flag selected, run 'list apps' to get status")
                 sys.exit(0)
             print("Restore job in progress...", end="")
@@ -1582,14 +1603,28 @@
                     sys.exit(2)
                 time.sleep(args.pollTimer)
         else:
             print("Submitting restore job failed.")
             sys.exit(3)
 
     elif args.subcommand == "clone":
+        if (args.filterSelection and not args.filterSet) or (
+            args.filterSet and not args.filterSelection
+        ):
+            print(
+                f"{' '.join(sys.argv[0:verbPosition+1])}: error: either both or none of "
+                "--filterSelection and --filterSet should be specified"
+            )
+            sys.exit(1)
+        if args.filterSet and args.sourceAppID:
+            print(
+                "Error: resource filters (--filterSet) may only be specified with --backupID "
+                "or --snapshotID arguments, not --sourceAppID"
+            )
+            sys.exit(1)
         if not args.cloneAppName:
             args.cloneAppName = input("App name for the clone: ")
         if not args.clusterID:
             print("Select destination cluster for the clone")
             print("Index\tClusterID\t\t\t\tclusterName\tclusterPlatform")
             args.clusterID = tkHelpers.userSelect(destCluster, ["id", "name", "clusterType"])
         # Get the original app dictionary based on args.sourceAppID/args.backupID/args.snapshotID,
@@ -1625,20 +1660,24 @@
             sys.exit(1)
 
         tk.doClone(
             tkHelpers.isRFC1123(args.cloneAppName),
             args.clusterID,
             oApp,
             tkHelpers.createNamespaceMapping(oApp, args.cloneNamespace, args.multiNsMapping),
-            backupID=args.backupID,
-            snapshotID=args.snapshotID,
-            sourceAppID=args.sourceAppID,
-            background=args.background,
-            pollTimer=args.pollTimer,
-            verbose=args.verbose,
+            args.backupID,
+            args.snapshotID,
+            args.sourceAppID,
+            args.background,
+            args.pollTimer,
+            tkHelpers.createFilterSet(
+                args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(oApp["id"])
+            ),
+            args.verbose,
+            args.quiet,
         )
 
     elif args.subcommand == "update":
         if args.objectType == "bucket":
             # Validate that both credentialID and accessKey/accessSecret were not specified
             if args.credentialID is not None and (
                 args.accessKey is not None or args.accessSecret is not None
@@ -1656,22 +1695,26 @@
                         + "accessSecret arguments must be provided."
                     )
                     sys.exit(1)
                 if plaidMode:
                     bucketDict = astraSDK.buckets.getBuckets().main()
                 encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
                 encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
-                crc = astraSDK.credentials.createCredential(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    next(b for b in bucketDict["items"] if b["id"] == args.bucketID)["name"],
-                    "s3",
-                    {"accessKey": encodedKey, "accessSecret": encodedSecret},
-                    cloudName="s3",
-                )
+                try:
+                    crc = astraSDK.credentials.createCredential(
+                        quiet=args.quiet, verbose=args.verbose
+                    ).main(
+                        next(b for b in bucketDict["items"] if b["id"] == args.bucketID)["name"],
+                        "s3",
+                        {"accessKey": encodedKey, "accessSecret": encodedSecret},
+                        cloudName="s3",
+                    )
+                except StopIteration:
+                    print(f"Error: {args.bucketID} does not seem to be a valid bucketID")
+                    sys.exit(1)
                 if crc:
                     args.credentialID = crc["id"]
                 else:
                     print("astraSDK.credentials.createCredential() failed")
                     sys.exit(1)
             # Call updateBucket class
             rc = astraSDK.buckets.updateBucket(quiet=args.quiet, verbose=args.verbose).main(
@@ -1738,15 +1781,15 @@
                     encodedStr = base64.b64encode(
                         json.dumps(kubeconfigDict).encode("utf-8")
                     ).decode("utf-8")
                 rc = astraSDK.credentials.updateCredential(
                     quiet=args.quiet, verbose=args.verbose
                 ).main(
                     cluster.get("credentialID"),
-                    credName=kubeconfigDict["clusters"][0]["name"],
+                    kubeconfigDict["clusters"][0]["name"],
                     keyStore={"base64": encodedStr},
                 )
                 if rc:
                     sys.exit(0)
                 else:
                     print("astraSDK.credentials.updateCredential() failed")
                     sys.exit(1)
```

## astraSDK/apps.py

```diff
@@ -315,14 +315,15 @@
         cloneName,
         clusterID,
         sourceClusterID,
         namespaceMapping=None,
         backupID=None,
         snapshotID=None,
         sourceAppID=None,
+        resourceFilter=None,
     ):
         assert backupID or snapshotID or sourceAppID
 
         endpoint = "k8s/v2/apps"
         url = self.base + endpoint
         params = {}
         data = {
@@ -336,14 +337,16 @@
             data["sourceAppID"] = sourceAppID
         if backupID:
             data["backupID"] = backupID
         if snapshotID:
             data["snapshotID"] = snapshotID
         if namespaceMapping:
             data["namespaceMapping"] = namespaceMapping
+        if resourceFilter:
+            data["restoreFilter"] = resourceFilter
 
         ret = super().apicall(
             "post",
             url,
             data,
             self.headers,
             params,
@@ -352,24 +355,23 @@
             verbose=self.verbose,
         )
 
         if ret.ok:
             results = super().jsonifyResults(ret)
             if not self.quiet:
                 print(json.dumps(results))
-            else:
-                return results
+            return results
         else:
             if not self.quiet:
                 super().printError(ret)
             return False
 
 
 class restoreApp(SDKCommon):
-    """Restore a backup or snapshot of an app.
+    """In place Restore (IPR) an app from a backup or snapshot.
     Must pass in an AppID and either a snapshotID or a backupID
     Note that this is a destructive operation that overwrites the current AppID
     with the backup/snapshot.
 
     Also note that the return code this class returns is referring to submitting
     the restore job.  To know if the restore job itself succeeds or fails you
     need to monitor the state of the app, watching for it to switch from
@@ -387,28 +389,31 @@
         self.headers["ForceUpdate"] = "true"
 
     def main(
         self,
         appID,
         backupID=None,
         snapshotID=None,
+        resourceFilter=None,
     ):
         assert backupID or snapshotID
 
         endpoint = f"k8s/v2/apps/{appID}"
         url = self.base + endpoint
         params = {}
         data = {
             "type": "application/astra-app",
             "version": "2.0",
         }
         if backupID:
             data["backupID"] = backupID
         elif snapshotID:
             data["snapshotID"] = snapshotID
+        if resourceFilter:
+            data["restoreFilter"] = resourceFilter
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
@@ -453,22 +458,23 @@
             self.verifySSL,
             quiet=self.quiet,
             verbose=self.verbose,
         )
 
         if ret.ok:
             assets = super().jsonifyResults(ret)
+            assets["metadata"]["appID"] = appID
             if self.output == "json":
                 dataReturn = assets
             elif self.output == "yaml":
                 dataReturn = yaml.dump(assets)
             elif self.output == "table":
                 dataReturn = self.basicTable(
-                    ["assetName", "assetType"],
-                    ["assetName", "assetType"],
+                    ["assetName", "group", "version", "kind"],
+                    ["assetName", "GVK.group", "GVK.version", "GVK.kind"],
                     assets,
                 )
             if not self.quiet:
                 print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
             return dataReturn
 
         else:
```

## astraSDK/clusters.py

```diff
@@ -85,26 +85,26 @@
         elif self.output == "table":
             dataReturn = self.basicTable(
                 [
                     "clusterName",
                     "clusterID",
                     "clusterType",
                     "location",
+                    "state",
                     "managedState",
-                    "tridentState",
-                    "tridentVersion",
+                    "tridentStateAllowed",
                 ],
                 [
                     "name",
                     "id",
                     "clusterType",
                     "location",
+                    "state",
                     "managedState",
                     "tridentManagedStateAllowed",
-                    "tridentVersion",
                 ],
                 clusters,
             )
 
         if not self.quiet:
             print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
         return dataReturn
```

## astraSDK/credentials.py

```diff
@@ -85,15 +85,15 @@
                                 cloudName = label["value"]
                             elif label["name"] == "astra.netapp.io/labels/read-only/clusterName":
                                 clusterName = label["value"]
                     tabData.append(
                         [
                             cred["name"],
                             cred["id"],
-                            (cred["keyType"] if not credType else credType),
+                            (cred.get("keyType") if not credType else credType),
                             cloudName,
                             clusterName,
                         ]
                     )
                 dataReturn = tabulate(tabData, tabHeader, tablefmt="grid")
             if not self.quiet:
                 print(json.dumps(dataReturn) if type(dataReturn) is dict else dataReturn)
@@ -219,26 +219,25 @@
         verbose: Print all of the ReST call info: URL, Method, Headers, Request Body"""
         self.quiet = quiet
         self.verbose = verbose
         super().__init__()
         self.headers["accept"] = "application/astra-credential+json"
         self.headers["Content-Type"] = "application/astra-credential+json"
 
-    def main(self, credentialID, credName=None, keyStore=None):
+    def main(self, credentialID, credName, keyStore=None):
         endpoint = f"core/v1/credentials/{credentialID}"
         url = self.base + endpoint
         params = {}
         data = {
             "type": "application/astra-credential",
             "version": "1.1",
+            "name": credName,
         }
         if keyStore:
             data["keyStore"] = keyStore
-        if credName:
-            data["name"] = credName
 
         ret = super().apicall(
             "put",
             url,
             data,
             self.headers,
             params,
```

## Comparing `actoolkit-2.6.2.dist-info/LICENSE` & `actoolkit-2.6.3b2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `actoolkit-2.6.2.dist-info/METADATA` & `actoolkit-2.6.3b2.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: actoolkit
-Version: 2.6.2
+Version: 2.6.3b2
 Summary: Toolkit and SDK for interacting with Astra Control
 Home-page: https://github.com/NetApp/netapp-astra-toolkits
 Author: Michael Haigh
 Author-email: Michael.Haigh@netapp.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
@@ -13,16 +13,16 @@
 License-File: LICENSE
 Requires-Dist: certifi (==2022.12.7)
 Requires-Dist: chardet (>=5.0.0)
 Requires-Dist: idna (==3.4)
 Requires-Dist: PyYAML (==6.0)
 Requires-Dist: requests (==2.28.2)
 Requires-Dist: tabulate (==0.9.0)
-Requires-Dist: termcolor (==2.2.0)
-Requires-Dist: urllib3 (==1.26.14)
+Requires-Dist: termcolor (==2.3.0)
+Requires-Dist: urllib3 (==1.26.15)
 Requires-Dist: func-timeout (==4.3.5)
 Requires-Dist: kubernetes (==25.3.0)
 
 # NetApp Astra Control Python SDK
 
 The NetApp Astra Control Python SDK is designed to provide guidance for working with the NetApp Astra Control API.
 
@@ -114,15 +114,15 @@
 ```
 
 ### 1. Docker Installation
 
 Launch the prepared Docker image. Docker will automatically download the image if you don't already have it on your system.
 
 ```text
-docker run -it netapp/astra-toolkits:2.6.2 /bin/bash
+docker run -it netapp/astra-toolkits:latest /bin/bash
 ```
 
 NOTE: From this point forward, you will be working in the Docker container you just launched.
 
 Set up your kubeconfig to successfully run kubectl commands against your cluster with the appropriate command (e.g. `export KUBECONFIG=/path/to/kubeconfig`, `gcloud container clusters get-credentials`, `az aks get-credentials`, or `aws eks update-kubeconfig`).
 
 Configure your `config.yaml` as detailed in the [authentication](#authentication) section.
```

