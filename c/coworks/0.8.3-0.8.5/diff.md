# Comparing `tmp/coworks-0.8.3-py2.py3-none-any.whl.zip` & `tmp/coworks-0.8.5-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,20 @@
-Zip file size: 85578 bytes, number of entries: 88
+Zip file size: 86691 bytes, number of entries: 88
 -rw-rw-r--  2.0 unx      241 b- defN 22-Jul-30 18:16 coworks/__init__.py
 -rw-rw-r--  2.0 unx     2539 b- defN 23-Feb-02 09:07 coworks/aws.py
--rw-rw-r--  2.0 unx    17917 b- defN 23-Feb-13 15:59 coworks/coworks.py
+-rw-rw-r--  2.0 unx    17847 b- defN 23-Apr-27 10:54 coworks/coworks.py
 -rw-rw-r--  2.0 unx      170 b- defN 22-Sep-19 10:20 coworks/globals.py
 -rw-rw-r--  2.0 unx      208 b- defN 22-Dec-29 17:27 coworks/operators.py
 -rw-rw-r--  2.0 unx      204 b- defN 22-Dec-29 17:27 coworks/sensors.py
--rw-rw-r--  2.0 unx    12339 b- defN 23-Feb-16 09:58 coworks/utils.py
--rw-rw-r--  2.0 unx       22 b- defN 23-Feb-16 10:13 coworks/version.py
--rw-rw-r--  2.0 unx     5638 b- defN 23-Feb-16 10:06 coworks/wrappers.py
+-rw-rw-r--  2.0 unx    12242 b- defN 23-Apr-27 10:54 coworks/utils.py
+-rw-rw-r--  2.0 unx       22 b- defN 23-Apr-27 10:54 coworks/version.py
+-rw-rw-r--  2.0 unx     8358 b- defN 23-Apr-27 10:54 coworks/wrappers.py
 -rw-rw-r--  2.0 unx     1089 b- defN 23-Feb-02 09:07 coworks/biz/__init__.py
--rw-rw-r--  2.0 unx     3613 b- defN 23-Feb-13 15:59 coworks/biz/group.py
--rw-rw-r--  2.0 unx    10928 b- defN 23-Feb-16 10:06 coworks/biz/operators.py
+-rw-rw-r--  2.0 unx     4583 b- defN 23-Apr-27 10:54 coworks/biz/group.py
+-rw-rw-r--  2.0 unx    12294 b- defN 23-Apr-27 10:54 coworks/biz/operators.py
 -rw-rw-r--  2.0 unx     1761 b- defN 23-Feb-02 09:07 coworks/biz/sensors.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Dec-07 10:43 coworks/blueprint/__init__.py
 -rw-rw-r--  2.0 unx     7278 b- defN 23-Feb-02 09:08 coworks/blueprint/admin_blueprint.py
 -rw-rw-r--  2.0 unx     5022 b- defN 23-Feb-02 09:07 coworks/blueprint/gsheets_blueprint.py
 -rw-rw-r--  2.0 unx     6891 b- defN 23-Feb-13 15:59 coworks/blueprint/mail_blueprint.py
 -rw-rw-r--  2.0 unx     3761 b- defN 23-Feb-13 15:59 coworks/blueprint/okta_blueprint.py
 -rw-rw-r--  2.0 unx      490 b- defN 23-Feb-02 09:07 coworks/blueprint/profiler_blueprint.py
@@ -25,15 +25,15 @@
 -rw-rw-r--  2.0 unx    22580 b- defN 23-Feb-04 11:34 coworks/cws/deploy.py
 -rw-rw-r--  2.0 unx      136 b- defN 21-Dec-07 10:43 coworks/cws/exception.py
 -rw-rw-r--  2.0 unx     1381 b- defN 23-Feb-02 09:07 coworks/cws/new.py
 -rw-rw-r--  2.0 unx     2085 b- defN 23-Feb-13 15:59 coworks/cws/utils.py
 -rw-rw-r--  2.0 unx     5265 b- defN 23-Feb-02 09:07 coworks/cws/zip.py
 -rw-rw-r--  2.0 unx     1091 b- defN 23-Feb-02 09:07 coworks/cws/project_templates/README.md
 -rw-rw-r--  2.0 unx       12 b- defN 23-Feb-02 09:07 coworks/cws/project_templates/template.env
--rw-rw-r--  2.0 unx     1315 b- defN 23-Feb-02 09:07 coworks/cws/project_templates/tech/app.py
+-rw-rw-r--  2.0 unx     1333 b- defN 23-Apr-27 10:54 coworks/cws/project_templates/tech/app.py
 -rw-rw-r--  2.0 unx       49 b- defN 22-Jul-30 18:16 coworks/cws/templates/deploy.j2
 -rw-rw-r--  2.0 unx       51 b- defN 22-Jul-30 18:16 coworks/cws/templates/destroy.j2
 -rw-rw-r--  2.0 unx      196 b- defN 21-Jan-06 14:45 coworks/cws/templates/list.j2
 -rw-rw-r--  2.0 unx      294 b- defN 22-Sep-19 10:20 coworks/cws/templates/project.cws.yml
 -rw-rw-r--  2.0 unx     1556 b- defN 23-Feb-02 09:07 coworks/cws/templates/terraform.j2
 -rw-rw-r--  2.0 unx      300 b- defN 21-Dec-29 08:39 coworks/cws/templates/terraform/deploy.j2
 -rw-rw-r--  2.0 unx     3347 b- defN 23-Feb-02 09:31 coworks/cws/templates/terraform/lambda.j2
@@ -42,49 +42,49 @@
 -rw-rw-r--  2.0 unx      946 b- defN 22-Jul-30 18:16 coworks/cws/templates/terraform/provider.j2
 -rw-rw-r--  2.0 unx     2791 b- defN 22-Oct-20 14:35 coworks/cws/templates/terraform/request_templates.j2
 -rw-rw-r--  2.0 unx     1245 b- defN 23-Feb-02 09:07 coworks/cws/templates/terraform/response_templates.j2
 -rw-rw-r--  2.0 unx    11324 b- defN 23-Feb-02 09:07 coworks/cws/templates/terraform/rest_api.j2
 -rw-rw-r--  2.0 unx     3111 b- defN 22-May-24 14:17 coworks/cws/templates/terraform/role.j2
 -rw-rw-r--  2.0 unx        0 b- defN 23-Feb-02 09:07 coworks/extension/__init__.py
 -rw-rw-r--  2.0 unx     8790 b- defN 23-Feb-02 09:09 coworks/extension/odoo.py
--rw-rw-r--  2.0 unx     7223 b- defN 23-Feb-13 15:59 coworks/extension/xray.py
+-rw-rw-r--  2.0 unx     7619 b- defN 23-Apr-27 10:54 coworks/extension/xray.py
 -rw-rw-r--  2.0 unx        0 b- defN 22-Jul-30 18:16 coworks/tech/__init__.py
 -rw-rw-r--  2.0 unx    10622 b- defN 23-Feb-02 09:07 coworks/tech/directory.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Aug-17 13:01 tests/__init__.py
 -rw-rw-r--  2.0 unx     1380 b- defN 23-Feb-02 09:07 tests/conftest.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Mar-29 09:57 tests/coworks/__init__.py
--rw-rw-r--  2.0 unx     4424 b- defN 23-Feb-02 09:07 tests/coworks/event.py
--rw-rw-r--  2.0 unx     2128 b- defN 22-Sep-19 10:21 tests/coworks/ms.py
+-rw-rw-r--  2.0 unx     4450 b- defN 23-Apr-27 10:54 tests/coworks/event.py
+-rw-rw-r--  2.0 unx     2209 b- defN 23-Apr-27 10:54 tests/coworks/ms.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Mar-29 09:57 tests/coworks/blueprint/__init__.py
 -rw-rw-r--  2.0 unx      725 b- defN 23-Feb-02 09:07 tests/coworks/blueprint/blueprint.py
 -rw-rw-r--  2.0 unx     3904 b- defN 23-Feb-02 09:07 tests/coworks/blueprint/test_admin.py
 -rw-rw-r--  2.0 unx     2349 b- defN 23-Feb-02 09:07 tests/coworks/blueprint/test_blueprint.py
 -rw-rw-r--  2.0 unx      954 b- defN 22-Dec-15 11:51 tests/coworks/blueprint/test_empty.py
 -rw-rw-r--  2.0 unx     3963 b- defN 23-Feb-02 09:07 tests/coworks/blueprint/test_mail.py
 -rw-rw-r--  2.0 unx      749 b- defN 22-Mar-28 13:01 tests/coworks/blueprint/test_overload.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Mar-29 09:57 tests/coworks/tech/__init__.py
 -rw-rw-r--  2.0 unx     1168 b- defN 23-Feb-02 09:07 tests/coworks/tech/test_async.py
 -rw-rw-r--  2.0 unx     1992 b- defN 23-Feb-02 09:07 tests/coworks/tech/test_auth.py
 -rw-rw-r--  2.0 unx     4336 b- defN 23-Feb-02 09:07 tests/coworks/tech/test_content_type.py
--rw-rw-r--  2.0 unx     8598 b- defN 23-Feb-02 09:07 tests/coworks/tech/test_event.py
--rw-rw-r--  2.0 unx    11912 b- defN 23-Feb-02 09:07 tests/coworks/tech/test_ms.py
+-rw-rw-r--  2.0 unx     8864 b- defN 23-Apr-27 10:54 tests/coworks/tech/test_event.py
+-rw-rw-r--  2.0 unx    11912 b- defN 23-Mar-14 13:36 tests/coworks/tech/test_ms.py
 -rw-rw-r--  2.0 unx     3715 b- defN 22-Jul-30 18:16 tests/coworks/tech/test_type.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Mar-29 09:57 tests/cws/__init__.py
 -rw-rw-r--  2.0 unx     2627 b- defN 23-Feb-02 09:07 tests/cws/test_cmd.py
 -rw-rw-r--  2.0 unx     5731 b- defN 23-Feb-02 09:07 tests/cws/test_deploy.py
 -rw-rw-r--  2.0 unx     4349 b- defN 23-Feb-02 09:07 tests/cws/test_environment.py
 -rw-rw-r--  2.0 unx     1464 b- defN 23-Feb-02 09:07 tests/cws/test_project_file.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Nov-03 09:34 tests/cws/src/__init__.py
 -rw-rw-r--  2.0 unx     1016 b- defN 23-Feb-02 09:07 tests/cws/src/app.py
 -rw-rw-r--  2.0 unx      916 b- defN 23-Feb-02 09:07 tests/cws/src/command.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Mar-29 09:57 tests/docs/__init__.py
 -rw-rw-r--  2.0 unx      846 b- defN 23-Feb-02 09:07 tests/docs/test_client.py
 -rw-rw-r--  2.0 unx     1300 b- defN 23-Feb-02 09:07 tests/docs/test_complete.py
 -rw-rw-r--  2.0 unx     2797 b- defN 23-Feb-02 09:07 tests/docs/test_first.py
 -rw-rw-r--  2.0 unx     1028 b- defN 23-Feb-02 09:07 tests/docs/test_hello.py
--rw-rw-r--  2.0 unx     1067 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/LICENSE.txt
--rw-rw-r--  2.0 unx     5052 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/METADATA
--rw-rw-r--  2.0 unx      110 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       50 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       14 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     7479 b- defN 23-Feb-16 10:15 coworks-0.8.3.dist-info/RECORD
-88 files, 264645 bytes uncompressed, 73720 bytes compressed:  72.1%
+-rw-rw-r--  2.0 unx     1067 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/LICENSE.txt
+-rw-rw-r--  2.0 unx     5051 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/METADATA
+-rw-rw-r--  2.0 unx      110 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       50 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       14 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     7479 b- defN 23-Apr-27 10:55 coworks-0.8.5.dist-info/RECORD
+88 files, 270320 bytes uncompressed, 74833 bytes compressed:  72.3%
```

## zipnote {}

```diff
@@ -240,26 +240,26 @@
 
 Filename: tests/docs/test_first.py
 Comment: 
 
 Filename: tests/docs/test_hello.py
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/LICENSE.txt
+Filename: coworks-0.8.5.dist-info/LICENSE.txt
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/METADATA
+Filename: coworks-0.8.5.dist-info/METADATA
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/WHEEL
+Filename: coworks-0.8.5.dist-info/WHEEL
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/entry_points.txt
+Filename: coworks-0.8.5.dist-info/entry_points.txt
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/top_level.txt
+Filename: coworks-0.8.5.dist-info/top_level.txt
 Comment: 
 
-Filename: coworks-0.8.3.dist-info/RECORD
+Filename: coworks-0.8.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## coworks/coworks.py

```diff
@@ -1,12 +1,13 @@
 import base64
 import io
 import itertools
 import logging
 import os
+import sys
 import traceback
 import typing as t
 from functools import partial
 from http.cookiejar import CookieJar
 from inspect import isfunction
 from pathlib import Path
 
@@ -293,15 +294,15 @@
     def token_authorizer(self, token: str) -> t.Union[bool, str]:
         """Defined the authorization process.
 
         If the returned value is False, all routes for all stages are denied.
         If the returned value is True, all routes for all stages are accepted.
         If the returned value is a string, then it must be a stage name and all routes are accepted for this stage.
 
-        By default, no entry are accepted for security reason.
+        By default, just using the token authentification process (defined from terraform template).
         """
 
         return token == os.getenv('TOKEN')
 
     def auto_find_instance_path(self):
         """Instance path may be redefined by an environment variable.
         """
@@ -373,15 +374,15 @@
 
         try:
             res = self.token_authorizer(aws_event['authorizationToken'])
             self.logger.warning(f"Token authorizer return is : {res}")
             return TokenResponse(res, aws_event['methodArn']).json
         except Exception as e:
             self.logger.error(f"Error in token handler for {self.name} : {e}")
-            self.logger.error(''.join(traceback.format_exception(None, e, e.__traceback__)))
+            self.logger.error(getattr(e, '__traceback__'))
             return TokenResponse(False, aws_event['methodArn']).json
 
     def _api_handler(
             self, aws_event: t.Dict[str, t.Any], aws_context: t.Dict[str, t.Any]
     ) -> t.Optional[t.Union[dict, str]]:
         """API handler.
         """
@@ -399,33 +400,29 @@
                 if invocation_type == 'Event':
                     self.store_response(resp, aws_event['headers'])
 
                 # Encodes binary content
                 if type(resp) is not dict:
                     resp = base64.b64encode(resp).decode('ascii')
                     content_length = len(resp) if self.logger.getEffectiveLevel() == logging.DEBUG else "N/A"
-                    self.logger.debug(f"API returns binary content [length: {content_length}]")
+                    self.logger.warning(f"API returns binary content [length: {content_length}]")
                     return resp
 
                 # Adds trace
-                if 'headers' in resp:
-                    content_length = int(resp['headers'].get('content_length', self.size_max_for_debug))
-                else:
-                    content_length = self.size_max_for_debug
-
-                if self.logger.getEffectiveLevel() == logging.DEBUG and content_length < self.size_max_for_debug:
-                    self.logger.debug(f"API returns {resp}")
-                    return resp
+                self.logger.warning(f"API returns code {resp.get('statusCode')} and headers {resp.get('headers')}")
+                self.logger.warning(f"API body: {str(resp.get('body'))[:self.size_max_for_debug]}")
 
-                self.logger.debug(f"API returns code {resp.get('statusCode')} and headers {resp.get('headers')}")
                 return resp
 
         except Exception as e:
             self.logger.error(f"Exception in api handler for {self.name} : {e}")
-            self.logger.error(''.join(traceback.format_exception(None, e, e.__traceback__)))
+            parts = ["Traceback (most recent call last):\n"]
+            parts.extend(traceback.format_stack(limit=15)[:-2])
+            parts.extend(traceback.format_exception(*sys.exc_info())[1:])
+            self.logger.error(f"Traceback: {parts}")
             headers = {'content_type': "application/json"}
             return self._aws_payload(str(e), InternalServerError.code, headers)
 
     def _flask_handler(self, environ: t.Dict[str, t.Any], start_response: t.Callable[[t.Any], None]):
         """Flask handler.
         """
         return self.wsgi_app(environ, start_response)
@@ -437,14 +434,15 @@
             # Set predefined environment variables
             self.config['X-CWS-S3Bucket'] = BIZ_BUCKET_HEADER_KEY
             self.config['X-CWS-S3Key'] = BIZ_KEY_HEADER_KEY
 
             self._cws_conf_updated = True
 
     def _check_token(self):
+        """Simulates the authorization process of lambda if not in lambda context."""
         if not request.in_lambda_context:
 
             # No token check on local
             if get_app_stage() == DEFAULT_LOCAL_STAGE:
                 return
 
             # Get no_auth option for this entry
```

## coworks/utils.py

```diff
@@ -32,14 +32,15 @@
 
 BIZ_BUCKET_HEADER_KEY: str = 'X-CWS-S3Bucket'
 BIZ_KEY_HEADER_KEY: str = 'X-CWS-S3Key'
 
 
 def add_coworks_routes(app, bp_state: BlueprintSetupState = None) -> None:
     """ Creates all routes for a microservice.
+
     :param app the app microservice
     :param bp_state the blueprint state
     """
     # Adds entrypoints
     stage = get_app_stage()
     scaffold = bp_state.blueprint if bp_state else app
     method_members = inspect.getmembers(scaffold.__class__, lambda x: inspect.isfunction(x))
@@ -120,26 +121,24 @@
                     kwargs = dict(**kwargs, **as_fun_params(data))
 
                 # Adds parameters from body parameter
                 elif request.method in ['POST', 'PUT', 'DELETE']:
                     try:
                         if request.is_json:
                             data = request.get_data()
-                            if not data:
-                                kwargs = {**kwargs}
-                            else:
+                            if data:
                                 data = request.json
                                 if type(data) is dict:
-                                    kwargs = dict(**kwargs, **as_fun_params(data, False))
+                                    kwargs = {**kwargs, **as_fun_params(data, False)}
                                 else:
                                     kwargs[kwarg_keys[0]] = data
                         elif request.is_multipart:
                             data = request.form.to_dict(False)
                             files = request.files.to_dict(False)
-                            kwargs = dict(**kwargs, **as_fun_params(data), **as_fun_params(files))
+                            kwargs = {**kwargs, **as_fun_params(data), **as_fun_params(files)}
                         elif request.is_form_urlencoded:
                             data = request.form.to_dict(False)
                             kwargs = dict(**kwargs, **as_fun_params(data))
                         else:
                             data = request.values.to_dict(False)
                             kwargs = dict(**kwargs, **as_fun_params(data))
                     except Exception as e:
```

## coworks/version.py

```diff
@@ -1 +1 @@
-__version__ = "0.8.3"
+__version__ = "0.8.5"
```

## coworks/wrappers.py

```diff
@@ -1,17 +1,23 @@
 import base64
 import io
 import json
+import re
 import typing as t
+import urllib
+import urllib.parse
 
 from flask import Request as FlaskRequest
 from flask import Response as FlaskResponse
 from flask import current_app
+from requests_toolbelt.multipart.decoder import MultipartDecoder
 from werkzeug.datastructures import ETags
+from werkzeug.datastructures import FileStorage
 from werkzeug.datastructures import Headers
+from werkzeug.datastructures import MultiDict
 from werkzeug.exceptions import HTTPException, BadRequest
 from werkzeug.exceptions import MethodNotAllowed
 from werkzeug.exceptions import NotFound
 from werkzeug.routing import MapAdapter
 
 
 class TokenResponse:
@@ -79,19 +85,21 @@
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
 
 
 class CoworksRequest(FlaskRequest):
 
     def __init__(self, environ, **kwargs):
-        self.aws_event = environ.get('aws_event')
+        self.aws_event: dict = environ.get('aws_event')
         self.aws_context = environ.get('aws_context')
-        self.aws_query_string = environ.get('aws_query_string')
-        self.aws_body = environ.get('aws_body')
+        self.aws_query_string: MultiDict = environ.get('aws_query_string')
+        self.aws_body: t.Union[str, bytes] = environ.get('aws_body')
         self._in_lambda_context: bool = self.aws_event is not None
+        self.__stream = self.__form = self.__files = None
+        self.__data = self.__json = None
 
         super().__init__(environ, **kwargs)
 
         if self._in_lambda_context:
             self.headers = Headers(self.aws_event.get('headers'))
 
     @property
@@ -129,53 +137,113 @@
         return self.aws_query_string
 
     @property
     def stream(self):
         if not self.in_lambda_context:
             return super().stream
 
-        print(self.is_multipart)
-        print(self.is_form_urlencoded)
-
-        if self.is_multipart:
-            return io.BytesIO(base64.b64decode(self.aws_body))
-        if self.is_form_urlencoded:
-            return io.BytesIO(self.aws_body.encode('ascii'))
-        raise BadRequest(f'Undefined mime-type: {self.mimetype}')
+        if self.__stream is None:
+            self._load_stream_form_files()
+        return self.__stream
 
     @property
     def form(self):
         if not self.in_lambda_context:
             return super().form
 
-        parser = self.make_form_data_parser()
-        data = parser.parse(
-            self.stream,
-            self.mimetype,
-            self.content_length,
-            self.mimetype_params,
-        )
-        d = self.__dict__
-        d["stream"], d["form"], d["files"] = data
-        return d["form"]
+        if self.__form is None:
+            self._load_stream_form_files()
+        return self.__form
+
+    @property
+    def files(self):
+        if not self.in_lambda_context:
+            return super().files
+
+        if self.__files is None:
+            self._load_stream_form_files()
+        return self.__files
 
     def get_data(self, **kwargs):
         if not self.in_lambda_context:
             return super().get_data(**kwargs)
-        return json.dumps(self.aws_body) if kwargs.get('as_text', False) else self.aws_body
+
+        if self.__data is None:
+            if kwargs.get('as_text', False):
+                self.__data = json.dumps(self.aws_body) if self._body_is_dict else self.aws_body
+            self.__data = self.aws_body if self._body_is_dict else json.loads(self.aws_body)
+        return self.__data
 
     def get_json(self, **kwargs):
         if not self.in_lambda_context:
             return super().get_json(**kwargs)
-        return self.aws_body
+
+        if self.__json is None:
+            self.__json = self.aws_body if self._body_is_dict else json.loads(self.aws_body)
+        return self.__json
 
     @property
     def if_match(self):  # No cache
         return ETags()
 
     @property
     def if_none_match(self):  # No cache
         return ETags()
 
     @property
     def if_modified_since(self):  # No cache
         return None
+
+    @property
+    def _body_is_dict(self) -> bool:
+        return type(self.aws_body) is dict
+
+    def _load_stream_form_files(self) -> None:
+
+        # Stream part
+        if self.is_multipart:
+            self.__stream = io.BytesIO(base64.b64decode(self.aws_body))
+        elif self.is_form_urlencoded:
+            self.__stream = io.BytesIO(self.aws_body.encode('ascii'))
+        else:
+            raise BadRequest(f'Undefined mime-type for stream body: {self.mimetype}')
+
+        if self.is_multipart:
+            self.__files = MultiDict()
+            self.__form = MultiDict()
+            multipart_data = MultipartDecoder(self.aws_body, self.content_type)
+            for part in multipart_data.parts:
+
+                # Files part
+                if b'content-disposition' in part.headers:
+                    content_disposition = part.headers.get(b'content-disposition').decode("utf-8")
+                    filename_regexp = "filename=\"(?P<filename>[^\"]+)\""
+                    match = re.search(filename_regexp, content_disposition)
+                    filename = match.group('filename') if match else None
+
+                    name_regexp = "name=\"(?P<name>[^\"]+)\""
+                    match = re.search(name_regexp, content_disposition)
+                    name = match.group('name') if match else None
+
+                    if b'content-type' in part.headers:
+                        content_type = part.headers.get(b'content-type').decode("utf-8")
+                    else:
+                        content_type = None
+
+                    if b'content-length' in part.headers:
+                        content_length = part.headers.get(b'content-length').decode("utf-8")
+                    else:
+                        content_length = None
+
+                    self.__files[filename] = FileStorage(
+                        stream=io.BytesIO(part.content),
+                        filename=filename,
+                        name=name,
+                        content_type=content_type,
+                        content_length=content_length,
+                    )
+
+                # Form part
+
+        elif self.is_form_urlencoded:
+            self.__files = MultiDict()
+            self.__form = MultiDict(urllib.parse.parse_qs(self.aws_body))
```

## coworks/biz/group.py

```diff
@@ -1,109 +1,122 @@
 import typing as t
 
 from airflow.models import BaseOperator
 from airflow.operators.python import PythonOperator
 from airflow.utils.task_group import TaskGroup
+from airflow.utils.trigger_rule import TriggerRule
 
 from coworks.biz.operators import AsyncTechServicePullOperator
 from coworks.biz.operators import TechMicroServiceOperator
 from coworks.biz.sensors import AsyncTechMicroServiceSensor
 
 
 class CoworksTaskGroup(TaskGroup):
+    """ Asynchronous tasks group.
+
+    .. versionchanged:: 0.8.4
+        Added the ``start_id``, ``end_id`` properties.
+    """
 
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
-        self.__call_task: t.Optional[BaseOperator] = None
-        self.__read_task: t.Optional[BaseOperator] = None
+        self.transformer_task: t.Optional[BaseOperator] = None
+        self.call_task: t.Optional[BaseOperator] = None
+        self.wait_task: t.Optional[BaseOperator] = None
+        self.read_task: t.Optional[BaseOperator] = None
 
     @property
-    def output(self):
-        return self.read_task.output
+    def start_id(self):
+        return f'{self._group_id}.transformer' if self.transformer_task else f'{self._group_id}.call'
 
     @property
-    def call_task(self):
-        return self.__call_task
-
-    @call_task.setter
-    def call_task(self, task):
-        self.__call_task = task
+    def end_id(self):
+        return f'{self._group_id}.read' if self.read_task else f'{self._group_id}.wait'
 
     @property
-    def read_task(self):
-        return self.__read_task
-
-    @read_task.setter
-    def read_task(self, task):
-        self.__read_task = task
+    def output(self):
+        return self.read_task.output
 
 
-def TechMicroServiceAsyncGroup(group_id: str, transformer: t.Callable = None,
+def TechMicroServiceAsyncGroup(group_id: str, transformer: t.Callable = None, read: bool = True,
                                op_args: t.Optional[t.Collection[t.Any]] = None,
                                op_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,
-                               method: str = 'get',
-                               raise_errors: bool = True, timeout: int = 900, xcom_push: bool = True,
+                               method: str = 'get', timeout: int = 900,
+                               raise_errors: bool = True, raise_400_errors: bool = True,
+                               xcom_push: bool = True, trigger_rule=TriggerRule.ALL_SUCCESS,
                                **tech_kwargs):
     """Task group to allow asynchronous call of a TechMicroService.
 
     The returned value is defined in the task_id : '{group_id}.read'.
 
     :param group_id: group id.
     :param transformer: python transformer function.
+    :param read: do read task.
     :param op_args: python transformer args.
     :param op_kwargs: python transformer kwargs.
     :param method: microservice method called.
-    :param raise_errors: raises error if microservice call raised one.
+    :param raise_errors: raise error on client errors (default True).
+    :param raise_400_errors: raise error on client 400 errors (default True).
     :param timeout: asynchronous call timeout.
-    :param xcom_push:  Pushes result in XCom (default True).
+    :param trigger_rule: trigger rule to be set on first task.
+    :param xcom_push:  pushes result in XCom (default True).
 
+    .. versionchanged:: 0.8.4
+        Added the ``read`` parameter.
+    .. versionchanged:: 0.8.4
+        Added the ``trigger_rule`` parameter.
     .. versionchanged:: 0.8.0
         Added the ``transformer`` parameter.
     """
     with CoworksTaskGroup(group_id=group_id) as tg:
         if transformer:
-            transformer_task = PythonOperator(
-                task_id=transformer.__name__,
+            tg.transformer_task = PythonOperator(
+                task_id='transformer',
                 python_callable=transformer,
-                op_args = op_args,
-                op_kwargs = op_kwargs
+                op_args=op_args,
+                op_kwargs=op_kwargs,
+                trigger_rule=trigger_rule
             )
 
             if method.lower() == 'get':
                 if 'query_params' in tech_kwargs:
-                    transformer_task.log.warning(f"Calling transformer method with already query_params parameter call")
-                tech_kwargs['query_params'] = transformer_task.output
+                    tg.transformer_task.log.warning(
+                        f"Calling transformer method with already query_params parameter call")
+                tech_kwargs['query_params'] = tg.transformer_task.output
             else:
                 if 'json' in tech_kwargs:
-                    transformer_task.log.warning("Calling transformer method with already json parameter call")
-                tech_kwargs['json'] = transformer_task.output
+                    tg.transformer_task.log.warning("Calling transformer method with already json parameter call")
+                tech_kwargs['json'] = tg.transformer_task.output
 
-        call = TechMicroServiceOperator(
+        tg.call_task = TechMicroServiceOperator(
             task_id="call",
             asynchronous=True,
             method=method,
+            raise_errors=raise_errors,
+            raise_400_errors=raise_400_errors,
+            trigger_rule=trigger_rule if not transformer else TriggerRule.ALL_SUCCESS,
             **tech_kwargs,
         )
-        wait = AsyncTechMicroServiceSensor(
+
+        tg.wait_task = AsyncTechMicroServiceSensor(
             task_id='wait',
             cws_task_id=f'{group_id}.call',
             timeout=timeout,
         )
 
-        if xcom_push:
-            read = AsyncTechServicePullOperator(
+        if read:
+            tg.read_task = AsyncTechServicePullOperator(
                 task_id='read',
                 cws_task_id=f'{group_id}.call',
                 raise_errors=raise_errors,
+                raise_400_errors=raise_400_errors,
+                xcom_push=xcom_push,
             )
 
-    tg.call_task = call
-    call >> wait
+    tg.call_task >> tg.wait_task
 
     if transformer:
-        tg.transformer_task = transformer_task
-        transformer_task >> call
-    if xcom_push:
-        tg.read_task = read
-        wait >> read
+        tg.transformer_task >> tg.call_task
+    if read:
+        tg.wait_task >> tg.read_task
 
     return tg
```

## coworks/biz/operators.py

```diff
@@ -6,53 +6,61 @@
 import requests
 from airflow.exceptions import AirflowFailException
 from airflow.models.baseoperator import BaseOperator
 from airflow.operators.branch import BaseBranchOperator
 from airflow.providers.amazon.aws.hooks.s3 import S3Hook
 from airflow.providers.http.hooks.http import HttpHook
 
+XCOM_DEFAULT_KEY = 'return_value'
 XCOM_CWS_BUCKET = 'bucket'  # the AWS S3 bucket where the coworks techmicroservice result is stored
 XCOM_CWS_KEY = 'key'  # the AWS S3 key where the coworks techmicroservice result is stored
 XCOM_CWS_NAME = 'cws_name'
 XCOM_STATUS_CODE = 'status_code'
 
 
 class TechMicroServiceOperator(BaseOperator):
-    """Microservice operator.
-    The tech microservice may be called from its name or from it api_id, stage and token.
-
-    :param cws_name: the tech microservice name.
-    :param entry: the route entry.
-    :param method: the route method ('GET', 'POST').
-    :param no_auth: set to 'True' if no authorization is needded (default 'False').
-    :param query_params: query parameters for GET method.
-    :param json: dict data for POST method.
-    :param data: object to send in the body for POST method
-    :param stage: the microservice stage (default 'dev' if 'cws_name' not defined).
-    :param api_id: APIGateway id (must be defined if no 'cws_name').
-    :param token: Authorization token (must be defined if auth and no 'cws_name').
-    :param directory_conn_id: Connection defined for the directory service (default 'coworks_directory').
-    :param asynchronous: Asynchronous call (default False).
-    :param xcom_push: Pushes result in XCom (default True).
-    :param json_result: Returns a JSON value in 'return_value' (default True).
-    :param raise_400_errors: raise error on client 400 errors (default True).
-    :param accept: accept header value (default 'application/json').
-    :param headers: specific header values forced (default {}).
-    :param log_response: Trace result content (default False).
-    """
     template_fields = ["cws_name", "entry", "query_params", "json", "data"]
 
     def __init__(self, *, cws_name: str = None, entry: str = '/', method: str = 'get', no_auth: bool = False,
                  query_params: t.Union[dict, str] = None, json: t.Union[dict, str] = None,
                  data: t.Union[dict, str] = None,
                  stage: str = None, api_id: str = None, token: str = None,
-                 directory_conn_id: str = 'coworks_directory', asynchronous: bool = False,
-                 xcom_push: bool = True, json_result: bool = True, raise_400_errors: bool = True,
+                 raise_errors: bool = True, raise_400_errors: bool = True,
                  accept: str = 'application/json', headers: dict = None, log_response: bool = False,
+                 directory_conn_id: str = 'coworks_directory', asynchronous: bool = False,
+                 xcom_push: bool = True, json_result: bool = True,
+                 multiple_outputs_transformer: t.Callable[[dict], dict] = None,
                  **kwargs) -> None:
+        """Microservice operator.
+        The tech microservice may be called from its name or from it api_id, stage and token.
+
+        :param cws_name: the tech microservice name.
+        :param entry: the route entry.
+        :param method: the route method ('GET', 'POST').
+        :param no_auth: set to 'True' if no authorization is needded (default 'False').
+        :param query_params: query parameters for GET method.
+        :param json: dict data for POST method.
+        :param data: object to send in the body for POST method
+        :param stage: the microservice stage (default 'dev' if 'cws_name' not defined).
+        :param api_id: APIGateway id (must be defined if no 'cws_name').
+        :param token: Authorization token (must be defined if auth and no 'cws_name').
+        :param directory_conn_id: connection defined for the directory service (default 'coworks_directory').
+        :param asynchronous: asynchronous call (default False).
+        :param xcom_push: pushes result in XCom (default True).
+        :param json_result: returns a JSON value in 'return_value' (default True).
+        :param raise_errors: raise error on client errors (default True).
+        :param raise_400_errors: raise error on client 400 errors (default True).
+        :param accept: accept header value (default 'application/json').
+        :param headers: specific header values forced (default {}).
+        :param log_response: trace result content (default False).
+        :param multiple_outputs_transformer: if defined, return a multi-output XCOM after tranformation.
+
+         .. versionchanged:: 0.8.4
+            Added the ``multiple_outputs_transformer`` parameter.
+        """
         super().__init__(**kwargs)
         self.cws_name = cws_name
         self.entry = entry.lstrip('/')
         self.method = method.lower()
         self.no_auth = no_auth
         self.log_response = log_response
         self.query_params = query_params
@@ -61,15 +69,17 @@
         self.stage = stage
         self.api_id = api_id
         self.token = token
         self.directory_conn_id = directory_conn_id
         self.asynchronous = asynchronous
         self.xcom_push_flag = xcom_push
         self.json_result = json_result
+        self.raise_errors = raise_errors
         self.raise_400_errors = raise_400_errors
+        self.multiple_outputs_transformer = multiple_outputs_transformer
         self._url = self._bucket = self._key = None
 
         if not self.cws_name and not self.api_id:
             raise AirflowFailException(f"The APIGateway id must be defined! (param 'api_id')")
         if not no_auth and not self.cws_name and not self.token:
             raise AirflowFailException(f"The authorization token id must be defined! (param 'token')")
 
@@ -79,14 +89,15 @@
             'Accept': accept,
         }
         if headers:
             self.headers.update(headers)
 
     def pre_execute(self, context):
         """Gets url and token from name or parameters.
+
         Done only before execution not on DAG loading.
         """
         dag_run = context['dag_run']
         start_date = dag_run.start_date.timestamp()
         trace_id = f"Root=1-{hex(int(start_date))[2:]}-{f'cws{dag_run.id:0>9}'.encode().hex()}"
         self.headers['x-amzn-trace-id'] = trace_id
         self.log.info(f"Cws trace: {trace_id}")
@@ -115,34 +126,35 @@
         if not self.no_auth:
             self.headers['Authorization'] = self.token
 
     def execute(self, context):
         """Call TechMicroService.
         """
         resp = self._call_cws(context)
+
+        if self.raise_errors:
+            if (self.raise_400_errors and resp.status_code >= 400) or resp.status_code >= 500:
+                if self.xcom_push_flag:
+                    self._push_response(context, resp)
+
+                msg = f"The TechMicroService {self.cws_name} had an error {resp.status_code}!"
+                self.log.error(msg)
+                raise AirflowFailException(msg)
+
         if self.xcom_push_flag:
             self._push_response(context, resp)
 
     def _call_cws(self, context):
         """Method used by operator and sensor."""
         self.log.info(f"Calling {self.method.upper()} method to {self._url}")
         resp = requests.request(
             self.method.upper(), self._url, headers=self.headers,
             params=self.query_params, json=self.json, data=self.data
         )
         self.log.info(f"Resulting status code : {resp.status_code}")
-
-        # Manages status
-        if self.raise_400_errors and resp.status_code >= 400:
-            self.log.error(f"Bad request: {resp.text}'")
-            raise AirflowFailException(f"The TechMicroService {self.cws_name} had a client error {resp.status_code}!")
-        if resp.status_code >= 500:
-            self.log.error(f"Internal error: {resp.text}'")
-            raise AirflowFailException(
-                f"The TechMicroService {self.cws_name} had an internal error {resp.status_code}!")
         return resp
 
     def _push_response(self, context, resp):
         # Return values or store file information
         self.xcom_push(context, XCOM_CWS_NAME, self.cws_name or self.api_id)
         if self.asynchronous:
             self.xcom_push(context, XCOM_CWS_BUCKET, self._bucket)
@@ -157,54 +169,71 @@
             else:
                 returned_value = resp.text
 
             if self.log_response:
                 self.log.info(returned_value)
 
             self.xcom_push(context, XCOM_STATUS_CODE, resp.status_code)
-            self.xcom_push(context, 'return_value', returned_value)
+            if self.multiple_outputs_transformer:
+                for key, value in self.multiple_outputs_transformer(returned_value):
+                    self.xcom_push(context, key, value)
 
+            self.xcom_push(context, XCOM_DEFAULT_KEY, returned_value)
 
-class AsyncTechServicePullOperator(BaseOperator):
-    """Pull in XCom a microservice result when its was called asynchronously.
 
-    :param cws_task_id: the tech microservice called asynchronously.
-    :param aws_conn_id: aws connection (default 'aws_s3').
-    :param raise_errors: raises error if the called microserrvice did (default True).
-    """
+class AsyncTechServicePullOperator(BaseOperator):
 
     def __init__(self, *, cws_task_id: str = None, aws_conn_id: str = 'aws_s3',
-                 raise_errors: bool = True, **kwargs) -> None:
+                 raise_errors: bool = True, raise_400_errors: bool = True,
+                 xcom_push: bool = True, **kwargs) -> None:
+        """Pull in XCom a microservice result when its was called asynchronously.
+
+        :param cws_task_id: the tech microservice called asynchronously.
+        :param aws_conn_id: aws connection (default 'aws_s3').
+        :param raise_errors: raise error on client errors (default True).
+        :param raise_400_errors: raise error on client 400 errors (default True).
+        :param xcom_push: pushes result in XCom (default True).
+
+        .. versionchanged:: 0.8.4
+            Added the ``xcom_push`` parameter.
+        """
+
         super().__init__(**kwargs)
         self.cws_task_id = cws_task_id
         self.aws_conn_id = aws_conn_id
         self.raise_errors = raise_errors
+        self.raise_400_errors = raise_400_errors
+        self.xcom_push_flag = xcom_push
 
     def execute(self, context):
         ti = context["ti"]
 
         # Reads bucket file content
         bucket_name = ti.xcom_pull(task_ids=self.cws_task_id, key=XCOM_CWS_BUCKET)
         key = ti.xcom_pull(task_ids=self.cws_task_id, key=XCOM_CWS_KEY)
         s3 = S3Hook(aws_conn_id=self.aws_conn_id)
         file = s3.download_file(key, bucket_name=bucket_name)
         with open(file, "r") as myfile:
             data = myfile.read()
         payload = loads(data)
 
         status_code = payload['statusCode']
+        self.xcom_push(context, XCOM_STATUS_CODE, status_code)
 
-        if self.raise_errors and status_code >= 300:
-            self.log.error(f"Error: {payload['body']}'")
-            raise AirflowFailException(f"TechMicroService doesn't complete successfully: {status_code}")
+        if self.raise_errors:
+            if (self.raise_400_errors and status_code >= 400) or status_code >= 500:
+                if self.xcom_push_flag:
+                    self.xcom_push(context, XCOM_DEFAULT_KEY, payload.get('body'))
+                self.log.error(f"Error: {payload['body']}'")
+                raise AirflowFailException(f"TechMicroService doesn't complete successfully: {status_code}")
 
-        self.xcom_push(context, XCOM_STATUS_CODE, status_code)
-        if payload['isBase64Encoded']:
-            return base64.b64decode(payload['body'])
-        return payload['body']
+        if self.xcom_push_flag:
+            if payload['isBase64Encoded']:
+                return base64.b64decode(payload['body'])
+            return payload['body']
 
 
 class BranchTechMicroServiceOperator(BaseBranchOperator):
     """Branch operator based on TechMicroservice call.
 
     :param cws_task_id: the tech microservice task_id result tested to determine the branch.
     :param on_failure: the task_ids in case of status code returned >= 400.
```

## coworks/cws/project_templates/tech/app.py

```diff
@@ -1,11 +1,9 @@
 import os
 
-from flask import request
-
 from coworks import TechMicroService
 from coworks import entry
 from coworks.blueprint.admin_blueprint import Admin
 from coworks.blueprint.profiler_blueprint import Profiler
 from coworks.utils import get_app_stage
 
 
@@ -32,21 +30,21 @@
         @self.errorhandler(500)
         def handle(e):
             ...
 
     def init_cli(self):
         """
         from flask_migrate import Migrate
-        Migrate(app, db)
+        Migrate(self, db)
         """
 
     def token_authorizer(self, token):
-        # Redefined to allow specific verification
-        user_key = request.headers.get("USER_KEY")
-        return token == os.getenv('TOKEN') and user_key is not None
+        # Simple authorization process.
+        # If you want to access AWS event or context for a more complex case, override the function _token_handler.
+        return token == os.getenv('USER_KEYS').split(',')
 
     @entry
     def get(self):
         return 'project ready!\n'
 
 
 app = MyMicroService()
```

## coworks/extension/xray.py

```diff
@@ -1,16 +1,19 @@
 import logging
+import os
 import traceback
 import typing as t
 from functools import partial
 from functools import update_wrapper
 
 from aws_xray_sdk import global_sdk_config
 from aws_xray_sdk.core import patch_all
 from aws_xray_sdk.core.exceptions.exceptions import SegmentNotFoundException
+from aws_xray_sdk.core.recorder import TRACING_NAME_KEY
+from aws_xray_sdk.ext.flask.middleware import XRayMiddleware
 
 from coworks.globals import request
 from coworks.wrappers import CoworksResponse
 
 if t.TYPE_CHECKING:
     from coworks import TechMicroService
     from aws_xray_sdk.core import AWSXRayRecorder
@@ -47,14 +50,20 @@
                     patch_all()
                     app.errorhandler(500)(self.capture_exception)
                     self.capture_routes()
                     return
 
             self._app.logger.debug("Skipped capture routes because the SDK is currently disabled.")
 
+        if os.getenv(TRACING_NAME_KEY):
+            XRayMiddleware(app, self._recorder)
+        else:
+            msg = f"Flask XRayMiddleware not installed because environment variable {TRACING_NAME_KEY} not defined."
+            app.logger.info(msg)
+
         app.before_first_request_funcs = [first, *app.before_first_request_funcs]
 
     def capture_routes(self):
         for rule in self._app.url_map.iter_rules():
             view_function = self._app.view_functions[rule.endpoint]
 
             def route_captured(_view_function, *args, **kwargs):
@@ -62,15 +71,15 @@
                 subsegment = self._recorder.current_subsegment()
 
                 if subsegment:
                     try:
                         subsegment.put_metadata('context', lambda_context_to_json(aws_context), LAMBDA_NAMESPACE)
                         metadata = {
                             'service': self._app.name,
-                            'environ': request_environ(request),
+                            'environ': request_environ_to_json(request),
                         }
                         if request.is_json:
                             try:
                                 metadata['json'] = request.json
                             except (Exception,):
                                 metadata['data'] = request.get_data(cache=False, as_text=True)
                         elif request.is_multipart:
@@ -166,15 +175,15 @@
         'function_version': context.function_version,
         'memory_limit_in_mb': context.memory_limit_in_mb,
         'aws_request_id': context.aws_request_id,
         'remaining_time': context.get_remaining_time_in_millis(),
     }
 
 
-def request_environ(_request):
+def request_environ_to_json(_request):
     return {
         'in_lambda_context': _request.in_lambda_context,
         'is_multipart': _request.is_multipart,
         'is_form_urlencoded': _request.is_form_urlencoded,
         'max_content_length': _request.max_content_length,
         'endpoint': _request.endpoint,
         'query_string': _request.args,
```

## tests/coworks/event.py

```diff
@@ -1,7 +1,10 @@
+import json
+
+
 def get_event(entry_path, method, entry_path_parameters=None, params=None, body=None, headers=None):
     headers = headers or {
         'accept': '*/*',
         'authorization': 'token',
         'content-type': 'application/json'
     }
     return {
@@ -29,15 +32,15 @@
             'x-amzn-trace-id': 'Root=1-620f51ee-3f8b28746271cbea29b0084e',
             'x-forwarded-for': '91.170.42.203, 130.176.185.118',
             'x-forwarded-port': '443',
             'x-forwarded-proto': 'https',
             **headers
         },
         'multiValueHeaders': {},
-        'body': body or {},
+        'body': json.dumps(body or {}),
         'queryStringParameters': {},
         'multiValueQueryStringParameters': params or {},
         'pathParameters': {},
         'stageVariables': None,
         'isBase64Encoded': False,
         'entryPathParameters': entry_path_parameters or {},
         'requestContext': {
```

## tests/coworks/ms.py

```diff
@@ -73,14 +73,18 @@
         return f"get **param with {value} and {list(kwargs.keys())}"
 
     # composed path
     @entry
     def get_extended_content(self):
         return "hello world"
 
+    @entry
+    def get_dir_content(self):
+        return {'msg': "hello world"}
+
 
 class GlobalMS(TechMicroService):
 
     def token_authorizer(self, token):
         return True
 
     @entry
```

## tests/coworks/tech/test_event.py

```diff
@@ -124,14 +124,19 @@
             assert response['body'] == "get **param with 5 and ['other']"
             response = app(get_event('/kwparam2', 'put', params={"other": ['other'], "value": [5]}), empty_aws_context)
             assert response['statusCode'] == 200
             assert response['body'] == "get **param with 0 and []"
             response = app(get_event('/extended/content', 'get'), empty_aws_context)
             assert response['statusCode'] == 200
             assert response['body'] == "hello world"
+            event = get_event('/dir/content', 'get')
+            del event['headers']['content-type']
+            response = app(event, empty_aws_context)
+            assert response['statusCode'] == 200
+            assert response['body'] == {'msg': 'hello world'}
 
     def test_request_globals(self, empty_aws_context):
         app = GlobalMS()
         with app.app_context() as c:
             response = app(get_event('/event/method', 'get'), empty_aws_context)
             assert response['statusCode'] == 200
             assert response['body'] == "GET"
```

## Comparing `coworks-0.8.3.dist-info/LICENSE.txt` & `coworks-0.8.5.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `coworks-0.8.3.dist-info/METADATA` & `coworks-0.8.5.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: coworks
-Version: 0.8.3
+Version: 0.8.5
 Summary: Coworks is a unified compositional microservices framework using Flask on AWS serverless technologies.
 Home-page: https://github.com/gdoumenc/coworks
 Author: Guillaume Doumenc
 Author-email: gdoumenc@fpr-coworks.com
 License: MIT
 Project-URL: Documentation, https://coworks.readthedocs.io/
 Project-URL: Issue Tracker, https://github.com/gdoumenc/coworks/issues
@@ -69,16 +69,15 @@
 -------------
 
 * Setup and installation: `Installation <https://coworks.readthedocs.io/en/latest/installation.html>`_
 * Complete reference guide: `Documentation <https://coworks.readthedocs.io/>`_.
 * Samples:
     * layers : Get available CoWorks lambda layers: `CoWorks layers <https://2kb9hn4bs4.execute-api.eu-west-1.amazonaws.com/v1>`_.
     * website : Very simple website done as a simple microservice: `Website <https://3jr90vkbe5.execute-api.eu-west-1.amazonaws.com/v1>`_.
-* Read `FAQ <https://coworks.readthedocs.io/en/latest/faq.html/>`_ for other information.
-
+* Read `FAQ <https://coworks.readthedocs.io/en/master/faq.html/>`_ for other information.
 
 Contributing
 ------------
 
 We work hard to provide a high-quality and useful framework, and we greatly value
 feedback and contributions from our community. Whether it's a new feature,
 correction, or additional documentation, we welcome your pull requests. Please
```

## Comparing `coworks-0.8.3.dist-info/RECORD` & `coworks-0.8.5.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 coworks/__init__.py,sha256=0sOE11yGw9Y9BT4_6_L9hK0LjmJt8qIE5AAl-BIPvJM,241
 coworks/aws.py,sha256=oL74lFlbAN1R9JBURBmOte6knfDUSaC1ujK4b4wSK6o,2539
-coworks/coworks.py,sha256=WaNKO10N_5mrH6SY0RA4PDsBStaiog7PbgblXBfIOFs,17917
+coworks/coworks.py,sha256=-dEuc1BJAOv-N0Lyhw6Ta2lmMp_jT9sZM1yOGj6HeFg,17847
 coworks/globals.py,sha256=uLOnOMCwzXwnfb55x1ixV5RcbU__cZ496pGPFlJptUA,170
 coworks/operators.py,sha256=EZXMM5kIQ44ewE5wqMW0XBTS3Evt2KwzHUGCelf25uQ,208
 coworks/sensors.py,sha256=bKvvSuPaAzqUOaaEBfxs_mmizE2qIpx8f4QXfQFKdJY,204
-coworks/utils.py,sha256=vmCCHLDk8hnOcZ9jiZYLHubyws57fK6nWUo5jS-IgBc,12339
-coworks/version.py,sha256=otnwfmvJLUamPajTPUaIekiO9mA-2HPi-_h_E0N-uOQ,22
-coworks/wrappers.py,sha256=KTYISYRxKKf9IHpgSzDcO6LPKnhkWAj381-P5VHJxUc,5638
+coworks/utils.py,sha256=8m0O4I_ZMZvokg56zjWxdD5MjMLUHXE6vl-k8M-X6sg,12242
+coworks/version.py,sha256=K0kGrhh1kzVisZcoSkeuJdC06rTwxufV05Vy2hOVGoo,22
+coworks/wrappers.py,sha256=5GxtHN8OnfzGWMTRkTJTlefmxbQQ2PrX_Yz6UArvKFI,8358
 coworks/biz/__init__.py,sha256=qzY1ZRDhQBYvf2ldnxd1didQdOlPt968LwE1QSoeDTQ,1089
-coworks/biz/group.py,sha256=nOnM7CUCM9WVcRSjn1gH1PHfgeNwdQAO9J6ThExqTcA,3613
-coworks/biz/operators.py,sha256=uKfSmltqAdcFxj1X7Tf6yBKmA4R3--3kznXBuUjRlHE,10928
+coworks/biz/group.py,sha256=ZcH3cbfCsqzKAn_tpG3P3w-qGVgBTF15DensxDZO0lQ,4583
+coworks/biz/operators.py,sha256=SqRlUe7d_QH_aMTmUkYuWnbh-aVUnLpnMCPkGPXZ6wg,12294
 coworks/biz/sensors.py,sha256=x7nawaxUtmcYiGiYwVsBNC-rwVvwE0XzrzauyKRVFJk,1761
 coworks/blueprint/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 coworks/blueprint/admin_blueprint.py,sha256=jPz70hqZHY4KeS5N7ytzWeTPr0UQ4XaEFdFjdG58rtQ,7278
 coworks/blueprint/gsheets_blueprint.py,sha256=W3Z1nw1445293_rg06FQi_X2koJuTYAafsXnW2COvNI,5022
 coworks/blueprint/mail_blueprint.py,sha256=LSWlfWZwPixcffwPQkkfuTZXC2I7EyhL1-3M8b5zA7A,6891
 coworks/blueprint/okta_blueprint.py,sha256=_K-saQs1nrf4WuExvvEw-DFAIVDjOLulovfsW63JQjw,3761
 coworks/blueprint/profiler_blueprint.py,sha256=uFNHvh5Jwo_N26urrsdBk4dQgKH2nKPCFc-Bi90FEFI,490
@@ -24,15 +24,15 @@
 coworks/cws/deploy.py,sha256=g7b4x_YG0Fnuc5KkpwGmJp3mKV-zak4dxxEgt3H4Ir8,22580
 coworks/cws/exception.py,sha256=ysaGq7UydioqhcO2yS5bZ4iVrNwILIu2jg-z4RhwTQ8,136
 coworks/cws/new.py,sha256=N1TEGXJXNwaXf8Rm5qFxySf1JXPgkMvgX1ficXFanso,1381
 coworks/cws/utils.py,sha256=kIZPgBaScwrNADc-U8AeUqa2c_gyug5tEcTwW5x4q7A,2085
 coworks/cws/zip.py,sha256=ktPn-CiIdAJi_ffh8cX7P76MB-ZVLqBj5Js15MwMc3A,5265
 coworks/cws/project_templates/README.md,sha256=sYmUwIF_Zt9ltwvCPUJnEPgd5BqE0CV-ZvM5tLSEbqM,1091
 coworks/cws/project_templates/template.env,sha256=fwn3Qkv38BQ7a288eWO7KCRf5G0sWK0mQMKUzIISKlA,12
-coworks/cws/project_templates/tech/app.py,sha256=F8ZIuOZt1NJBNxzF6A_vtg6SioyIAZHSdof_vknuA7I,1315
+coworks/cws/project_templates/tech/app.py,sha256=XseCLJV0SV1jyr6jo-Zxc9qYyogKdz0VW39agTBe4x0,1333
 coworks/cws/templates/deploy.j2,sha256=yi4baDHpAcKQjIddKUZAYIsSIE2Wo_HgNiiDrwzYrTk,49
 coworks/cws/templates/destroy.j2,sha256=IJ8ic0CjyUFV9M0UYD3qRy7KxbLJW58LyNFPlHuY980,51
 coworks/cws/templates/list.j2,sha256=VE7oylydWqA250RuWnsSsbhoB2uDYh6Car1g7YPRJak,196
 coworks/cws/templates/project.cws.yml,sha256=N3vPn24iqn-uaETcvHeMt7vHlk72_nH8Olbwyx3OVBU,294
 coworks/cws/templates/terraform.j2,sha256=EaITmlN1CDLl04GTQDvBZw85XdhSFb6L1L61INi5Jb0,1556
 coworks/cws/templates/terraform/deploy.j2,sha256=10XrzxVQU_amAUyStcsa3GvW2j3D0B3hQ2MSljvseYA,300
 coworks/cws/templates/terraform/lambda.j2,sha256=Wcbuix2_QErB7DrtZ75yIk9LGWExExpakdxas1twecs,3347
@@ -41,34 +41,34 @@
 coworks/cws/templates/terraform/provider.j2,sha256=Dvu7cw79FoVVSS1weJpN8I6dpxq8mTVby4O-xOMiABE,946
 coworks/cws/templates/terraform/request_templates.j2,sha256=omBuY--LZTYpWl34nnlbXBKsZ_p76t2Lji2Hr_hIg9E,2791
 coworks/cws/templates/terraform/response_templates.j2,sha256=Upz5YYUnbUTAIwAQkVyd1EmUFsfVBqMsfAG25RxFIQo,1245
 coworks/cws/templates/terraform/rest_api.j2,sha256=ZofX0tI5HNa6DweFEYaoHYD11GXWVov5_q9u8wpxXh8,11324
 coworks/cws/templates/terraform/role.j2,sha256=MQFUS55sPxHQYTJZqoFBqlmf9VaEFH93qA3cX70Crog,3111
 coworks/extension/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 coworks/extension/odoo.py,sha256=l9FoAKX4C2CvHiQjye9QYC2OmGbQg1yzX4HEFVevJMA,8790
-coworks/extension/xray.py,sha256=96JLpYcQh8y8_hF5NCsP41fn29nuxdtf1w3yf6z2Rz4,7223
+coworks/extension/xray.py,sha256=kV7jDba9jwHkfDpe_6RvK9pmKhg2sRWdn_Kz9mgaRXY,7619
 coworks/tech/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 coworks/tech/directory.py,sha256=yATjqxpK81EA2zjcw2zKwz2ClVF_0Hy05FyZ01qXrow,10622
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/conftest.py,sha256=32O1j54ZObgm7yX_7mkuQgg88JUWxLzSzSSRN7d6x4Q,1380
 tests/coworks/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/coworks/event.py,sha256=q2cTEo6fez2vCrL_zFudAcS1i2G5yMPFfZelqDm19Ik,4424
-tests/coworks/ms.py,sha256=K2I1r0JPUg28YD1mKuGwgWqMKhlM823ULbNtyOt8tX0,2128
+tests/coworks/event.py,sha256=XPH2GGmiDN3bmezF-5B5PoDj5vqRTnBuF0DC9JKrrBI,4450
+tests/coworks/ms.py,sha256=IoMhQO5nLRNWV3F4sciSjJU7utqr0G4Y85lTruxpjiQ,2209
 tests/coworks/blueprint/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/coworks/blueprint/blueprint.py,sha256=ENwtPXwuiAPiHCAgRSUBC2pkHPfrFCHyYh8fmMcw9Bc,725
 tests/coworks/blueprint/test_admin.py,sha256=QlirDrGS9mMm-ZkShKdNwNfCn-BRrv1RU4EVh1rfHjw,3904
 tests/coworks/blueprint/test_blueprint.py,sha256=8pAd683_Ea9t_7vDAVqvooWS4R0MngrNgdB57AkRBno,2349
 tests/coworks/blueprint/test_empty.py,sha256=uSRotG8Zn54-9BmkOT5r-2W7cXCyuuQPc95R9vOO_NY,954
 tests/coworks/blueprint/test_mail.py,sha256=4gxwb9NyJkl0L3aDhqprejtfGIhLfuRh6cC7evp8eXY,3963
 tests/coworks/blueprint/test_overload.py,sha256=JyhU7GQRog8HYkq9yr4Fl9w-_2swD1q4D4c3Y6tolIg,749
 tests/coworks/tech/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/coworks/tech/test_async.py,sha256=Z-3CfnGllg8bE78RSmmNh3-gOkRQtls11YVNMmp0Rgc,1168
 tests/coworks/tech/test_auth.py,sha256=WlWSDMYwefkVaoMr6_UGD_S7daWoL1xE2AYjkz0BK7Q,1992
 tests/coworks/tech/test_content_type.py,sha256=-2EhxzCV8VQx1RUeHZ2465n1lg2YEFN5XAXoV5JtnVM,4336
-tests/coworks/tech/test_event.py,sha256=syL35UpLxmNM4ibRl_A5wR8bwENSbVq-lot4UsGZYiI,8598
+tests/coworks/tech/test_event.py,sha256=eNaSrTJzJPd8U57h9twc9LVAY6LShAETEI68LsGaGHE,8864
 tests/coworks/tech/test_ms.py,sha256=r7xEKlmVZJKEahdB_22c8oZWL2BHeKZj_vkBJKk_HXc,11912
 tests/coworks/tech/test_type.py,sha256=PjMLlsL13AxlTcjLihiLnVuOATurbtFu_FXIS90JcCI,3715
 tests/cws/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/cws/test_cmd.py,sha256=XYyr-KBHTUXSfyVAIpEx5D-gaQirJ6PDILhCFY3EKZM,2627
 tests/cws/test_deploy.py,sha256=vg8YxJ5FBZx7kJeFPJZLY3AxyNMyZBvKe9g8mTmVYZE,5731
 tests/cws/test_environment.py,sha256=cLaA-yOjd0sGtbeggJcWIkOIdC06FRKoaujhHa0DNTA,4349
 tests/cws/test_project_file.py,sha256=MaGvkqSD1DaTvuVSIpfdiaVjRkDP_NMCjQ5xWh7CMQI,1464
@@ -76,13 +76,13 @@
 tests/cws/src/app.py,sha256=E4FQfhbN-KGr8AJzJwNB5yKagZJt8maTdqh5YmCt07I,1016
 tests/cws/src/command.py,sha256=ZN9_2VvxpYDxrU0hMvWAD6I-9-ThgFigSucmBhOzx9g,916
 tests/docs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/docs/test_client.py,sha256=Sd8Woi64EWNY9x_6YZIJE0xGI33YU9q4GZvw-G0dR2o,846
 tests/docs/test_complete.py,sha256=yM4YkkwS4b_ilI_nsgugwKuwj5qXqdgwq4Y4CbvVKjw,1300
 tests/docs/test_first.py,sha256=pHagh-oI8dx_sD_WmHpdH2PfFRCRy7CvHixUqwU2pYk,2797
 tests/docs/test_hello.py,sha256=PcK_b3t4mrYig6jWTxbHo6781xcGeJb6cgxfiydIm90,1028
-coworks-0.8.3.dist-info/LICENSE.txt,sha256=H9lFQprvS8Lk-XzlT5V90nssU9NjTom5lEOF93JgJPU,1067
-coworks-0.8.3.dist-info/METADATA,sha256=GpfxNm2FNB46_a6F1eUi45ofHu_7fczZKV5Yt7dqMh8,5052
-coworks-0.8.3.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-coworks-0.8.3.dist-info/entry_points.txt,sha256=aTbgXsDq05y6oKVMJBtu4UgK39mdZZ11uinCkw6RZEk,50
-coworks-0.8.3.dist-info/top_level.txt,sha256=AGvgSI7NgzO4ydnGKMV7WpbfsfjerVh4XmhOAKVsMJs,14
-coworks-0.8.3.dist-info/RECORD,,
+coworks-0.8.5.dist-info/LICENSE.txt,sha256=H9lFQprvS8Lk-XzlT5V90nssU9NjTom5lEOF93JgJPU,1067
+coworks-0.8.5.dist-info/METADATA,sha256=cSPfjb-U0VH-W2ekp-y5vEdT9vlmBWcMbsVT4zsj3a4,5051
+coworks-0.8.5.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
+coworks-0.8.5.dist-info/entry_points.txt,sha256=aTbgXsDq05y6oKVMJBtu4UgK39mdZZ11uinCkw6RZEk,50
+coworks-0.8.5.dist-info/top_level.txt,sha256=AGvgSI7NgzO4ydnGKMV7WpbfsfjerVh4XmhOAKVsMJs,14
+coworks-0.8.5.dist-info/RECORD,,
```

